*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sftreeview.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfcollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: additem		&& Adds an item (backward compatibility)
		*m: calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: clear		&& Clears the collection
		*m: fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		*m: fillcollection		&& Loads the collection from persistent storage
		*m: getarray		&& Fills the passed array with information about objects in the collection
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*m: removeitem		&& Removes an item (backward compatibility)
		*m: savecollection		&& Saves the collection to persistent storage
		*m: saveitem		&& Saves the specified item to persistent storage
		*p: cerrormessage		&& The text of an error message
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lfilloninit		&& .T. if we're supposed to fill the collection when it's instantiated
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cerrormessage = 		&& The text of an error message
	Height = 23
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfcollection"
	oexception = .NULL.		&& A reference to an Exception object
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="clear" type="method" display="Clear"/>
		<memberdata name="fillarrayrow" type="method" display="FillArrayRow" favorites="True"/>
		<memberdata name="fillcollection" type="method" display="FillCollection"/>
		<memberdata name="getarray" type="method" display="GetArray"/>
		<memberdata name="lfilloninit" type="property" display="lFillOnInit" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="savecollection" type="method" display="SaveCollection"/>
		<memberdata name="saveitem" type="method" display="SaveItem" favorites="True"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="additem" type="method" display="AddItem"/>
		<memberdata name="removeitem" type="method" display="RemoveItem"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFCollection
		* Based On:						Collection
		* Purpose:						Base class for all Collection objects
		* Author:						Doug Hennig
		* Copyright:					(c) 2003-2008 Stonefield Systems Group Inc.
		* Last revision:				05/22/2008
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	None
		*
		* Changes in "Based On" class methods:
		*	Add:						store upper-cased key so case-insensitive and
		*									ignore duplicate keys
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GetKey:						handle case-insensitivity
		*	Init:						calls FillCollection if lFillOnInit is .T.
		*	Item:						return .NULL. if the item isn't found and
		*								handle case-insensitivity
		*	Remove:						handle case-insensitivity
		*
		* Custom public properties added:
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*	lFillOnInit:				.T. if we're supposed to fill the collection
		*								when it's instantiated
		*	oException:					a reference to an Exception object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AddItem:					adds an item (backward compatibility)
		*	Clear:						clears the collection
		*	GetArray:					fills the passed array with information about
		*								objects in the collection
		*	FillCollection:				loads the collection from persistent storage
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*	RemoveItem:					removes an item (backward compatibility)
		*	SaveCollection:				saves the collection to persistent storage
		*	SaveItem:					saves the specified item to persistent storage
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*	FillArrayRow:				fills the specified row in the passed array
		*								with information about the current item
		*==============================================================================
		
	ENDPROC

	PROCEDURE Add
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local lcKey
		do case
			case pcount() = 1
				dodefault(tuItem)
			case vartype(tcKey) = 'C'
				lcKey = upper(alltrim(tcKey))
				do case
					case This.GetKey(lcKey) > 0
					case pcount() = 2
						dodefault(tuItem, lcKey)
					case pcount() = 3
						dodefault(tuItem, lcKey, tuBefore)
					case pcount() = 4
						dodefault(tuItem, lcKey, tuBefore, tuAfter)
				endcase
			case pcount() = 3
				dodefault(tuItem, tcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		nodefault
		
	ENDPROC

	PROCEDURE additem		&& Adds an item (backward compatibility)
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local luReturn
		do case
			case pcount() = 1
				luReturn = This.Add(tuItem)
			case pcount() = 2
				luReturn = This.Add(tuItem, tcKey)
			case pcount() = 3
				luReturn = This.Add(tuItem, tcKey, tuBefore)
			case pcount() = 4
				luReturn = This.Add(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		return luReturn
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if the method that called this method was called from a method of this class or an ancestor
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998-2005 Stonefield Systems Group Inc.
		* Last Revision:	01/29/2005
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE clear		&& Clears the collection
		This.Remove(-1)
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROTECTED PROCEDURE fillarrayrow		&& Fills the specified row in the passed array with information about the current item
		lparameters taArray, ;
			tnItem, ;
			toItem
		taArray[tnItem] = toItem.Name
		
	ENDPROC

	PROCEDURE fillcollection		&& Loads the collection from persistent storage
		* Abstract method
		
	ENDPROC

	PROCEDURE getarray		&& Fills the passed array with information about objects in the collection
		lparameters taArray
		local lnItem, ;
			loItem
		if This.Count > 0
			dimension taArray[This.Count]
		else
			dimension taArray[1]
		endif This.Count > 0
		lnItem = 0
		for each loItem in This foxobject
			lnItem = lnItem + 1
			This.FillArrayRow(@taArray, lnItem, loItem)
		next loItem
		return This.Count
		
	ENDPROC

	PROCEDURE GetKey
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex  = upper(alltrim(tuIndex))
			luReturn = dodefault(lcIndex)
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Init
		* Fill the collection if we're supposed to.
		
		with This
			if .lFillOnInit
				.FillCollection()
			endif .lFillOnInit
		endwith
		
	ENDPROC

	PROCEDURE Item
		lparameters tuIndex
		local luReturn, ;
			lcIndex
		luReturn = .NULL.
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				luReturn = dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			try
				luReturn = dodefault(tuIndex)
			catch
			endtry
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

	PROCEDURE Remove
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(alltrim(tuIndex))
			if This.GetKey(lcIndex) > 0
				dodefault(lcIndex)
			endif This.GetKey(lcIndex) > 0
		else
			dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		
	ENDPROC

	PROCEDURE removeitem		&& Removes an item (backward compatibility)
		lparameters tuIndex
		return This.Remove(tuIndex)
		
	ENDPROC

	PROCEDURE savecollection		&& Saves the collection to persistent storage
		local loItem
		for each loItem in This foxobject
			This.SaveItem(loItem)
		next loItem
		
	ENDPROC

	PROCEDURE saveitem		&& Saves the specified item to persistent storage
		lparameters toItem
		
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfstack AS sfcollection OF "sftreeview.vcx" 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: pop		&& Pops an item off the stack
		*m: push		&& Pushes an item onto the stack
	*</DefinedPropArrayMethod>

	Name = "sfstack"
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="clear" type="method" display="Clear"/>
		<memberdata name="fillarrayrow" type="method" display="FillArrayRow" favorites="True"/>
		<memberdata name="fillcollection" type="method" display="FillCollection"/>
		<memberdata name="getarray" type="method" display="GetArray"/>
		<memberdata name="lfilloninit" type="property" display="lFillOnInit" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="savecollection" type="method" display="SaveCollection"/>
		<memberdata name="saveitem" type="method" display="SaveItem" favorites="True"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="additem" type="method" display="AddItem"/>
		<memberdata name="removeitem" type="method" display="RemoveItem"/>
		<memberdata name="push" type="method" display="Push"/>
		<memberdata name="pop" type="method" display="Pop"/>
		</VFPData>
	
	PROCEDURE pop		&& Pops an item off the stack
		local luValue
		with This
			if .Count > 0
				luValue = .Item(.Count)
				.Remove(.Count)
			else
				luValue = .NULL.
			endif This.Count > 0
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE push		&& Pushes an item onto the stack
		lparameters tuValue
		This.Add(tuValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sftimer AS timer 		&& The base class for all Timer objects
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class specified as Library,Class)
		*p: lrelease		&& .T. as the object is being released
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class specified as Library,Class)
	Height = 23
	lrelease = .F.		&& .T. as the object is being released
	Name = "sftimer"
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFTimer
		* Based On:						Timer
		* Purpose:						The base class for all Timer objects
		* Author:						Doug Hennig
		* Copyright:					(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:				12/15/2005
		* Include file:					SFCtrls.H
		*
		* Changes in "Based On" class properties:
		*	Height:						23 so the object is small when dropped on a form
		*	Width:						23 so the object is small when dropped on a form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Copyright:		(c) 1998, 2000 Stonefield Systems Group Inc.
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Copyright:		(c) 1998 Stonefield Systems Group Inc.
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.oHook is .NULL.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		This.oHook = .NULL.
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
	ENDPROC

ENDDEFINE

DEFINE CLASS sftreeviewcontainer AS sfcontainer OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oTree" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oImageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrSync" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oStack" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrReload" UniqueID="" Timestamp="" />

	#INCLUDE "sftreeview.h"
	*<DefinedPropArrayMethod>
		*m: beforeselectnode		&& Fires before a new node is selected
		*m: calctwipsperpixel		&& Calculate the conversion factor between VFP window units (in pixels) and TreeView window units (in twips)
		*m: candrop		&& Returns .T. if the specified source can be dropped on the specified node
		*m: canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		*m: createnodeobject		&& Returns an object with properties about a node in the TreeView
		*m: deletenode		&& Deletes the selected node
		*m: getchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		*m: getdragdropdataobject		&& Returns an object with properties about a dragged object and the node it's dropped on
		*m: getnodeitemfromnode		&& Returns a node item object from the specified TreeView node
		*m: getnodekey		&& Gets the key for the specified node type and ID (not called from anywhere but can be implemented and called)
		*m: getnodeundermouse		&& Returns a reference to the node under the mouse
		*m: getregistrykey		&& Gets the Registry key to use
		*m: getrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		*m: getsinglenode		&& Creates and populates a single node object
		*m: gettypeandidfromnode		&& Returns an object containing Type and ID properties for the specified node
		*m: goback		&& Goes back to the previously selected node
		*m: handledragdrop		&& Handles the completion of a DragDrop operation
		*m: insertnode		&& Inserts a new node
		*m: loadexpandednode		&& Loads the children for the specified node
		*m: loadimages		&& Loads the ImageList control with desired images
		*m: loadnode		&& Loads the specified node into the TreeView
		*m: loadnodechildren		&& Loads the children of the specified node
		*m: loadtree		&& Loads the TreeView
		*m: locktreeview		&& Locks the TreeView so updates don't appear immediately
		*m: nodeclicked		&& Called when a node is clicked
		*m: oselectednode_access
		*m: pushkey		&& Pushes the specified key onto the stack
		*m: removenode		&& Removes the selected node
		*m: restoreselectednode		&& Restores the selected node from whereever it was saved when this was last used
		*m: saveselectednode		&& Saves the selected node so it can be restored at restart
		*m: selectnode		&& Selects the specified node
		*m: settreeviewbackcolor		&& Sets the background color of the TreeView
		*m: treeafterlabeledit		&& Called after the text of a node has been edited in the TreeView
		*m: treebeforelabeledit		&& Called before the text of a node is edited in the TreeView
		*m: treedblclick		&& Fired when the user double-clicks on the TreeView
		*m: treeexpand		&& Called when a node is expanded in the TreeView
		*m: treekeydown		&& Called when a key is pressed when the TreeView has focus
		*m: treemousedown		&& Called when a mouse button is pressed over the TreeView
		*m: treemouseup		&& Called when a mouse button is released over the TreeView
		*m: treenodecheck		&& Called when a node is checked in the TreeView
		*m: treenodeclick		&& Called when a node is selected in the TreeView
		*m: treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		*m: treeoledragdrop		&& Called when an OLEDragDrop event occurs in the TreeView
		*m: treeoledragover		&& Called when an OLEDragOver event occurs in the TreeView
		*m: treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
		*p: ccurrentnodeid		&& The ID of the currently selected node
		*p: ccurrentnodekey		&& The key of the currently selected node
		*p: ccurrentnodetext		&& The text of the currently selected node
		*p: ccurrentnodetype		&& The type of the currently selected node
		*p: clastnode		&& The key for the node selected the last time this container was used
		*p: cregistrykey		&& The key used to persist expanded and selected nodes
		*p: cregistrykeysuffix		&& The subnode to use under the parent form's Registry key to store values for this control
		*p: lallowdelete		&& .T. if the user can delete a node by pressing Delete
		*p: lallowinsert		&& .T. if the user can insert a node by pressing Insert
		*p: lallowrename		&& .T. if the user can rename a node
		*p: lautoloadchildren		&& .T. if child nodes are loaded when the TreeView is loaded
		*p: ldraginprogress		&& .T. if a drag operation is in progress
		*p: lexpanded		&& .T. if the selected node should be expanded or not (double-clicking on a node causes it to be expanded when it shouldn't)
		*p: lexpandondblclick		&& .T. to expand a parent node on a double-click
		*p: linitialized		&& .T. once all the tasks in Init are done
		*p: lloading		&& .T. if we're loading the TreeView
		*p: lloadtreeviewatstartup		&& .T. to load the TreeView control when the container is instantiated
		*p: lneedreload		&& .T. if LoadTree was called during a drag operation, meaning we need to call it again after the drag is complete
		*p: lrestoreoninit		&& .T. to restore selected and expanded nodes at startup
		*p: lsortrootnodes		&& .T. to sort the root nodes
		*p: ltracknodeclicks		&& .T. to push node clicks onto a stack so we can provide "go back" functionality
		*p: lusepathaskey		&& .T. to use the path of a node as its key
		*p: lwindowlocked		&& .T. if the TreeView is locked
		*p: nautoexpand		&& The level to which nodes are expanded when the TreeView is loaded
		*p: nnodeclick		&& The time the selected node was clicked (used for double-clicking)
		*p: ntimerinterval		&& The timer interval for tmrSync (temporary holding property)
		*p: ntreefactorx		&& The horizontal conversion factor for twips to pixels
		*p: ntreefactory		&& The vertical conversion factor for twips to pixels
		*p: oselectednode		&& A reference to the selected node in the TreeView
		*a: aexpandednodes[1,0]		&& An array containing the FullPath of expanded nodes
	*</DefinedPropArrayMethod>

	PROTECTED ldraginprogress,lexpanded,lneedreload,nnodeclick,ntreefactorx,ntreefactory
	ccurrentnodeid = 		&& The ID of the currently selected node
	ccurrentnodekey = 		&& The key of the currently selected node
	ccurrentnodetext = 		&& The text of the currently selected node
	ccurrentnodetype = 		&& The type of the currently selected node
	clastnode = 		&& The key for the node selected the last time this container was used
	cregistrykey = 		&& The key used to persist expanded and selected nodes
	cregistrykeysuffix = 		&& The subnode to use under the parent form's Registry key to store values for this control
	Height = 200
	lallowdelete = .F.		&& .T. if the user can delete a node by pressing Delete
	lallowinsert = .F.		&& .T. if the user can insert a node by pressing Insert
	lallowrename = .F.		&& .T. if the user can rename a node
	lautoloadchildren = .F.		&& .T. if child nodes are loaded when the TreeView is loaded
	ldraginprogress = .F.		&& .T. if a drag operation is in progress
	lexpanded = .F.		&& .T. if the selected node should be expanded or not (double-clicking on a node causes it to be expanded when it shouldn't)
	lexpandondblclick = .F.		&& .T. to expand a parent node on a double-click
	linitialized = .F.		&& .T. once all the tasks in Init are done
	lloadtreeviewatstartup = .T.		&& .T. to load the TreeView control when the container is instantiated
	lneedreload = .F.		&& .T. if LoadTree was called during a drag operation, meaning we need to call it again after the drag is complete
	lrestoreoninit = .T.		&& .T. to restore selected and expanded nodes at startup
	lsortrootnodes = .F.		&& .T. to sort the root nodes
	ltracknodeclicks = .T.		&& .T. to push node clicks onto a stack so we can provide "go back" functionality
	lusepathaskey = .T.		&& .T. to use the path of a node as its key
	lwindowlocked = .F.		&& .T. if the TreeView is locked
	Name = "sftreeviewcontainer"
	nautoexpand = 0		&& The level to which nodes are expanded when the TreeView is loaded
	nnodeclick = 0		&& The time the selected node was clicked (used for double-clicking)
	ntimerinterval = 0		&& The timer interval for tmrSync (temporary holding property)
	ntreefactorx = 0		&& The horizontal conversion factor for twips to pixels
	ntreefactory = 0		&& The vertical conversion factor for twips to pixels
	oselectednode = .NULL.		&& A reference to the selected node in the TreeView
	Width = 210
	_memberdata = <VFPData>
		<memberdata name="aexpandednodes" type="property" display="aExpandedNodes"/>
		<memberdata name="calctwipsperpixel" type="method" display="CalcTwipsPerPixel"/>
		<memberdata name="candrop" type="method" display="CanDrop"/>
		<memberdata name="canstartdrag" type="method" display="CanStartDrag"/>
		<memberdata name="ccurrentnodeid" type="property" display="cCurrentNodeID"/>
		<memberdata name="ccurrentnodekey" type="property" display="cCurrentNodeKey"/>
		<memberdata name="ccurrentnodetype" type="property" display="cCurrentNodeType"/>
		<memberdata name="clastnode" type="property" display="cLastNode"/>
		<memberdata name="createnodeobject" type="method" display="CreateNodeObject"/>
		<memberdata name="getchildnodes" type="method" display="GetChildNodes"/>
		<memberdata name="getdragdropdataobject" type="method" display="GetDragDropDataObject"/>
		<memberdata name="getnodeitemfromnode" type="method" display="GetNodeItemFromNode"/>
		<memberdata name="getrootnodes" type="method" display="GetRootNodes"/>
		<memberdata name="gettypeandidfromnode" type="method" display="GetTypeAndIDFromNode"/>
		<memberdata name="handledragdrop" type="method" display="HandleDragDrop"/>
		<memberdata name="insertnode" type="method" display="InsertNode"/>
		<memberdata name="lallowdelete" type="property" display="lAllowDelete"/>
		<memberdata name="lallowinsert" type="property" display="lAllowInsert"/>
		<memberdata name="lautoloadchildren" type="property" display="lAutoLoadChildren"/>
		<memberdata name="lexpanded" type="property" display="lExpanded"/>
		<memberdata name="lloadtreeviewatstartup" type="property" display="lLoadTreeviewAtStartup"/>
		<memberdata name="loadexpandednode" type="method" display="LoadExpandedNode"/>
		<memberdata name="loadimages" type="method" display="LoadImages"/>
		<memberdata name="loadnode" type="method" display="LoadNode"/>
		<memberdata name="loadnodechildren" type="method" display="LoadNodeChildren"/>
		<memberdata name="loadtree" type="method" display="LoadTree"/>
		<memberdata name="locktreeview" type="method" display="LockTreeview"/>
		<memberdata name="lusepathaskey" type="property" display="lUsePathAsKey"/>
		<memberdata name="nautoexpand" type="property" display="nAutoExpand"/>
		<memberdata name="nnodeclick" type="property" display="nNodeClick"/>
		<memberdata name="nodeclicked" type="method" display="NodeClicked"/>
		<memberdata name="ntreefactorx" type="property" display="nTreeFactorX"/>
		<memberdata name="ntreefactory" type="property" display="nTreeFactorY"/>
		<memberdata name="oselectednode" type="property" display="oSelectedNode"/>
		<memberdata name="oselectednode_access" type="method" display="oSelectedNode_Access"/>
		<memberdata name="removenode" type="method" display="RemoveNode"/>
		<memberdata name="restoreselectednode" type="method" display="RestoreSelectedNode"/>
		<memberdata name="saveselectednode" type="method" display="SaveSelectedNode"/>
		<memberdata name="selectnode" type="method" display="SelectNode"/>
		<memberdata name="startdrag" type="method" display="StartDrag"/>
		<memberdata name="treeafterlabeledit" type="method" display="TreeAfterLabelEdit"/>
		<memberdata name="treebeforelabeledit" type="method" display="TreeBeforeLabelEdit"/>
		<memberdata name="treedblclick" type="method" display="TreeDblClick"/>
		<memberdata name="treeexpand" type="method" display="TreeExpand"/>
		<memberdata name="treekeydown" type="method" display="TreeKeyDown"/>
		<memberdata name="treemousedown" type="method" display="TreeMouseDown"/>
		<memberdata name="treemouseup" type="method" display="TreeMouseUp"/>
		<memberdata name="treenodecheck" type="method" display="TreeNodeCheck"/>
		<memberdata name="treenodeclick" type="method" display="TreeNodeClick"/>
		<memberdata name="treeolecompletedrag" type="method" display="TreeOLECompleteDrag"/>
		<memberdata name="treeoledragdrop" type="method" display="TreeOLEDragDrop"/>
		<memberdata name="treeoledragover" type="method" display="TreeOLEDragOver"/>
		<memberdata name="treeolestartdrag" type="method" display="TreeOLEStartDrag"/>
		<memberdata name="deletenode" type="method" display="DeleteNode"/>
		<memberdata name="lexpandondblclick" type="property" display="lExpandOnDblClick"/>
		<memberdata name="lallowrename" type="property" display="lAllowRename"/>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="method" display="lSaveAnchor_Assign"/>
		<memberdata name="cregistrykeysuffix" type="property" display="cRegistryKeySuffix"/>
		<memberdata name="getregistrykey" type="method" display="GetRegistryKey"/>
		<memberdata name="linitialized" type="property" display="lInitialized"/>
		<memberdata name="goback" type="method" display="GoBack"/>
		<memberdata name="pushkey" type="method" display="PushKey"/>
		<memberdata name="ltracknodeclicks" type="property" display="lTrackNodeClicks"/>
		<memberdata name="getnodeundermouse" type="method" display="GetNodeUnderMouse"/>
		<memberdata name="ldraginprogress" type="property" display="lDragInProgress"/>
		<memberdata name="lneedreload" type="property" display="lNeedReload"/>
		<memberdata name="ntimerinterval" type="property" display="nTimerInterval"/>
		<memberdata name="settreeviewbackcolor" type="method" display="SetTreeViewBackColor"/>
		<memberdata name="getnodekey" display="GetNodeKey"/>
		<memberdata name="ccurrentnodetext" display="cCurrentNodeText"/>
		<memberdata name="lloading" display="lLoading"/>
		<memberdata name="beforeselectnode" display="BeforeSelectNode"/>
		<memberdata name="getsinglenode" display="GetSingleNode"/>
		<memberdata name="lrestoreoninit" display="lRestoreOnInit"/>
		<memberdata name="lwindowlocked" display="lWindowLocked"/>
		<memberdata name="lsortrootnodes" display="lSortRootNodes"/>
		</VFPData>

	ADD OBJECT 'oImageList' AS olecontrol WITH ;
		Left = 160, ;
		Name = "oImageList", ;
		Top = 0, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system32\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEB+LsIulssBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAD0AAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8jfyQskYXREbFqAMDwKDYoIUM0EggAAADjAwAA4wMAAIB+4eYAAAYAIAAAABEADwDAwMAA//85AAHvzasAAAUAXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEuAFcAZgAhAFQAPwBnACgAWgAxAHoAPwBWAFgAQgBdADIAZAABAACADAAAAEltYWdlSGVpZ2h0AAkAAABJCgAAAA8AAAALAAAASW1hZ2VXaWR0aAAJAAAASQoAAAARAAAAADEAuGilCAYAeQD/////BQAAgAAAAAAAAAAAAAAAACcANgA2AEEAWQBQAHEANgBvAHMAKgB1AHYALgBTAFMALgBXAGYAIQBUAD8AZwAoAFoAMQB6AD8AVgBYAEIAXQAyAGQAXgBfAEUAWwBnACEAQgAyAGcAKABTAHYAeQA/AFYAWABCAF0AMgBkAE4APQBsAGQALQB5AGcAMABnACgAUABtAHkAPwBWAFgAQgBdADIAZABgAFMALgBXAGYAIQBUAD8AZwAoAFoAMQB6AD8AVgBYAEIAXQAyAGQAXQBTAC4AVwBmACEAVAA/AGcAKABaADEAegA/AFYAWABCAF0AMgBkAA==" />

	ADD OBJECT 'oStack' AS sfstack WITH ;
		Left = 160, ;
		Name = "oStack", ;
		Top = 80
		*< END OBJECT: ClassLib="hold\sftreeview.vcx" BaseClass="collection" />

	ADD OBJECT 'oTree' AS olecontrol WITH ;
		Anchor = 15, ;
		Height = 200, ;
		Name = "oTree", ;
		Width = 210, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system32\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7///8EAAAA/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEB+LsIulssBAwAAAMACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAEQBAAAAAAAABAAAAAIAAAD+////BQAAAAoAAAAGAAAABwAAAAgAAAAJAAAA/v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAABdEQAAiRAAALE8wWoBAAYAIgAAAF0ANgDUAAAATABQAKmFoggB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAQPYAAAAAAACUAQEAAAAAAFACAQAAAAAABAMBAAAAAAABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwAAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAAAFAHiHoggGKHkAAAAAAAUAAICc6RIAAQAAAFwAH97svQEABQDh6RIAA1LjC5GPzhGd4wCqAEu4UQEAAACQAQAAJEAKAAAATGFiZWxFZGl0AAkAAABJCgAAAAAAAAAKAAAATGluZVN0eWxlAAkAAABJCgAAAAEAAAANAAAATW91c2VQb2ludGVyAAkAAABJCgAAAAAAAAAOAAAAUGF0aFNlcGFyYXRvcgAKAAAASAAAAAABAAAAXAwAAABPTEVEcmFnTW9kZQAJAAAASQoAAAABAAAADAAAAE9MRURyb3BNb2RlAAkAAABJCgAAAAEAAAALAAAAQXBwZWFyYW5jZQAJAAAASQoAAAABAAAADAAAAEJvcmRlclN0eWxlAAkAAABJCgAAAAAAAAAMAAAASG90VHJhY2tpbmcABQAAAEwBAAAAAAAAAAAAAAAAAAAAAAAAAFgCAABQEQAA9CMAAAAAAAC8GAAAAAAAAAAAAAD/////AQBUAAQAAAABAAAAkF8BAAZUYWhvbWH/JSIbAJiVAAAAAAAA/////wMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAgAAEgAAAKgmAAAAAAAA/////wAAAAAAAAAA/////wEAAAAEAAAAUAEAAAAAAAAAAAAA/////zQiHACYlQAAQAEAANgAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAiAIAAFARAADEJgAAAAAAANwYAAAAAAAAAAAAAP////8BACgABAAAAAEAAAACAAcAAAAAAP////80Ih0ARJYAAEABAAAwAQAAAwAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAKACAABQEQAAKCcAAAAAAAAoGQAAAAAAAAAAAAD/////AQAsAAQAAAABAAAAAgAHAAAAAAD/////NCIeADSXAAAADAAAuAcAAAMAAAAAAAAAGwAAAAAAAAAAAAAAAAAAAAAAAAC4AgAAUBEAAIAnAAAAAAAAsBkAAAAAAAAAAAAA" />

	ADD OBJECT 'tmrReload' AS sftimer WITH ;
		Enabled = .F., ;
		Interval = 200, ;
		Left = 161, ;
		Name = "tmrReload", ;
		Top = 111
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="timer" />

	ADD OBJECT 'tmrSync' AS sftimer WITH ;
		Interval = 1500, ;
		Left = 160, ;
		Name = "tmrSync", ;
		Top = 49
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="timer" />
	
	PROCEDURE beforeselectnode		&& Fires before a new node is selected
		* Abstract method.
		
		lparameters toNode
		
	ENDPROC

	PROTECTED PROCEDURE calctwipsperpixel		&& Calculate the conversion factor between VFP window units (in pixels) and TreeView window units (in twips)
		* Calculate the conversion factor between VFP window units (in pixels) and
		* TreeView window units (in twips).
		
		local liHWnd, ;
			liHDC, ;
			liPixelsPerInchX, ;
			liPixelsPerInchY
		
		* Declare some Windows API functions.
		
		declare integer GetDC         in Win32API ;
			integer iHDC
		declare integer GetDeviceCaps in Win32API ;
			integer iHDC, integer iIndex
		declare integer ReleaseDC     in Win32API ;
			integer ihWnd, integer iHDC
		
		* Get a device context for VFP.
		
		liHWnd = _vfp.hWnd
		liHDC  = GetDC(liHWnd)
		
		* Get the pixels per inch.
		
		liPixelsPerInchX = GetDeviceCaps(liHDC, cnLOG_PIXELS_X)
		liPixelsPerInchY = GetDeviceCaps(liHDC, cnLOG_PIXELS_Y)
		
		* Get the twips per pixel.
		
		with This
			.nTreeFactorX = cnTWIPS_PER_INCH/liPixelsPerInchX
			.nTreeFactorY = cnTWIPS_PER_INCH/liPixelsPerInchY
		endwith
		
		* Clean up.
		
		ReleaseDC(liHWnd, liHDC)
		clear dlls GetDC, GetDeviceCaps, ReleaseDC
		
	ENDPROC

	PROCEDURE candrop		&& Returns .T. if the specified source can be dropped on the specified node
		* This method is abstract here, but would typically look at toObject.DragType
		* and toObject.DropType to see if the source has data that the node the mouse
		* is over can accept, and if so, return .T. toData is the OLE drag and drop
		* data object, toNode is a reference to the target node, toObject is an object
		* containing the type and keys of the dragged object and the target node (see
		* GetDragDropDataObject for its properties). tnEffect should also be set based
		* on the type, if any, of drop allowed.
		
		lparameters toData, ;
			toNode, ;
			toObject, ;
			tnEffect, ;
			tnButton, ;
			tnShift
		return .F.
		
	ENDPROC

	PROCEDURE canstartdrag		&& Returns .T. if the current node in the TreeView can be dragged
		* Abstract method. This should return .T. if we can start a drag from the
		* selected node.
		
		return .F.
		
	ENDPROC

	PROCEDURE createnodeobject		&& Returns an object with properties about a node in the TreeView
		local loNodeItem
		loNodeItem = createobject('Empty')
		addproperty(loNodeItem, 'Key',           sys(2015))
		addproperty(loNodeItem, 'Text',          '')
		addproperty(loNodeItem, 'Image',         '')
		addproperty(loNodeItem, 'SelectedImage', '')
		addproperty(loNodeItem, 'ExpandedImage', '')
		addproperty(loNodeItem, 'Sorted',        .F.)
		addproperty(loNodeItem, 'HasChildren',   .F.)
		addproperty(loNodeItem, 'Tag',           '')
		addproperty(loNodeItem, 'ParentKey',     '')
		addproperty(loNodeItem, 'Bold',          .F.)
		return loNodeItem
		
	ENDPROC

	PROCEDURE deletenode		&& Deletes the selected node
		* Abstract method: called from TreeKeyDown when Delete pressed
		
	ENDPROC

	PROCEDURE Destroy
		* Save the last expanded and selected nodes.
		
		This.SaveSelectedNode()
		dodefault()
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.SetTreeViewBackColor(tlEnabled)
		This.Enabled = tlEnabled
			&& note that we don't DODEFAULT() because we don't want to use SetAll like
			&& the parent method does; that makes the TreeView "jump" when re-enabling
			&& the control
		
	ENDPROC

	PROCEDURE getchildnodes		&& Fills the passed collection with objects containing properties about the child nodes of the specified node
		* This method is abstract here, but would typically look like this:
		* loNodeItem = This.CreateNodeObject()
		* with loNodeItem
		*	.Text          = 'whatever'
		*	.Key           = 'whatever' && only needed if lUsePathAsKey is .F. and you want to assign the key manually
		*	.Image         = 'image name or number'
		*	.SelectedImage = 'selected image name or number; use same as Image if not different'
		*	.ExpandedImage = 'expanded image name or number; use same as Image or blank if not different'
		*	.Sorted        = .T. if it should be sorted
		*	.HasChildren   = .T. if there are any child nodes
		* endwith
		* toCollection.Add(loNodeItem)
		* repeat for other nodes
		
		lparameters tcType, ;
			tcID, ;
			toCollection
		
	ENDPROC

	PROCEDURE getdragdropdataobject		&& Returns an object with properties about a dragged object and the node it's dropped on
		* In a subclass, use DODEFAULT() to get the empty object, then make any changes
		* necessary to the property values.
		
		lparameters toNode, ;
			toData, ;
			tnButton, ;
			tnShift
		local loObject, ;
			loDataObject, ;
			lcData, ;
			lnPos
		loObject = createobject('Empty')
		addproperty(loObject, 'Data',     '')
		addproperty(loObject, 'DropType', '')
		addproperty(loObject, 'DropKey',  '')
		addproperty(loObject, 'DragType', '')
		addproperty(loObject, 'DragKey',  '')
		addproperty(loObject, 'Button',   tnButton)
		addproperty(loObject, 'Shift',    tnShift)
		with loObject
			if vartype(toNode) = 'O'
				loDataObject = This.GetTypeAndIDFromNode(toNode)
				.DropType    = loDataObject.Type
				.DropKey     = loDataObject.ID
			endif vartype(toNode) = 'O'
			try
				do case
					case toData.GetFormat(CF_MAX)
						lcData    = toData.GetData(CF_MAX)
						lnPos     = at(':', lcData)
						.Data     = lcData
						.DragType = '' + left(lcData, lnPos - 1)
						.DragKey  = '' + substr(lcData, lnPos + 1)
					case toData.GetFormat(CF_TEXT)
						lcData    = toData.GetData(CF_TEXT)
						.Data     = lcData
						.DragType = 'Text'
					case toData.GetFormat(CF_FILES)
						addproperty(loObject, 'Files', createobject('Collection'))
						for each lcFile in toData.Files
							loObject.Files.Add(lcFile)
						next lcFile
						.DragType = 'ImportFiles'
				endcase
			catch
			endtry
		endwith
		return loObject
		
	ENDPROC

	PROCEDURE getnodeitemfromnode		&& Returns a node item object from the specified TreeView node
		* Return a node item object from the specified TreeView node.
		
		lparameters toNode
		loNodeItem = This.CreateNodeObject()
		with loNodeItem
			.Key           = toNode.Key
			.Text          = toNode.Text
			.Image         = toNode.Image
			.SelectedImage = toNode.SelectedImage
			.Sorted        = toNode.Sorted
			.HasChildren   = toNode.Children > 0
		endwith
		return loNodeItem
		
	ENDPROC

	PROCEDURE getnodekey		&& Gets the key for the specified node type and ID (not called from anywhere but can be implemented and called)
		* Abstract method.
		
		lparameters tcType, ;
			tcID
		return ''
		
	ENDPROC

	PROCEDURE getnodeundermouse		&& Returns a reference to the node under the mouse
		* Return the node the user clicked on. Note that clicking the mouse to the
		* right of a node's caption won't select that node, so we'll check everywhere
		* starting from the leftmost edge of the TreeView to find the node, thanks to
		* code written by Sergey Berezniker.
		
		lparameters tnXCoord, ;
			tnYCoord
		local loNode
		with This
			loNode = .oTree.HitTest(tnXCoord * .nTreeFactorX, ;
				tnYCoord * .nTreeFactorY)
			if vartype(loNode) <> 'O'
				for lnI = 1 to tnXCoord
					loNode = .oTree.HitTest(lnI * .nTreeFactorX, ;
						tnYCoord * .nTreeFactorY)
					if vartype(loNode) = 'O'
						exit
					endif vartype(loNode) = 'O'
				next lnI
			endif vartype(loNode) <> 'O'
		endwith
		return loNode
		
	ENDPROC

	PROTECTED PROCEDURE getregistrykey		&& Gets the Registry key to use
		local lcKey
		with This
			do case
		
		* If we have a Registry key and a suffix to use, do so.
		
				case not empty(.cRegistryKey) and not empty(.cRegistryKeySuffix)
					lcKey = addbs(.cRegistryKey) + .cRegistryKeySuffix
		
		* If we have a Registry key to use, do so.
		
				case not empty(.cRegistryKey)
					lcKey = .cRegistryKey
		
		* If our form has a Registry key and we're supposed to add a suffix to it, do
		* so.
		
				case pemstatus(Thisform, 'cRegistryKey', 5) and ;
					not empty(Thisform.cRegistryKey)
					lcKey = addbs(Thisform.cRegistryKey) + .cRegistryKeySuffix
		
		* We don't have a key.
		
				otherwise
					lcKey = ''
			endcase
		endwith
		return lcKey
		
	ENDPROC

	PROCEDURE getrootnodes		&& Fills the passed collection with objects containing properties about the root nodes
		* This method is abstract here, but would typically look like this:
		* loNodeItem = This.CreateNodeObject()
		* with loNodeItem
		*	.Text          = 'whatever'
		*	.Key           = 'whatever' && only needed if lUsePathAsKey is .F. and you want to assign the key manually
		*	.Image         = 'image name or number'
		*	.SelectedImage = 'selected image name or number; use same as Image if not different'
		*	.ExpandedImage = 'expanded image name or number; use same as Image or blank if not different'
		*	.Sorted        = .T. if it should be sorted
		*	.HasChildren   = .T. if there are any child nodes
		* endwith
		* toCollection.Add(loNodeItem)
		* repeat for other nodes
		
		lparameters toCollection
		
	ENDPROC

	PROCEDURE getsinglenode		&& Creates and populates a single node object
		* This method is abstract here, but would typically look like this:
		* loNodeItem = This.CreateNodeObject()
		* with loNodeItem
		*	.Text          = 'whatever'
		*	.Key           = 'whatever' && only needed if lUsePathAsKey is .F. and you want to assign the key manually
		*	.Image         = 'image name or number'
		*	.SelectedImage = 'selected image name or number; use same as Image if not different'
		*	.ExpandedImage = 'expanded image name or number; use same as Image or blank if not different'
		*	.Sorted        = .T. if it should be sorted
		*	.HasChildren   = .T. if there are any child nodes
		* endwith
		
	ENDPROC

	PROCEDURE gettypeandidfromnode		&& Returns an object containing Type and ID properties for the specified node
		* In a subclass, use DODEFAULT() to get the empty object, then fill in the Type
		* and ID properties.
		
		lparameters toNode
		local loObject
		loObject = createobject('Empty')
		addproperty(loObject, 'Type', '')
		addproperty(loObject, 'ID',   '')
		return loObject
		
	ENDPROC

	PROCEDURE goback		&& Goes back to the previously selected node
		* Go back to the previously selected node by popping it off the stack. If the
		* node no longer exists, no harm done since SelectNode won't do anything in
		* that case.
		
		local lcKey
		lcKey = This.oStack.Pop()
		This.SelectNode(lcKey, .T.)
		
	ENDPROC

	PROCEDURE handledragdrop		&& Handles the completion of a DragDrop operation
		* This method is abstract here, but would typically call toData.GetFormat and
		* toData.GetData to get the data from the source object and somehow apply it to
		* the node it was dropped on, toNode. toObject is an object containing the type
		* and keys of the dragged object and the target node (see GetDragDropDataObject
		* for its properties).
		
		lparameters toData, ;
			toNode, ;
			toObject
		
	ENDPROC

	PROCEDURE Init
		local lnAnchor
		with This
		
		* Do the normal behavior.
		
			dodefault()
		
		* Set AutoYield to .F. so ActiveX events aren't processed when something is
		* executing.
		
			_vfp.AutoYield = .F.
		
		* Call the LoadImages method to programmatically load images into the
		* ImageList. Images can also be loaded visually if desired.
		
			.oImageList.ImageHeight = 16
			.oImageList.ImageWidth  = 16
			.LoadImages()	
		
		* Associate the ImageList with the TreeView.
		
			.oTree.ImageList = .oImageList.Object
		
		* Calculate the factors for converting twips to pixels.
		
			.CalcTwipsPerPixel()
		
		* Adjust the TreeView size (although we use anchoring, it doesn't work until
		* the control is visible.
		
			lnAnchor      = .oTree.Anchor
			.oTree.Anchor = 0
			.oTree.Height = .Height
			.oTree.Width  = .Width
			.oTree.Anchor = lnAnchor
		
		* Restore the last expanded and selected nodes if we're supposed to.
		
			if .lRestoreOnInit
				.RestoreSelectedNode()
			endif .lRestoreOnInit
		
		* If we're supposed to, load the TreeView.
		
			if .lLoadTreeViewAtStartup
				.LoadTree()
			endif .lLoadTreeViewAtStartup
		
		* Flag that initialization is done.
		
			.lInitialized = .T.
		endwith
		
	ENDPROC

	PROCEDURE insertnode		&& Inserts a new node
		* Abstract method
		
	ENDPROC

	PROCEDURE loadexpandednode		&& Loads the children for the specified node
		lparameters toNode
		local llLocked
		with This
			llLocked = .lWindowLocked
			.LockTreeView(.T.)
			if type('toNode.Child.Key') = 'C'
				.oTree.Nodes.Remove(toNode.Child.Key)
			endif type('toNode.Child.Key') = 'C'
			.LoadNodeChildren(toNode)
			if not llLocked
				.LockTreeView()
			endif not llLocked
		endwith
		
	ENDPROC

	PROCEDURE loadimages		&& Loads the ImageList control with desired images
		* Abstract method to load the images for the ImageList control. Typically, code
		* will look like this:
		*
		* with This.oImageList
		*	.ListImages.Add(1, 'Image1Key', loadpicture('SomeImageFile'))
		*	.ListImages.Add(2, 'Image2Key', loadpicture('SomeImageFile'))
		* endwith
		*
		* Set ImageHeight and ImageWidth of This.oImageList to appropriate values if
		* the images are not 16x16.
		
	ENDPROC

	PROCEDURE loadnode		&& Loads the specified node into the TreeView
		lparameters toNodeItem, ;
			tcParentKey
		local loNode, ;
			lcSeparator, ;
			llExpand
		
		* Add the node to the TreeView (unless it's already there). If we're supposed
		* to, set the node's Key to its FullPath so we can use FullPath to locate the
		* Key.
		
		with toNodeItem
			do case
				case type('This.oTree.Nodes[.Key]') = 'O'
					loNode = This.oTree.Nodes[.Key]
				case empty(tcParentKey)
					loNode = This.oTree.Nodes.Add(, 1, .Key, .Text, .Image)
				otherwise
					loNode = This.oTree.Nodes.Add(tcParentKey, 4, .Key, .Text, .Image)
			endcase
			if not empty(.SelectedImage)
				loNode.SelectedImage = .SelectedImage
			endif not empty(.SelectedImage)
			if not empty(.ExpandedImage)
				loNode.ExpandedImage = .ExpandedImage
			endif not empty(.ExpandedImage)
			loNode.Sorted = .Sorted
			loNode.Tag    = .Tag
			loNode.Bold   = .Bold
			if This.lUsePathAsKey
				store loNode.FullPath to loNode.Key, toNodeItem.Key
			endif This.lUsePathAsKey
		ENDWITH
		* Modified 7-December-2010 by TEG
		* Make sure it's visible
		loNode.EnsureVisible()
		with This
		
		* Flag if we're still above the end of the auto-expand limit.
		
			lcSeparator = .oTree.PathSeparator
			llExpand    = occurs(lcSeparator, loNode.FullPath) <= .nAutoExpand - 1
			do case
		
		* If the node doesn't have any children, we don't have anything else to do.
		
				case not toNodeItem.HasChildren
		
		* If we're supposed to load all child nodes or we're not at the end of the
		* auto-expand limit, let's load the children.
		
				case .lAutoLoadChildren or llExpand
					.LoadNodeChildren(loNode)
		
		* This node has children but we're not going to load them, so we'll add a
		* "loading" node so the + appears properly.
		
				case loNode.Children = 0
					.oTree.Nodes.Add(loNode.Key, 4, sys(2015), ccLOADING)
			endcase
		endwith
		return loNode
		
	ENDPROC

	PROTECTED PROCEDURE loadnodechildren		&& Loads the children of the specified node
		lparameters toNode
		local loChildNodesCollection as Collection, ;
			loNodeItem, ;
			llSorted, ;
			loChildNode
		with This
			loChildNodesCollection = createobject('Collection')
			loNodeItem = .GetTypeAndIDFromNode(toNode)
			.GetChildNodes(loNodeItem.Type, loNodeItem.ID, loChildNodesCollection)
			llSorted = toNode.Sorted
			toNode.Sorted = .F.
				&& speeds up loading if Sorted set to .F. during load and .T. after
			for each loChildNode in loChildNodesCollection foxobject
				.LoadNode(loChildNode, toNode.Key)
			next loChildNode
			if llSorted
				toNode.Sorted = .T.
			endif llSorted
		endwith
		
	ENDPROC

	PROCEDURE loadtree		&& Loads the TreeView
		* Load the TreeView.
		
		lparameters tlNoSelect
		local lnExpandedNodes , ;
			lnI, ;
			laExpandedNodes[1], ;
			loNodesCollection, ;
			loNodeItem, ;
			lcKey, ;
			loNode
		
		* There's a bug in the TreeView control: adding a new node or changing the
		* parent of an existing node in a drag operation causes the node to be deleted
		* once the drag is complete. So, we'll do nothing in that case and we'll be
		* called again from tmrReload after the drag is complete.
		
		if This.lDragInProgress
			This.lNeedReload = .T.
			return
		endif This.lDragInProgress
		with This
		
		* Flag that we're loading the TreeView; we don't want certain events fired in
		* that case.
		
			.lLoading = .T.
		
		* Lock the TreeView so we don't see updates until they're done.
		
			.LockTreeView(.T.)
		
		* If we have any existing nodes, let's save the keys of the expanded ones and
		* the selected one so we can restore them later, then nuke the nodes. That way,
		* LoadTree can be called to refresh or reload the TreeView.
		
			with .oTree
				if .Nodes.Count > 0
					lnExpandedNodes = 0
					for lnI = 1 to .Nodes.Count
						if .Nodes[lnI].Expanded
							lnExpandedNodes = lnExpandedNodes + 1
							dimension This.aExpandedNodes[lnExpandedNodes]
							This.aExpandedNodes[lnExpandedNodes] = .Nodes[lnI].Key
						endif .Nodes[lnI].Expanded
					next lnI
					do case
						case not empty(This.cLastNode)
						case vartype(.SelectedItem) = 'O'
							This.cLastNode = .SelectedItem.Key
						otherwise
							This.cLastNode = ''
					endcase
					.Nodes.Clear()
				endif .Nodes.Count > 0
			endwith
		
		* Get the root nodes and add them to the TreeView.
		
			loNodesCollection = createobject('Collection')
			.GetRootNodes(loNodesCollection)
			for each loNodeItem in loNodesCollection foxobject
				.LoadNode(loNodeItem)
			next loNodeItem
		
		* Blank the cCurrent* properties indicating nothing is currently selected
		* (needed in case we don't load any nodes and these properties previously had
		* values from an earlier loaded tree).
		
			.cCurrentNodeID   = ''
			.cCurrentNodeKey  = ''
			.cCurrentNodeText = ''
			.cCurrentNodeType = ''
		
		* Re-expand any previously expanded nodes.
		
			with .oTree
				for lnI = 1 to alen(This.aExpandedNodes)
					lcKey = This.aExpandedNodes[lnI]
					if type('.Nodes[lcKey]') = 'O'
						This.TreeExpand(.Nodes[lcKey], .T.)
					endif type('.Nodes[lcKey]') = 'O'
				next lnI
			endwith
		
		* Flag that we're done loading the TreeView.
		
			.lLoading = .F.
		
		* If we're supposed to re-select the node selected last time and that node
		* still exists, select it. Otherwise, select the first node.
		
			loNode = .NULL.
			do case
				case tlNoSelect
				case not empty(.cLastNode) and type('.oTree.Nodes[.cLastNode]') = 'O'
					loNode = .oTree.Nodes[.cLastNode]
				case .oTree.Nodes.Count > 0
					loNode = .oTree.Nodes[1]
			endcase
			if not isnull(loNode)
				.SelectNode(loNode)
			endif not isnull(loNode)
		
		* Reset cLastNode so we aren't fooled by its value when LoadTree is called
		* again.
		
			.cLastNode = ''
		
		* Sort the tree if we're supposed to.
		
			.oTree.Sorted = .lSortRootNodes
		
		* Unlock the TreeView.
		
			.LockTreeView()
		endwith
		
	ENDPROC

	PROCEDURE locktreeview		&& Locks the TreeView so updates don't appear immediately
		lparameters tlLock
		declare integer LockWindowUpdate in Win32API ;
			integer nHandle
		do case
			case tlLock and This.lWindowLocked
			case tlLock
				lnStatus = LockWindowUpdate(This.oTree.hWnd)
		*** Can check for lnStatus = 0 which means a window was already locked
				This.lWindowLocked = .T.
			otherwise
				LockWindowUpdate(0)
				This.lWindowLocked = .F.
		endcase
		return
		
	ENDPROC

	PROCEDURE nodeclicked		&& Called when a node is clicked
		* Abstract method.
		
		lparameters tlSameNode
		
	ENDPROC

	PROCEDURE oselectednode_access
		return This.oTree.SelectedItem
		
	ENDPROC

	PROCEDURE pushkey		&& Pushes the specified key onto the stack
		lparameters tcKey
		This.oStack.Push(tcKey)
		
	ENDPROC

	PROCEDURE removenode		&& Removes the selected node
		* Remove the selected node and select the new node if we're supposed to.
		
		lparameters tcKey, ;
			tlNoSelect
		local lcKey
		with This
			lcKey = evl(tcKey, .oTree.SelectedItem.Key)
			if type('.oTree.Nodes[lcKey]') = 'O'
				.oTree.Nodes.Remove(lcKey)
				if not tlNoSelect and vartype(.oTree.SelectedItem) = 'O'
					.SelectNode(.oTree.SelectedItem)
				endif not tlNoSelect ...
			endif type('.oTree.Nodes[lcKey]') = 'O'
		endwith
		
	ENDPROC

	PROCEDURE restoreselectednode		&& Restores the selected node from whereever it was saved when this was last used
		* Restore cLastNode and aExpandedNodes so the TreeView is restored to its
		* former state.
		
		local lcKey, ;
			loRegistry, ;
			lnNode, ;
			laValues[1], ;
			lnValues, ;
			lnI, ;
			lcValue
		with This
		
		* Blank the current values.
		
			dimension .aExpandedNodes[1]
			.aExpandedNodes[1] = ''
			.cLastNode = ''
		
		* If we have a registry key, restore the settings.
		
			lcKey = .GetRegistryKey()
			if not empty(lcKey)
				loRegistry = newobject('SFRegistry', 'SFRegistry.vcx')
				.cLastNode = loRegistry.GetKey(lcKey, 'SelectedNode')
				lnNode     = 0
				lnValues   = loRegistry.EnumerateKeyValues(lcKey, @laValues)
				for lnI = 1 to lnValues
					lcValue = laValues[lnI, 1]
					if lcValue = 'Expanded'
						lnNode = lnNode + 1
						dimension .aExpandedNodes[lnNode]
						.aExpandedNodes[lnNode] = laValues[lnI, 2]
					endif lcValue = 'Expanded'
				next lnI
			endif not empty(lcKey)
		endwith
		
	ENDPROC

	PROCEDURE saveselectednode		&& Saves the selected node so it can be restored at restart
		* Save the selected and all expanded nodes so we can restore our former state
		* next time.
		
		local lcKey, ;
			loRegistry, ;
			lnNode, ;
			lnI, ;
			loNode, ;
			laValues[1], ;
			lnValues, ;
			lcValue
		with This.oTree
			lcKey = This.GetRegistryKey()
			if not empty(lcKey)
				loRegistry = newobject('SFRegistry', 'SFRegistry.vcx')
				if vartype(.SelectedItem) = 'O'
					loRegistry.SetKey(lcKey, 'SelectedNode', .SelectedItem.Key)
				endif vartype(.SelectedItem) = 'O'
				lnNode = 0
				for lnI = 1 to .Nodes.Count
					loNode = .Nodes(lnI)
					if loNode.Expanded
						lnNode = lnNode + 1
						loRegistry.SetKey(lcKey, 'Expanded' + transform(lnNode), ;
							loNode.Key)
					endif loNode.Expanded
				next lnI
		
		* Remove extra lines from the Registry in case there were more expanded nodes
		* the last time it was written to.
		
				lnValues = loRegistry.EnumerateKeyValues(lcKey, @laValues)
				for lnI = 1 to lnValues
					lcValue = laValues[lnI, 1]
					if lcValue = 'Expanded' and val(substr(lcValue, 9)) > lnNode
						loRegistry.DeleteKeyValue(lcKey, lcValue)
					endif lcValue = 'Expanded' ...
				next lnI
			endif not empty(lcKey)
		endwith
		
	ENDPROC

	PROCEDURE selectnode		&& Selects the specified node
		* Select the specified node.
		
		lparameters toNode, ;
			tlNoPush
		local loNode, ;
			llReturn, ;
			lcKey, ;
			loObject
		with This
		
		* If we were passed a key or index rather than a node, try to find the proper
		* node.
		
			do case
				case vartype(toNode) = 'O'
					loNode = toNode
				case type('.oTree.Nodes[toNode]') = 'O'
					loNode = .oTree.Nodes[toNode]
				case type('.oTree.Nodes[upper(toNode)]') = 'O'
					loNode = .oTree.Nodes[upper(toNode)]
				otherwise
					loNode = .NULL.
			endcase
		
		* If we have a node, ensure any custom pre-selection code succeeds. Note that
		* we save the key of the specified node and then reacquire the node again
		* afterward in case BeforeSelectNode causes the TreeView to be re-loaded.
		
			llReturn = vartype(loNode) = 'O'
			if llReturn
				lcKey    = loNode.Key
				llReturn = .BeforeSelectNode(loNode)
				if type('.oTree.Nodes[lcKey]') = 'O'
					loNode = .oTree.Nodes[lcKey]
				else
					llReturn = .F.
				endif type('.oTree.Nodes[lcKey]') = 'O'
			endif llReturn
			if llReturn
		
		* Push the previous node onto the stack if we're supposed to.
		
				if not tlNoPush and .lTrackNodeClicks and ;
					vartype(.oTree.SelectedItem) = 'O'
					.PushKey(.oTree.SelectedItem.Key)
				endif not tlNoPush ...
		
		* Ensure the node is visible and selected. Prevent two items from being
		* selected by nulling the currently selected item before selecting this one.
		
				loNode.EnsureVisible()
				.oTree.SelectedItem = .NULL.
				loNode.Selected     = .T.
		
		* Set cCurrentNodeType, cCurrentNodeID, cCurrentNodeKey, and cCurrentNodeText
		* to the type, ID, key, and text of the selected node.
		
				loObject          = .GetTypeAndIDFromNode(loNode)
				.cCurrentNodeType = loObject.Type
				.cCurrentNodeID   = loObject.ID
				.cCurrentNodeKey  = loNode.Key
				.cCurrentNodeText = loNode.Text
		
		* Call the NodeClicked method for any custom behavior.
		
				.NodeClicked()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE settreeviewbackcolor		&& Sets the background color of the TreeView
		* Modified 17-September-2010 by TEG
		* Commented this method out because it's not needed for this tool
		* and it pulls a lot of extraneous code in.
		
		*!*	*==============================================================================
		*!*	* Program:			SetTreeViewColor
		*!*	* Purpose:			Adds a "lightbox" image over the TreeView, visually
		*!*	*						indicating that it's unavailable
		*!*	* Author:			Doug Hennig, adapted from code written by Bernard Bout
		*!*	* Last Revision:	10/07/2009
		*!*	* Parameters:		tlEnable - .T. to reenable the TreeView
		*!*	*					tnColor  - the color to use (optional: if it isn't passed,
		*!*	*						the system color for an active caption is used; also,
		*!*	*						not needed if tlEnable is .T.)
		*!*	* Returns:			.T.
		*!*	* Environment in:	System.APP/EXE is available to be run
		*!*	* Environment out:	the container has an image added to it if tlEnable is .F.
		*!*	*						and the image is not visible if tlEnable is .T.
		*!*	*					System.APP/EXE has been run, adding a System object to
		*!*	*						_screen
		*!*	*==============================================================================
		
		*!*	lparameters tlEnable, ;
		*!*		tnColor
		*!*	local llImage, ;
		*!*		lnWidth, ;
		*!*		lnHeight, ;
		*!*		lnColor, ;
		*!*		lnFactor, ;
		*!*		lnRed, ;
		*!*		lnGreen, ;
		*!*		lnBlue, ;
		*!*		loClrMatrix, ;
		*!*		loBmp, ;
		*!*		loGfx, ;
		*!*		lcFile
		
		*!*	* See if we have a LightBox image.
		
		*!*	with This
		*!*		llImage = pemstatus(This, 'imgLightBox', 5)
		*!*		do case
		
		*!*	* It does and we're supposed to enable the TreeView, so hide the image and
		*!*	* redisplay the TreeView.
		
		*!*			case tlEnable and llImage
		*!*				.imgLightBox.Visible    = .F.
		*!*				.imgLightBox.PictureVal = ''
		*!*				.oTree.Visible          = .T.
		
		*!*	* We're supposed to disable the TreeView, so ensure GDIPlusX libraries are open and
		*!*	* create the image if necessary.
		
		*!*			case not tlEnable
		*!*				if type('_screen.System.Drawing') <> 'O'
		*!*					do System
		*!*				endif type('_screen.System.Drawing') <> 'O'
		*!*				if not llImage
		*!*					.AddObject('imgLightBox', 'Image')
		*!*				endif not llImage
		
		*!*	* Size the image as necessary.
		
		*!*				lnWidth  = .oTree.Width
		*!*				lnHeight = .oTree.Height
		*!*				with .imgLightBox
		*!*					.Top     = This.oTree.Top
		*!*					.Left    = This.oTree.Left
		*!*					.Width   = lnWidth
		*!*					.Height  = lnHeight
		*!*					.Anchor  = This.oTree.Anchor
		*!*					.Stretch = 1
		*!*				endwith
		
		*!*	* If we weren't passed a color to use, use grey.
		
		*!*				if vartype(tnColor) = 'N'
		*!*					lnColor = tnColor
		*!*				else
		*!*					lnColor = rgb(240, 240, 240)
		*!*				endif vartype(tnColor) = 'N'
		
		*!*	* Get the colors we'll need.
		
		*!*				lnFactor = 0.90  && 0 = Dark   1 = Bright
		*!*				lnRed    = bitand(lnColor, 0x000000FF) / 255 * lnFactor
		*!*				lnGreen  = bitrshift(bitand(lnColor, 0x0000FF00), 8) / 255 * lnFactor
		*!*				lnBlue   = bitrshift(bitand(lnColor, 0x00FF0000), 16) / 255 * lnFactor
		
		*!*	* Create a BMP of the desired color and use it as the picture for the image.
		
		*!*				with _Screen.System.Drawing
		*!*					loClrMatrix = .Imaging.ColorMatrix.New( ;
		*!*						lnRed,       0,      0, 0, 0, ;
		*!*						    0, lnGreen,      0, 0, 0, ;
		*!*						    0,       0, lnBlue, 0, 0, ;
		*!*						    0,       0,      0, 1, 0, ;
		*!*						    0,       0,      0, 0, 1)
		*!*					loBmp = .Bitmap.FromScreen(This.imgLightBox)
		*!*					loBmp.ApplyColorMatrix(loClrMatrix)
		*!*					loGfx = .Graphics.FromImage(loBmp)
		*!*					loGfx.FillRectangle(.SolidBrush.New(.Color.FromARGB(10, 0, 0, 0)), ;
		*!*						0, 0, lnWidth, lnHeight)
		*!*				endwith
		*!*				with .imgLightBox
		*!*					.PictureVal = loBmp.GetPictureValFromHBitmap()
		*!*					.ZOrder(0)
		*!*					.Visible = .T.
		*!*				endwith
		*!*				.oTree.Visible = .F.
		*!*			endcase
		*!*	endwith
		
	ENDPROC

	PROCEDURE treeafterlabeledit		&& Called after the text of a node has been edited in the TreeView
		* Abstract method. tnCancel and tcNewName are passed by reference, so set
		* Cancel to .T. to prevent the label from being saved or change tcNewName as
		* desired.
		
		lparameters tnCancel, ;
			tcNewName
		
	ENDPROC

	PROCEDURE treebeforelabeledit		&& Called before the text of a node is edited in the TreeView
		* Abstract method. tnCancel is passed by reference, so set it to .T. to prevent
		* the label from being edited.
		
		lparameters tnCancel
		tnCancel = not This.lAllowRename
		
	ENDPROC

	PROCEDURE treedblclick		&& Fired when the user double-clicks on the TreeView
		* Restore the saved expanded setting for the node so double-clicking doesn't
		* expand the node if that's what we're supposed to do.
		
		with This
			if not .lExpandOnDblClick
				.oTree.SelectedItem.Expanded = .lExpanded
			endif not .lExpandOnDblClick
		endwith
		
	ENDPROC

	PROCEDURE treeexpand		&& Called when a node is expanded in the TreeView
		* If the node has a "Loading" child, this is the first time the node has been
		* expanded, so nuke the child and add the appropriate child nodes, depending on
		* the type of node this is. The TreeView is locked while this happens so we
		* don't see the updates until they're done.
		
		lparameters toNode, ;
			tlNoSelect
		local laStack[1], ;
			lnStack, ;
			loNode, ;
			loNodeItem
		
		* If we were called from ourselves because setting loNode.Expanded to .T. fires
		* Expand which calls us, do nothing.
		
		lnStack = astackinfo(laStack)
		if lnStack > 2 and 'treeexpand' $ lower(laStack[lnStack - 2, 3])
			return
		endif lnStack > 2 ...
		with This
		
		* If we were passed a key rather than a node, try to find the proper node.
		
			do case
				case vartype(toNode) = 'O'
					loNode = toNode
				case type('.oTree.Nodes[toNode]') = 'O'
					loNode = .oTree.Nodes[toNode]
				case type('.oTree.Nodes[upper(toNode)]') = 'O'
					loNode = .oTree.Nodes[upper(toNode)]
			endcase
		
		* If this node has a "Loading" child, remove it and add the real children.
		
			if vartype(loNode) = 'O'
				if loNode.Children > 0 and loNode.Child.Text = ccLOADING
					.LoadExpandedNode(loNode)
				endif loNode.Children > 0 ...
		
		* Ensure the node is expanded (we may have been called programmatically).
		
				if not loNode.Expanded
					loNode.Expanded = .T.
				endif not loNode.Expanded
		
		* Act like the node was just clicked so it's selected.
		
				if not tlNoSelect and not .lLoading
					.SelectNode(loNode)
				endif not tlNoSelect ...
			endif vartype(loNode) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE treekeydown		&& Called when a key is pressed when the TreeView has focus
		lparameters tnKeyCode, ;
			tnShift
		local lnKeyCode
		lnKeyCode = 0
		with This
			do case
		
		* Delete was pressed, so remove the selected node if we're allowed to.
		
				case tnKeyCode = 46 and .lAllowDelete
					.DeleteNode()
		
		* Insert was pressed, so add a new node if we're allowed to.
		
				case tnKeyCode = 45 and .lAllowInsert
					.InsertNode()
		
		* F1 was pressed, so bring up help.
		
				case tnKeyCode = 112
					help
		
		* Translate keypress codes from the TreeView to VFP, then call the form's
		* KeyPress method.
		
				case tnKeyCode = 33		&& Page Up
					lnKeyCode = 18
					tnKeyCode = 0
				case tnKeyCode = 34		&& Page Down
					lnKeyCode = 3
					tnKeyCode = 0
				case tnKeyCode = 121	&& Shift-F10
					lnKeyCode = 93
					tnKeyCode = 0
			endcase
			if lnKeyCode <> 0
				Thisform.KeyPress(lnKeyCode, tnShift)
			endif lnKeyCode <> 0
		endwith
		
	ENDPROC

	PROCEDURE treemousedown		&& Called when a mouse button is pressed over the TreeView
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loNode
		with This
		
		* Ensure the node under the mouse is selected.
		
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			if not isnull(loNode)
				.TreeNodeClick(loNode)
			endif not isnull(loNode)
		
		* If this is the left mouse button, determine whether we can drag from the
		* selected node or not.
		
			if tnButton = BUTTON_LEFT
				.oTree.OLEDragMode = iif(.CanStartDrag(), DRAG_AUTOMATIC, DRAG_MANUAL)
		
		* If this is the right mouse button, show the shortcut menu. We would normally
		* do this is the RightClick method, except the TreeView doesn't have one, or
		* the MouseUp method, except that doesn't fire when the mouse is over the image
		* or text of a node. So, we have to do it here. Alternatively, we could store
		* which button is held down in MouseDown and check for the right button in
		* NodeClick (which doesn't receive a tnButton parameter, hence the need to
		* store it in MouseDown) and call ShowMenu from there.
		
			else
				.ShowMenu()
			endif tnButton = BUTTON_LEFT
		endwith
		
	ENDPROC

	PROCEDURE treemouseup		&& Called when a mouse button is released over the TreeView
		* Abstract method.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		
	ENDPROC

	PROCEDURE treenodecheck		&& Called when a node is checked in the TreeView
		* Abstract method
		
		lparameters toNode
		
	ENDPROC

	PROCEDURE treenodeclick		&& Called when a node is selected in the TreeView
		lparameters toNode
		local loParent, ;
			loNode, ;
			lnSeconds
		with This
		
		* If you click lightly on the + for a parent node, sometimes Expand doesn't
		* fire but the node still expands, so you see "Loading..." as the node.
		* Since that isn't a valid node, if the user clicks it, we'll expand the
		* parent node.
		
			if toNode.Text = ccLOADING
				loParent = toNode.Parent
				.TreeExpand(loParent, .T.)
				loNode = loParent.Child
			else
				loNode = toNode
			endif toNode.Text = ccLOADING
		
		* If we're on the same node as before (likely because we were called from
		* TreeMouseDown on the down-press and again from NodeClick when the mouse is
		* released), do nothing. Otherwise, select the node.
		
			if isnull(.oTree.SelectedItem) or not loNode.Key == .cCurrentNodeKey
				.SelectNode(loNode)
		
		* Save its Expanded property if this isn't the second click of a double-click.
		* Note that we use a TRY because it's possible the node may have changed in
		* SelectNode.
		
				lnSeconds = seconds()
				if lnSeconds - .nNodeClick > _dblclick
					try
						.lExpanded = loNode.Expanded
					catch
					endtry
				endif lnSeconds - .nNodeClick > _dblclick
				.nNodeClick = seconds()
		
		* If we're on the same node, call NodeClicked in case something should happen
		* even if the same node is clicked.
		
			else
				.NodeClicked(.T.)
			endif isnull(.oTree.SelectedItem) ...
		endwith
		
	ENDPROC

	PROCEDURE treeolecompletedrag		&& Called when an OLECompleteDrag events occurs in the TreeView
		* Turn off node highlighting. This is done in both TreeOLEDragDrop and here
		* because sometimes one or the other event fires.
		
		lparameters tnEffect
		This.oTree.DropHighlight = .NULL.
		
	ENDPROC

	PROCEDURE treeoledragdrop		&& Called when an OLEDragDrop event occurs in the TreeView
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loNode, ;
			loObject
		with This
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			.oTree.DropHighlight = .NULL.	&& do this here plus in TreeOLECompleteDrag
											&& because sometimes one or the other event
											&& fires
			loObject = .GetDragDropDataObject(loNode, toData, tnButton, tnShift)
			if .CanDrop(toData, loNode, loObject, @tnEffect, tnButton, tnShift)
		
		* Flag that a drag is in progress so calls to LoadTree do nothing; the code
		* below starts a timer that calls LoadTree after the drag operation is
		* complete.
		
				.lDragInProgress = .T.
		
		* Save the key of the selected node so we can restore it if necessary.
		
				if vartype(.oTree.SelectedItem) = 'O'
					.cLastNode = .oTree.SelectedItem.Key
				else
					.cLastNode = ''
				endif vartype(.oTree.SelectedItem) = 'O'
		
		* Handle the drop and reset lDragInProgress.
		
				.HandleDragDrop(toData, loNode, loObject)
				.lDragInProgress = .F.
		
		* There's a bug in the TreeView control: adding a new node or changing the
		* parent of an existing node in a drag operation causes the node to be deleted
		* once the drag is complete. In that case, LoadTree did nothing and we'll
		* start a timer that'll call it again after the drag is done. Note that we have
		* to disable the sync timer since it interferes with the reloading.
		
				if .lNeedReload
					.lNeedReload       = .F.
					.nTimerInterval    = .tmrSync.Interval
					.tmrSync.Interval  = 0
					.tmrSync.Enabled   = .F.
					.tmrReload.Enabled = .T.
				endif .lNeedReload
			endif .CanDrop(toData ...
		endwith
		
	ENDPROC

	PROCEDURE treeoledragover		&& Called when an OLEDragOver event occurs in the TreeView
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		local loNode, ;
			loPrevious, ;
			loObject
		with This
		
		* Determine which node the source was dragged over and highlight it.
		
			loNode = .GetNodeUnderMouse(tnXCoord, tnYCoord)
			if vartype(loNode) = 'O'
				.oTree.DropHighlight = loNode
		
		* If we're near the top or bottom of the TreeView, auto-scroll (the INKEY()
		* ensures it doesn't scroll too fast).
		
				do case
					case tnYCoord > .oTree.Top + 15
					case type('loNode.Previous.Text') = 'C'
						loPrevious = loNode.Previous
						do while vartype(loPrevious.Parent) = 'O' and ;
							not loPrevious.Parent.Expanded
							loPrevious = loPrevious.Parent
						enddo while vartype(loPrevious.Parent) = 'O' ...
						do while loPrevious.Expanded and loPrevious.Children > 0
							loPrevious = loPrevious.Child.LastSibling
						enddo while loPrevious.Expanded ...
						inkey(0.05, 'H')
						loPrevious.EnsureVisible()
					case type('loNode.Parent.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Parent.EnsureVisible()
				endcase
				do case
					case tnYCoord < .oTree.Top + .oTree.Height - 15
					case loNode.Expanded and type('loNode.Child.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Child.EnsureVisible()
					case type('loNode.Next.Text') = 'C'
						inkey(0.05, 'H')
						loNode.Next.EnsureVisible()
				endcase
			endif vartype(loNode) = 'O'
		
		* If the mouse is entering or moving over the TreeView, flag whether we'll
		* allow a drop or not.
		
			if tnState = DRAG_ENTER or tnState = DRAG_OVER
				loObject = .GetDragDropDataObject(loNode, toData, tnButton, tnShift)
				.CanDrop(toData, loNode, loObject, @tnEffect, tnButton, tnShift)
			endif tnState = DRAG_ENTER ...
		endwith
		
	ENDPROC

	PROCEDURE treeolestartdrag		&& Called when an OLEStartDrag event occurs in the TreeView
		* Set the data for the drag object to the node type and ID. We'll use a custom
		* format that holds the node type and key so dragging and dropping to ourselves
		* can be detected. In addition, the "text" format contains the current node's
		* Text value.
		
		lparameters toData, ;
			tnAllowedEffects
		local lcValue
		with This
			lcValue = createbinary(.cCurrentNodeType + ':' + ;
				transform(.cCurrentNodeID))
			toData.SetData(lcValue, CF_MAX)
			toData.SetData(.cCurrentNodeText, CF_TEXT)
		endwith
		
	ENDPROC

	PROCEDURE oTree.AfterLabelEdit
		* Pass AfterLabelEdit events to the parent.
		
		lparameter tnCancel, ;
			tcNewName
		This.Parent.TreeAfterLabelEdit(@tnCancel, @tcNewName)
		
	ENDPROC

	PROCEDURE oTree.BeforeLabelEdit
		* Pass BeforeLabelEdit events to the parent.
		
		lparameters tnCancel
		This.Parent.TreeBeforeLabelEdit(@tnCancel)
		
	ENDPROC

	PROCEDURE oTree.Collapse
		* Ensure the node in the tree that was just collapsed is selected.
		
		lparameters toNode
		This.Parent.SelectNode(toNode)
		
	ENDPROC

	PROCEDURE oTree.DblClick
		* Pass double-clicks to the parent.
		
		This.Parent.TreeDblClick()
		
	ENDPROC

	PROCEDURE oTree.Expand
		* Pass node expansion to the parent.
		
		lparameters toNode
		This.Parent.TreeExpand(toNode)
		
	ENDPROC

	PROCEDURE oTree.Init
		* Change the font to Segoe UI in Vista.
		
		if os(3) >= '6'
			This.Font.Name = 'Segoe UI'
		endif os(3) >= '6'
		
	ENDPROC

	PROCEDURE oTree.KeyDown
		* Pass keypresses to the parent.
		
		lparameters tnKeyCode, ;
			tnShift
		This.Parent.TreeKeyDown(tnKeyCode, tnShift)
		
	ENDPROC

	PROCEDURE oTree.MouseDown
		* Pass MouseDown events to the parent.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeMouseDown(tnButton, tnShift, tnXCoord, tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.MouseUp
		* Pass MouseUp events to the parent. This doesn't fire when the mouse is over
		* the image or text of a node (NodeClick fires in that case), only when it's
		* over a "white" part of the TreeView.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeMouseUp(tnButton, tnShift, tnXCoord, tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.NodeCheck
		* Pass NodeCheck events to the parent.
		
		lparameters toNode
		This.Parent.TreeNodeCheck(toNode)
		
	ENDPROC

	PROCEDURE oTree.NodeClick
		* Pass NodeClick events to the parent.
		
		lparameters toNode
		This.Parent.TreeNodeClick(toNode)
		
	ENDPROC

	PROCEDURE oTree.OLECompleteDrag
		* Pass OLECompleteDrag events to the parent.
		
		lparameters tnEffect
		This.Parent.TreeOLECompleteDrag(@tnEffect)
		
	ENDPROC

	PROCEDURE oTree.OLEDragDrop
		* Pass OLEDragDrop events to the parent.
		
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.Parent.TreeOLEDragDrop(@toData, @tnEffect, tnButton, tnShift, tnXCoord, ;
			tnYCoord)
		
	ENDPROC

	PROCEDURE oTree.OLEDragOver
		* Pass OLEDragOver events to the parent.
		
		lparameters toData, ;
			tnEffect, ;
			tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord, ;
			tnState
		This.Parent.TreeOLEDragOver(@toData, @tnEffect, tnButton, tnShift, tnXCoord, ;
			tnYCoord, tnState)
		
	ENDPROC

	PROCEDURE oTree.OLEStartDrag
		* Pass OLEStartDrag events to the parent.
		
		lparameters toData, ;
			tnAllowedEffects
		This.Parent.TreeOLEStartDrag(@toData, @tnAllowedEffects)
		
	ENDPROC

	PROCEDURE tmrReload.Timer
		local loNode
		with This.Parent
			This.Enabled = .F.
			.LoadTree()
			.tmrSync.Enabled  = .T.
			.tmrSync.Interval = .nTimerInterval
		endwith
		
	ENDPROC

	PROCEDURE tmrSync.Timer
		* It appears that sometimes clicking on a node in the TreeView doesn't fire
		* NodeClick. So, we'll periodically check whether the node we think is selected
		* matches the actual selection, and if not, fire NodeClick. Note that we
		* specifically ensure Interval isn't 0 since sometimes this event fires one
		* more time even after we disabled it.
		
		with This.Parent
			if wvisible('Trace')
				This.Enabled = .F.
			endif wvisible('Trace')
			if This.Interval > 0 and not isnull(.oTree.SelectedItem) and ;
				not .oTree.SelectedItem.Key == .cCurrentNodeKey
				.TreeNodeClick(.oTree.SelectedItem)
			endif This.Interval > 0 ...
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sftreeviewcursor AS sftreeviewcontainer OF "sftreeview.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addnodetocollection		&& Adds a node to the collection
		*m: createtreeviewcursor		&& Creates the cursor driving the TreeView
		*m: displayrecord		&& Called when a node is clicked to display the current record
		*m: filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		*p: ccursoralias		&& The alias of the cursor driving the TreeView
		*p: ccursorstructure		&& The structure of the cursor driving the TreeView as it would go into a CREATE CURSOR statement
	*</DefinedPropArrayMethod>

	ccursoralias = 		&& The alias of the cursor driving the TreeView
	ccursorstructure = ID C(60), TYPE C(60), PARENTID C(60), PARENTTYPE C(60), TEXT C(60), IMAGE C(20), SELIMAGE C(20), EXPIMAGE C(20), SORTED L, NODEKEY C(60)		&& The structure of the cursor driving the TreeView as it would go into a CREATE CURSOR statement
	lsortrootnodes = .T.
	lusepathaskey = .F.
	Name = "sftreeviewcursor"
	_memberdata = <VFPData>
		<memberdata name="ccursorstructure" type="property" display="cCursorStructure"/>
		<memberdata name="ccursoralias" type="property" display="cCursorAlias"/>
		<memberdata name="createtreeviewcursor" type="method" display="CreateTreeViewCursor"/>
		<memberdata name="filltreeviewcursors" type="method" display="FillTreeViewCursors"/>
		<memberdata name="filltreeviewcursor" type="method" display="FillTreeViewCursor"/>
		<memberdata name="displayrecord" type="method" display="DisplayRecord"/>
		<memberdata name="addnodetocollection" type="method" display="AddNodeToCollection"/>
		<memberdata name="lsortrootnodes" type="property" display="lSortRootNodes"/>
		<memberdata name="getnodekey" type="method" display="GetNodeKey"/>
		</VFPData>
	oTree.Height = 200
	oTree.Name = "oTree"
	oTree.Width = 210
	oImageList.Left = 160
	oImageList.Name = "oImageList"
	oImageList.Top = 0
	tmrSync.Name = "tmrSync"
	oStack.Name = "oStack"
	tmrReload.Name = "tmrReload"
	
	PROCEDURE about
		* Subclassing this control:
		*
		* - Fill in the LoadImages, FillTreeViewCursor, and DisplayRecord methods. See
		*   the comments in those methods for sample code.
		*
		* - Set lSortRootNodes as desired.
		*
		* - Set lAllowRename to .T. to always allow renaming the selected node (the
		*   default is .F.). You could also put code into DisplayRecord that sets
		*   lAllowRename to .T. if the selected node can be renamed. You'll need to add
		*   code to TreeAfterLabelEdit to rename the record in the source data.
		*
		* - Set lAllowDelete to .T. to always allow deleting the selected node (the
		*   default is .F.). You could also put code into DisplayRecord that sets
		*   lAllowDelete to .T. if the selected node can be deleted. (In that case,
		*   you could have a menu item or command button to delete the selected node
		*   with it conditionally being enabled based on lAllowDelete.) You'll need to
		*   add code to DeleteNode to remove the record from the source data and have
		*   it call RemoveNode to remove the node from the TreeView. You can also call
		*   This.oTree.Nodes.Remove(KeyValue) to remove other nodes (not child nodes,
		*   since those are automatically removed) if necessary.
		*
		* - Set lAllowInsert as .T. to allow the user to add nodes (the default is
		*   .F.). In that case, fill in InsertNode with the necessary code.
		*
		* - To persist expanded and selected nodes, set either cRegistryKey or, if the
		*   form has a cRegistryKey property and you want to use a subnode of that, set
		*   cRegistryKeySuffix.
		
	ENDPROC

	PROTECTED PROCEDURE addnodetocollection		&& Adds a node to the collection
		lparameters toCollection
		local lnRecno, ;
			lcID, ;
			lcType, ;
			llHasChildren, ;
			lcKey, ;
			loNodeItem
		with This
		
		* See if the current record has any children.
		
			lnRecno = recno()
			lcID    = ID
			lcType  = TYPE
			locate for PARENTID = lcID and PARENTTYPE = lcType
			llHasChildren = found()
			go lnRecno
		
		* If we don't have a key, create one and put it into NODEKEY.
		
			if empty(NODEKEY)
				lcKey = .GetNodeKey(TYPE, ID)
				replace NODEKEY with lcKey
			else
				lcKey = trim(NODEKEY)
			endif empty(NODEKEY)
		
		* Create a node item object and fill its properties from fields in the cursor
		* for the current record, then add it to the collection
		
			loNodeItem = .CreateNodeObject()
			with loNodeItem
				.Key           = lcKey
				.Text          = alltrim(TEXT)
				.Image         = alltrim(IMAGE)
				.SelectedImage = iif(empty(SELIMAGE), .Image, alltrim(SELIMAGE))
				.ExpandedImage = iif(empty(EXPIMAGE), .Image, alltrim(EXPIMAGE))
				.Sorted        = SORTED
				.HasChildren   = llHasChildren
			endwith
			toCollection.Add(loNodeItem)
		endwith
		
	ENDPROC

	PROCEDURE createtreeviewcursor		&& Creates the cursor driving the TreeView
		* Creates the cursor from cCursorStructure.
		
		local lcStructure
		lcStructure = This.cCursorStructure
		
		* Ensure we have parens around the structure string.
		
		if left(lcStructure, 1) <> '('
			lcStructure = '(' + lcStructure + ')'
		endif left(lcStructure, 1) <> '('
		
		* Create and index the cursor.
		
		create cursor (This.cCursorAlias) &lcStructure
		index on ID         tag ID
		index on PARENTID   tag PARENTID
		index on PARENTTYPE tag PARENTTYPE
		index on NODEKEY    tag NODEKEY
		index on TYPE       tag TYPE
		if This.lSortRootNodes
			index on upper(TEXT) tag TEXT
		endif This.lSortRootNodes
		
	ENDPROC

	PROCEDURE displayrecord		&& Called when a node is clicked to display the current record
		* Abstract method. The TreeView cursor (alias in This.cCursorAlias) is
		* positioned to the record for the node and This.cCurrentNodeID and
		* cCurrentNodeType contain the ID and type of the node, so typically you'll
		* find the record in the desired table and refresh the form to display
		* information about that record.
		
	ENDPROC

	PROCEDURE filltreeviewcursor		&& Fills the cursor driving the TreeView with the records to display
		* Abstract method. Typically, you'll add parent and child records to the
		* TreeView cursor using code like this:
		*
		* select ParentTable
		* scan
		*	insert into (This.cCursorAlias)
		*			(ID, ;
		*			TYPE, ;
		*			TEXT, ;
		*			IMAGE, ;
		*			SORTED) ;
		*		values ;
		*			(ParentTable.ID, ;
		*			'ParentType', ;
		*			ParentTable.SomeDescriptiveField, ;
		*			'ImageForParent', ;
		*			.T. for sorted children, .F. to display in order in cursor)
		* endscan
		* select ChildTable
		* scan
		*	insert into (This.cCursorAlias) ;
		*			(ID, ;
		*			PARENTID, ;
		*			TYPE, ;
		*			TEXT, ;
		*			IMAGE, ;
		*			SORTED) ;
		*		values ;
		*			(ChildTable.ID, ;
		*			ChildTable.ParentID, ;
		*			'ChildType', ;
		*			ChildTable.SomeDescriptiveField, ;
		*			'ImageForChild')
		*			.T. for sorted children (if there are children), .F. to display in order in cursor)
		* endscan
		*
		* Note:
		* - By default, ID and PARENTID are character fields (although you can change
		*   that in the cCursorStructure property), so use TRANSFORM() if the ID values
		*   are another data type.
		* - TYPE defines the type of record, so it can be things like "Parent" and
		*   "Child" or more descriptive like "Customer" and "Order"
		* - If you want different images when a node is selected or expanded, store the
		*   image key in SELIMAGE or EXPIMAGE.
		
	ENDPROC

	PROCEDURE getchildnodes
		* Get the child nodes for the specified parent.
		
		lparameters tcType, ;
			tcID, ;
			toCollection
		local lnSelect
		with This
			lnSelect = select()
			select (.cCursorAlias)
			set order to
			scan for alltrim(PARENTID) == alltrim(tcID) and alltrim(PARENTTYPE) == alltrim(tcType)
				.AddNodeToCollection(toCollection)
			endscan for alltrim(PARENTID) == alltrim(tcID) ...
			select (lnSelect)
		endwith
		
	ENDPROC

	PROCEDURE getnodekey
		lparameters tcType, ;
			tuID
		local lcKey
		lcKey = trim(tcType) + '~' + trim(transform(tuID))
		return lckey
		
	ENDPROC

	PROCEDURE getrootnodes
		* Fill the root node collection with all parent records (ie. where PARENTID is empty).
		
		lparameters toCollection
		local lnSelect, ;
			llHasChildren, ;
			loNodeItem
		with This
			lnSelect = select()
			select (.cCursorAlias)
			if .lSortRootNodes
				set order to TEXT
			else
				set order to
			endif .lSortRootNodes
			scan for empty(PARENTID)
				.AddNodeToCollection(toCollection)
			endscan for empty(PARENTID)
			select (lnSelect)
		endwith
		
	ENDPROC

	PROCEDURE gettypeandidfromnode
		lparameters toNode
		local loObject, ;
			lcAlias, ;
			lnRecno
		loObject = dodefault()
		lcAlias  = This.cCursorAlias
		lnRecno  = recno(lcAlias)
		if seek(toNode.Key, lcAlias, 'NODEKEY')
			loObject.ID   = trim(evaluate(lcAlias + '.ID'))
			loObject.Type = trim(evaluate(lcAlias + '.TYPE'))
		endif seek(toNode.Key, lcAlias, 'NODEKEY')
		if between(lnRecno, 1, reccount(lcAlias))
			go lnRecno in (lcAlias)
		endif between(lnRecno, 1, reccount(lcAlias))
		return loObject
		
	ENDPROC

	PROCEDURE Init
		* Create an alias for the TreeView cursor if we don't already have one.
		
		if empty(This.cCursorAlias)
			This.cCursorAlias = sys(2015)
		endif empty(This.cCursorAlias)
		dodefault()
		
	ENDPROC

	PROCEDURE loadimages
		* Abstract method to load the images for the ImageList control. Typically, code
		* will look like this:
		*
		* with This.oImageList
		*	.ListImages.Add(1, 'Image1Key', loadpicture('SomeImageFile'))
		*	.ListImages.Add(2, 'Image2Key', loadpicture('SomeImageFile'))
		* endwith
		*
		* Set ImageHeight and ImageWidth of This.oImageList to appropriate values if
		* the images are not 16x16.
		
	ENDPROC

	PROCEDURE loadtree
		Lparameters tlNoSelect
		With This
		
			* Close the cursor driving the TreeView if necessary.
		
			Use In Select(.cCursorAlias)
		
			* Create and fill the cursor.
		
			.CreateTreeViewCursor()
			.FillTreeViewCursor()
		Endwith
		
		* Do the usual behavior.
		
		Return DoDefault(tlNoSelect)
		
	ENDPROC

	PROCEDURE nodeclicked
		* Find the record for the selected node in the TreeView cursor.
		
		lparameters tlSameNode
		local lnSelect
		if not tlSameNode
			with This
				lnSelect = select()
				select (This.cCursorAlias)
				locate for ID = .cCurrentNodeID and TYPE = .cCurrentNodeType
				select (lnSelect)
				.DisplayRecord()
			endwith
		endif not tlSameNode
		
	ENDPROC

ENDDEFINE
