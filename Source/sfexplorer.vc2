*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfexplorer.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfexplorerform AS sfform OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oSplitter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oPersist" UniqueID="" Timestamp="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: addmenutoform		&& Adds a menu to the form
		*m: displayproperties		&& Displays the properties for the selected item
		*m: hideprogressbar		&& Hides the progress bar
		*m: restoreformsize		&& Restores the form size and position
		*m: saveformsize		&& Saves the form size and position
		*m: setupstatusbar		&& Sets up the properties of the status bar
		*m: statusbarclick		&& Fired when the user clicks the status bar
		*m: updatemessagepanel		&& Updates the text in the message panel
		*m: updateprogressbar		&& Updates the value of the progress bar
		*m: updatestatepanel		&& Updates the "state" panel of the status bar
		*p: ccurrentnodeid		&& The ID of the currently selected node
		*p: ccurrentnodekey		&& The key of the currently selected node
		*p: ccurrentnodetext		&& The text of the currently selected node
		*p: ccurrentnodetype		&& The type of the currently selected node
		*p: cdefaultstatemessage		&& The default message for the state panel of the status bar
		*p: cgobackicon		&& The icon to use for the Go Back panel
		*p: cregistrykey		&& The Registry key used for persisting settings
		*p: cstateiconbusy		&& The image to use when something other than the default message is displayed in the state panel
		*p: cstateiconready		&& The image to use when the default message is displayed in the state panel
		*p: cstatepanelname		&& The name of the state panel
		*p: ctoolbarclass		&& The class to use for a toolbar
		*p: ctoolbarlibrary		&& The library containing the class specified in cToolbarClass
		*p: lstatepanelautosize		&& .T. to auto-size the state panel
		*p: luseformfont		&& .T. for all objects to use the same font as the form
		*p: nheightadjust		&& The height the form is reduced by when a toolbar is docked
		*p: nsplitterleft		&& The starting position for the splitter control
		*p: nstatepanelwidth		&& The width of the state panel if lStatePanelAutoSize is .F.
		*p: otoolbar		&& A reference to a toolbar
	*</DefinedPropArrayMethod>

	ccurrentnodeid = 		&& The ID of the currently selected node
	ccurrentnodekey = 		&& The key of the currently selected node
	ccurrentnodetext = 		&& The text of the currently selected node
	ccurrentnodetype = 		&& The type of the currently selected node
	cdefaultstatemessage = Ready		&& The default message for the state panel of the status bar
	cgobackicon = Back.ico		&& The icon to use for the Go Back panel
	cregistrykey = 		&& The Registry key used for persisting settings
	cstateiconbusy = Red.ico		&& The image to use when something other than the default message is displayed in the state panel
	cstateiconready = Green.ico		&& The image to use when the default message is displayed in the state panel
	cstatepanelname = StatePanel		&& The name of the state panel
	ctoolbarclass = 		&& The class to use for a toolbar
	ctoolbarlibrary = 		&& The library containing the class specified in cToolbarClass
	DataSession = 2
	DoCreate = .T.
	Height = 330
	lstatepanelautosize = .F.		&& .T. to auto-size the state panel
	luseformfont = .T.		&& .T. for all objects to use the same font as the form
	MinHeight = 300
	MinWidth = 600
	Name = "sfexplorerform"
	nborderstyle = 3
	nheightadjust = 0		&& The height the form is reduced by when a toolbar is docked
	nsplitterleft = 0		&& The starting position for the splitter control
	nstatepanelwidth = 200		&& The width of the state panel if lStatePanelAutoSize is .F.
	otoolbar = .NULL.		&& A reference to a toolbar
	Width = 680
	_memberdata = <VFPData>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="ctoolbarclass" type="property" display="cToolbarClass"/>
		<memberdata name="ctoolbarlibrary" type="property" display="cToolbarLibrary"/>
		<memberdata name="nsplitterleft" type="property" display="nSplitterLeft"/>
		<memberdata name="otoolbar" type="property" display="oToolbar"/>
		<memberdata name="updatestatepanel" type="method" display="UpdateStatePanel"/>
		<memberdata name="updateprogressbar" type="method" display="UpdateProgressBar"/>
		<memberdata name="nstatepanelwidth" type="property" display="nStatePanelWidth"/>
		<memberdata name="lstatepanelautosize" type="property" display="lStatePanelAutoSize"/>
		<memberdata name="cstatepanelname" type="property" display="cStatePanelName"/>
		<memberdata name="hideprogressbar" type="method" display="HideProgressBar"/>
		<memberdata name="setupstatusbar" type="method" display="SetupStatusBar"/>
		<memberdata name="restoreformsize" type="method" display="RestoreFormSize"/>
		<memberdata name="updatemessagepanel" type="method" display="UpdateMessagePanel"/>
		<memberdata name="saveformsize" type="method" display="SaveFormSize"/>
		<memberdata name="cdefaultstatemessage" type="property" display="cDefaultStateMessage"/>
		<memberdata name="displayproperties" type="method" display="DisplayProperties"/>
		<memberdata name="ccurrentnodeid" type="property" display="cCurrentNodeID"/>
		<memberdata name="ccurrentnodekey" type="property" display="cCurrentNodeKey"/>
		<memberdata name="ccurrentnodetype" type="property" display="cCurrentNodeType"/>
		<memberdata name="cstateiconready" type="property" display="cStateIconReady"/>
		<memberdata name="cstateiconbusy" type="property" display="cStateIconBusy"/>
		<memberdata name="statusbarclick" type="method" display="StatusBarClick"/>
		<memberdata name="cgobackicon" type="property" display="cGoBackIcon"/>
		<memberdata name="luseformfont" type="property" display="lUseFormFont"/>
		<memberdata name="ccurrentnodetext" display="cCurrentNodeText"/>
		<memberdata name="addmenutoform" display="AddMenuToForm"/>
		<memberdata name="nheightadjust" display="nHeightAdjust"/>
		</VFPData>

	ADD OBJECT 'oPersist' AS sfpersistentform WITH ;
		Left = 0, ;
		lrestoreoninit = .F., ;
		lsaveondestroy = .F., ;
		Name = "oPersist", ;
		Top = 0
		*< END OBJECT: ClassLib="sfpersist.vcx" BaseClass="custom" />

	ADD OBJECT 'oSplitter' AS sfsplitterh WITH ;
		Height = 316, ;
		Left = 220, ;
		Name = "oSplitter", ;
		nobject1minsize = 200, ;
		nobject2minsize = 300, ;
		Top = 10, ;
		Width = 10
		*< END OBJECT: ClassLib="sfsplitter.vcx" BaseClass="control" />
	
	PROCEDURE about
		* Subclassing notes:
		*
		* - Add controls to the left and right of the splitter, adjusting the
		*   position and height of the splitter so it's right between them.
		*
		* - Set the following properties of oSplitter: cObject1Name,
		*   cObject1Name, nObject1MinSize, and nObject2MinSize.
		*
		* - Set cRegistryKey to the Registry key used to save and restore the size and
		*   position of this form.
		*
		* - Set cToolbarClass and cToolbarLibrary to the class and library for a
		*   toolbar if one is wanted.
		*
		* - Set lStatePanelAutoSize to .T. if the state panel (the rightmost one)
		*   should automatically size itself.
		*
		* - Set nStatePanelWidth to the desired width of the state panel if
		*   lStatePanelAutoSize is .F.
		*
		* - Set cGoBackIcon, cStateIconBusy, and cStateIconReady to the icons to use
		*   for the Go Back button and the state panel when the state is busy and ready
		*
		* - Set Caption and Icon as desired.
		
	ENDPROC

	PROCEDURE Activate
		* Create a toolbar if necessary. Because the toolbar takes up some of the form
		* height, ensure that the form is no smaller than the minimum height by setting
		* MinHeight to itself.
		
		with This
			if not empty(.cToolbarClass) and vartype(.oToolbar) <> 'O'
				lnHeight = .Height
				.oToolbar = newobject(.cToolbarClass, .cToolbarLibrary)
				.oToolbar.Dock(TOOL_TOP)
				.oToolbar.Show()
				.MinHeight     = .MinHeight
				.nHeightAdjust = lnHeight - .Height
			endif not empty(.cToolbarClass) ...
		endwith
		
	ENDPROC

	PROCEDURE addmenutoform		&& Adds a menu to the form
		* Abstract method.
		
	ENDPROC

	PROCEDURE afterrefresh
		* If we have a toolbar, refresh it.
		
		if vartype(This.oToolbar) = 'O'
			This.oToolbar.RefreshForm()
		endif vartype(This.oToolbar) = 'O'
		
	ENDPROC

	PROCEDURE displayproperties		&& Displays the properties for the selected item
		* Abstract method.
		
		lparameters tnPage
		
	ENDPROC

	PROCEDURE hideprogressbar		&& Hides the progress bar
		* Hides the progress bar.
		
		This.oStatus.ProgressBar.ctlVisible = .F.
		
	ENDPROC

	PROCEDURE Init
		* Set up the status bar.
		
		This.SetupStatusBar()
		dodefault()
		
	ENDPROC

	PROCEDURE releasemembers
		* Save the form size and position.
		
		This.SaveFormSize()
		dodefault()
		
	ENDPROC

	PROCEDURE restoreformsize		&& Restores the form size and position
		* Restores the form size and position.
		
		with This
			.nSplitterLeft = .oSplitter.Left
			if not empty(.cRegistryKey)
				if empty(.oPersist.cKey)
					.oPersist.cKey = .cRegistryKey
				endif empty(.oPersist.cKey)
				.oPersist.Restore()
			endif not empty(.cRegistryKey)
		endwith
		
	ENDPROC

	PROCEDURE saveformsize		&& Saves the form size and position
		* Saves the form size and position. Adjust the form's height by nHeightAdjust,
		* which is how much space a docked toolbar reduced the form height by.
		
		with This
			.Height        = .Height + .nHeightAdjust
			.nSplitterLeft = .oSplitter.Left
			if not empty(.cRegistryKey)
				.oPersist.Save()
			endif not empty(.cRegistryKey)
		endwith
		
	ENDPROC

	PROCEDURE setupstatusbar		&& Sets up the properties of the status bar
		* Set the properties of the status bar panels.
		
		Return
		
		with This.oStatus
		
		* Create a panel for a Go Back icon.
		
			with .ctlPanels(.ctlPanelCount - 1)
				.ctlName        = 'Back'
				.ctlWidth       = 30
				.ctlIcon        = This.cGoBackIcon
				.ctlToolTipText = iif(type('oLocalizer.Name') = 'C', ;
					oLocalizer.GetLocalizedString('STR_GO_BACK'), 'Go back')
			endwith
		
		* Create a state panel.	
		
			with .ctlPanels(.ctlPanelCount)
				.ctlName      = This.cStatePanelName
				.ctlAlignment = 1 && right
				.ctlAutoSize  = This.lStatePanelAutoSize
				.ctlWidth     = This.nStatePanelWidth
			endwith
		
		* Turn off other panels.
		
			.PanelOvr.ctlVisible  = .F.
			.PanelCaps.ctlVisible = .F.
			.PanelNum.ctlVisible  = .F.
			.PanelDate.ctlVisible = .F.
		endwith
		
		* Bind to the ctlClick event of the status bar.
		
		bindevent(This.oStatus, 'ctlClick', This, 'StatusBarClick')
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		local lnHeight
		with This
		
		* Do the default behavior.
		
			dodefault(tnStyle)
		
		* Add a menu to the form (AddMenuToForm is abstract in this class but can be
		* implemented in a subclass).
		
			.AddMenuToForm()
		
		* Restore the form height and position.
		
			.RestoreFormSize()
		
		* Move the splitter to its former position. Note that we do this here rather
		* than in RestoreFormSize because that method may be overridden.
		
			.oSplitter.MoveSplitterToPosition(.nSplitterLeft)
		
		* If all objects are supposed to use the same font as the form, do so.
		
			if .lUseFormFont
				.SetAll('FontName', .FontName)
			endif .lUseFormFont
		
		* Display the default message in the status bar.
		
			.UpdateStatePanel()
		endwith
		
	ENDPROC

	PROCEDURE statusbarclick		&& Fired when the user clicks the status bar
		* Abstract method
		
	ENDPROC

	PROCEDURE updatemessagepanel		&& Updates the text in the message panel
		* Updates the message in the message panel and returns the former message.
		
		lparameters tcMessage
		local lcText
		with This
			lcText = .oStatus.ctlMessage
			if not lcText == tcMessage
				.oStatus.ctlMessage = tcMessage
			endif not lcText == tcMessage
		endwith
		return lcText
		
	ENDPROC

	PROCEDURE updateprogressbar		&& Updates the value of the progress bar
		* Ensures the progress bar is visible and updates its value.
		
		lparameters tnValue
		if tnValue = 0
			This.HideProgressBar()
		else
			with This.oStatus.ProgressBar
				if not .ctlVisible
					.ctlVisible = .T.
				endif not .ctlVisible
				.ctlValue = tnValue
			endwith
		endif tnValue = 0
		doevents
		
	ENDPROC

	PROCEDURE updatestatepanel		&& Updates the "state" panel of the status bar
		* Updates the message in the state panel (another panel name can also be
		* passed to update that panel) and returns the former message.
		
		lparameters tcMessage, ;
			tcPanel
		local lnPanel, ;
			loPanel, ;
			lcText
		with This
			lcPanel = iif(vartype(tcPanel) = 'C' and not empty(tcPanel), tcPanel, ;
				.cStatePanelName)
			if type('.oStatus.' + lcPanel + '.Name') = 'C'
		
		* Get a reference to the panel and the current text so we can return it.
		
				loPanel = .oStatus.&lcPanel
				lcText  = loPanel.ctlCaption
		
		* If the message wasn't specified, use the default message.
		
				lcMessage = iif(vartype(tcMessage) = 'C' and (not empty(tcMessage) or ;
					lcPanel <> .cStatePanelName), tcMessage, .cDefaultStateMessage)
		
		* If the message is different than the current text, use the message.
		
				if not lcText == lcMessage
					loPanel.ctlCaption = lcMessage
		
		* Display the appropriate image.
		
					do case
						case lcPanel <> .cStatePanelName
						case lcMessage = .cDefaultStateMessage and ;
							not empty(.cStateIconReady)
							loPanel.ctlIcon = .cStateIconReady
						case lcMessage <> .cDefaultStateMessage and ;
							not empty(.cStateIconBusy)
							loPanel.ctlIcon = .cStateIconBusy
					endcase
				endif not lcText == lcMessage
			endif type('.oStatus.' + lcPanel + '.Name') = 'C'
		endwith
		return lcText
		
	ENDPROC

	PROCEDURE oPersist.defineitems
		* Tell the persistence object that it's supposed to save and restore the value
		* of the nSplitterLeft property.
		
		dodefault()
		This.AddItem('SplitterPosition', 'Thisform.nSplitterLeft')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfexplorerformtreeview AS sfexplorerform OF "sfexplorer.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oTreeViewContainer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties" UniqueID="" Timestamp="" />

	DoCreate = .T.
	Name = "sfexplorerformtreeview"
	oSplitter.cobject1name = oTreeViewContainer
	oSplitter.cobject2name = pgfProperties
	oSplitter.Height = 306
	oSplitter.Left = 208
	oSplitter.Name = "oSplitter"
	oSplitter.Top = 0
	oPersist.Name = "oPersist"
	oStatus.lblname.Name = "lblname"
	oStatus.Name = "oStatus"
	oStatus.tmrHideVFPStatusBar.Name = "tmrHideVFPStatusBar"

	ADD OBJECT 'oTreeViewContainer' AS sftreeviewexplorer WITH ;
		Height = 308, ;
		Left = -2, ;
		lloadtreeviewatstartup = .F., ;
		Name = "oTreeViewContainer", ;
		Top = -2, ;
		Width = 210, ;
		oTree.Height = 295, ;
		oTree.Name = "oTree", ;
		oTree.Width = 210, ;
		oImageList.Left = 160, ;
		oImageList.Name = "oImageList", ;
		oImageList.Top = 0, ;
		tmrSync.Name = "tmrSync", ;
		oStack.Name = "oStack"
		*< END OBJECT: ClassLib="sfexplorer.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProperties' AS sfpageframe WITH ;
		Anchor = 13, ;
		ErasePage = .T., ;
		Height = 309, ;
		Left = 218, ;
		luseformshortcutmenu = .T., ;
		Name = "pgfProperties", ;
		TabIndex = 2, ;
		Tabs = .F., ;
		Top = -1, ;
		Width = 465, ;
		sfpage1.Name = "sfpage1"
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="pageframe" />
	
	PROCEDURE about
		* Subclassing notes:
		*
		* - Set pgfProperties.PageCount to the desired number of pages and add controls
		*   to each page. These will likely be containers of controls (you can use
		*   SFPropertiesContainer if desired but not required).
		*
		* Subclassing notes from This.Parent:
		*
		* - Set cRegistryKey to the Registry key used to save and restore the size and
		*   position of this form.
		*
		* - Set cToolbarClass and cToolbarLibrary to the class and library for a
		*   toolbar if one is wanted.
		*
		* - Set lStatePanelAutoSize to .T. if the state panel (the rightmost one)
		*   should automatically size itself.
		*
		* - Set nStatePanelWidth to the desired width of the state panel if
		*   lStatePanelAutoSize is .F.
		*
		* - Set Caption and Icon as desired.
		*
		* Subclassing notes from SFTreeViewCursor:
		*
		* - Fill in the LoadImages and FillTreeViewCursor methods of
		*   oTreeViewContainer. See the comments in those methods in SFTreeViewCursor
		*   for sample code.
		*
		* - Set lSortRootNodes as desired.
		*
		* - Set lAllowRename to .T. to always allow renaming the selected node (the
		*   default is .F.). You could also put code into the Refresh method of
		*   container objects on the appropriate page of the pageframe that sets
		*   lAllowRename to .T. if the selected node can be renamed. You'll need to add
		*   code to TreeAfterLabelEdit to rename the record in the source data.
		*
		* - Set lAllowDelete to .T. to always allow deleting the selected node (the
		*   default is .F.). You could also put code into the Refresh method of
		*   container objects on the appropriate page of the pageframe that sets
		*   lAllowDelete to .T. if the selected node can be deleted. (In that case,
		*   you could have a menu item or command button to delete the selected node
		*   with it conditionally being enabled based on lAllowDelete.) You'll need to
		*   add code to DeleteNode to remove the record from the source data and have
		*   it call RemoveNode to remove the node from the TreeView. You can also call
		*   This.oTree.Nodes.Remove(KeyValue) to remove other nodes (not child nodes,
		*   since those are automatically removed) if necessary.
		*
		* - Set lAllowInsert as .T. to allow the user to add nodes (the default is
		*   .F.). In that case, fill in InsertNode with the necessary code.
		*
		* - Fill in cRegistryKeySuffix with the subnode of the Registry key for the
		*   form if you want to use a subnode. Otherwise, leave it blank to store the
		*   settings for the TreeView in the form's Registry key.
		
	ENDPROC

	PROCEDURE displayproperties		&& Displays the properties for the selected item
		* Display information about the selected item by selecting the specified page
		* in the properties pageframe and refreshing it.
		
		lparameters tnPage
		with This
			if between(tnPage, 1, .pgfProperties.PageCount)
				.pgfProperties.ActivePage = tnPage
				.pgfProperties.Pages(tnPage).Refresh()
			endif between(tnPage, 1, .pgfProperties.PageCount)
		endwith
		
	ENDPROC

	PROCEDURE Show
		* Load the TreeView if it hasn't already been.
		
		lparameters tnStyle
		if not This.oTreeViewContainer.lLoadTreeviewAtStartup
			This.oTreeViewContainer.LoadTree()
		endif not This.oTreeViewContainer.lLoadTreeviewAtStartup
		dodefault(tnStyle)
		
	ENDPROC

	PROCEDURE statusbarclick		&& Fired when the user clicks the status bar
		* If the user clicked the Go Back panel, tell the TreeView to go back to the
		* previous node.
		
		local loPanel
		with This
			if .oStatus.nPanel > 0
				loPanel = .oStatus.ctlPanels(.oStatus.nPanel)
				if vartype(loPanel) = 'O' and loPanel.ctlName = 'Back'
					.oTreeViewContainer.GoBack()
				endif vartype(loPanel) = 'O' ...
			endif .oStatus.nPanel > 0
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sftreeviewexplorer AS sftreeviewcursor OF "sftreeview.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: updatenodetext		&& Call this when the text of the node should change
	*</DefinedPropArrayMethod>

	ccursorstructure = ID C(60), TYPE C(60), PARENTID C(60), PARENTTYPE C(60), TEXT C(60), IMAGE C(20), SELIMAGE C(20), EXPIMAGE C(20), SORTED L, NODEKEY C(60), PAGE N(1)
	luseformshortcutmenu = .T.
	Name = "sftreeviewexplorer"
	_memberdata = <VFPData>
		<memberdata name="updatenodetext" display="UpdateNodeText"/>
		</VFPData>
	oTree.Height = 200
	oTree.Name = "oTree"
	oTree.Width = 210
	oImageList.Left = 160
	oImageList.Name = "oImageList"
	oImageList.Top = 0
	tmrSync.Name = "tmrSync"
	oStack.Name = "oStack"
	tmrReload.Name = "tmrReload"
	
	PROCEDURE displayrecord
		lparameters tnPage
		local lnPage
		with This
		
		* Get the page we're supposed to display.
		
			do case
				case vartype(tnPage) = 'N'
					lnPage = tnPage
				case not empty(.cCursorAlias) and used(.cCursorAlias)
					lnPage = evaluate(.cCursorAlias + '.PAGE')
				otherwise
					lnPage = 0
			endcase
		
		* Set the node ID, key, and type for the selected item.
		
			Thisform.cCurrentNodeID   = .cCurrentNodeID
			Thisform.cCurrentNodeKey  = .cCurrentNodeKey
			Thisform.cCurrentNodeType = .cCurrentNodeType
			Thisform.cCurrentNodeText = .cCurrentNodeText
		
		* Display the properties for the selected item.
		
			if lnPage <> 0 and .lInitialized
				Thisform.DisplayProperties(lnPage)
			endif lnPage <> 0 ...
		endwith
		
	ENDPROC

	PROCEDURE loadexpandednode
		* Show a message in the status bar while we load the children for a node.
		
		lparameters toNode
		local lcMessage, ;
			lcText
		lcMessage = iif(type('oLocalizer.Name') = 'C', ;
			oLocalizer.GetLocalizedString('MSG_LOADING'), 'Loading...')
		lcText = Thisform.UpdateStatePanel(lcMessage)
		dodefault(toNode)
		Thisform.UpdateStatePanel(lcText)
		
	ENDPROC

	PROCEDURE loadtree
		* Show a message in the status bar while we load the tree.
		
		lparameters tlNoSelect
		local lcMessage
		lcMessage = iif(type('oLocalizer.Name') = 'C', ;
			oLocalizer.GetLocalizedString('MSG_LOADING'), 'Loading...')
		Thisform.UpdateStatePanel(lcMessage)
		dodefault(tlNoSelect)
		lcMessage = iif(type('oLocalizer.Name') = 'C', ;
			oLocalizer.GetLocalizedString('STR_DEFAULT_STATUS'), 'Ready')
		Thisform.UpdateStatePanel(lcMessage)
		
	ENDPROC

	PROCEDURE updatenodetext		&& Call this when the text of the node should change
		lparameters tcType, ;
			tuID, ;
			tcName
		local lcKey, ;
			loNode, ;
			lcMessage
		with This
			lcKey = .GetNodeKey(tcType, tuID)
			if type('.oTree.Nodes[lcKey]') = 'O'
				loNode      = .oTree.Nodes[lcKey]
				store tcName to loNode.Text, .cCurrentNodeText, ;
					Thisform.cCurrentNodeText
				if .lSortRootNodes
					.oTree.Sorted = .T.
				endif .lSortRootNodes
			endif type('loControl.oTree.Nodes[lcKey]') = 'O'
		endwith
		
	ENDPROC

ENDDEFINE
