SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CJ075YOW
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_animation
[START PROPERTIES]
Name = "ctl32_animation"
ctlTextbox.Name = "ctlTextbox"
lblname.Name = "lblname"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_animation
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1T811MAIO
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_balloontip
[START PROPERTIES]
BackColor = 140,200,200
ForeColor = 255,0,245
Height = 48
Name = "ctl32_balloontip"
Visible = .F.
Width = 120
ctlabout = ctl32_balloontip - Carlos Alloatti.
ctlactive = .T.
ctlalignment = 3
ctlbackcolor = -1
ctlcapslockstyle = .F.
ctlclosebutton = .F.
ctlcontrol = 
ctlfadein = .F.
ctlfadeout = .F.
ctlfontbold = 
ctlfontcharset = 
ctlfontitalic = 
ctlfontname = 
ctlfontsize = 
ctlfontstrikethru = 
ctlfontunderline = 
ctlforecolor = -1
ctlhidedelay = 5000
ctlhwnd = 0
ctlicon = 0
ctliconlarge = .F.
ctllangid = 0
ctlleft = 0
ctllink = 
ctllinklabel = 
ctllinkurl = 
ctlmargin = 0
ctlmarginbottom = 0
ctlmarginleft = 0
ctlmarginright = 0
ctlmargintop = 0
ctlmaxwidth = 255
ctloffsetx = 0.75
ctloffsety = 0.75
ctlposition = 3
ctlpositionstyle = 1
ctlshowdelay = 200
ctlstyle = 1
ctltext = 
ctltitle = 
ctltop = 0
ctlversion = 20070711
ctlvisible = .F.
[END PROPERTIES]
[START PROTECTED]
_addproperties^
_bindevents^
_create^
_eventhandlerformmoved^
_eventhandlerformresize^
_eventhandlerscreenmoved^
_getfontdefault^
_gettrackposparam^
_messagehandlerformwm_keydown^
_messagehandlerhostwm_lbuttondown^
_messagehandlerhostwm_notify^
_setfont^
_seticonandtitle^
_setlocalestrings^
_setmargins^
_showstyle1^
_showstyle2^
ctlactive_assign^
ctlalignment_assign^
ctlbackcolor_assign^
ctlcapslockstyle_assign^
ctlclosebutton_assign^
ctlfadein_assign^
ctlfadeout_assign^
ctlfontbold_assign^
ctlfontcharset_assign^
ctlfontitalic_assign^
ctlfontname_assign^
ctlfontsize_assign^
ctlfontstrikethru_assign^
ctlfontunderline_assign^
ctlforecolor_assign^
ctlhidedelay_assign^
ctlhwnd_access^
ctlhwnd_assign^
ctlicon_assign^
ctliconlarge_assign^
ctllangid_assign^
ctllink_access^
ctlmargin_assign^
ctlmarginbottom_assign^
ctlmarginleft_assign^
ctlmarginright_assign^
ctlmargintop_assign^
ctlmaxwidth_assign^
ctlshowdelay_assign^
ctlstyle_assign^
ctltext_assign^
ctltitle_assign^
ctlvisible_assign^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
apiDestroyWindow(This._ControlHwnd)

*!* Disable timer just in case (Forum/rcanop/2006-11-26)
This.tmrShow.Enabled = FALSE

*!* Control is an object reference to the control to use to locate the balloontip
This.ctlControl = Null

*!* oToolInfo is an instance of the _toolinfo class of ctl32_structs
This.oToolInfo = Null

*!* loIcon is an object reference to an icon file if a custom icon was used
This.oIcon = Null

*!* oFont stores a handle to a Logical Font in memory
If This.oFont <> 0 Then
    apiDeleteObject(This.oFont)
Endif

ENDPROC
PROCEDURE Init

*!* If we have a parameter, Status Bar is creating this
Lparameters m.tnParam

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

*!* This Property we need now:
If Not Pemstatus(This, "_StatusBarHwnd", CON_PEMSTAT_DEFINED)
	This.AddProperty("_StatusBarHwnd", 0)
Endif

*!* If we have a parameter, Status Bar is creating this
If Pcount() > 0 And Type("m.tnParam") = T_NUMERIC Then
	This._StatusBarHwnd = m.tnParam
Endif

*!* Check if -1 parameter from statusbar, that means no Init yet
If This._StatusBarHwnd = -1
	Return
Endif

This._AddObjects()
This._AddProperties()
This._SetLocaleStrings()
This._Create()
This._BindEvents()

ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* This will hold an object reference to a custom icon to display in balloontip
This.AddProperty("oIcon", 0)

*!* Add oToolInfo object
This.AddProperty("oToolInfo", Createobject("ctlToolInfo"))

*!* Rect structure
This.AddProperty("oRect", Createobject("ctlRect"))

*!* nonclientmetrics structure
*!* This.AddProperty("oNonClientMetrics", Newobject("_NonClientMetrics", m.lcVcxStructs))

*!* logfont structure
This.AddProperty("oLogFont", Createobject("ctlLogFont"))

*!* This stores a font object reference that we apply to the tooltip
*!* it gets released at Destroy() event
This.AddProperty("oFont", 0)

ENDPROC
PROCEDURE _addproperties
*!* _AddProperties()

*!* Here we add properties to the class that will be used internally

*!* Stores the hWnd of the host window
This.AddProperty("_HosthWnd", ctlGetHostHWnd(This))

*!* Indicates we are in the creation stage
This.AddProperty("_Creating", FALSE)

*!* Stores the value of VFP window procedure
This.AddProperty("_VFPWndProc", apiGetWindowLong(_vfp.HWnd, GWL_WNDPROC))

*!* Stores hWnd of Windows common control created by the class
This.AddProperty("_ControlHwnd", 0)

*!* These 2 properties hold the title and text for the capslock balloontip
This.AddProperty("_LangTitle", "")
This.AddProperty("_LangText", "")

*!* Specifies the state of the TTM_TRACKACTIVATE flag
This.AddProperty("_TrackActive", 0)

*!* Saves old TrackPosition, used by ctlTrack()
This.AddProperty("_OldTrackPosition", 0)

*!* Font handling properties:

*!* This indicates if the default system font for tooltips has
*!* already been saved in _DefaultLogFont
This.AddProperty("_DefaultFontSaved", FALSE)

*!* This stores a LogFont structure of the default system font as a string
*!* for tooltips
This.AddProperty("_DefaultLogFont", "")

*!* This indicates if _SetFont is allowed to continue
This.AddProperty("_SetFontEnable", TRUE)




ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

Bindevent(Thisform, "RESIZE", This, "_EventHandlerFormResize", 1)
Bindevent(Thisform, "MOVED", This, "_EventHandlerFormMoved", 1)
Bindevent(_Screen, "MOVED", This, "_EventHandlerScreenMoved", 1)

Bindevent(Thisform.HWnd, WM_KEYDOWN, This, "_MessageHandlerFormWm_KeyDown", 1)
Bindevent(This._HosthWnd, WM_LBUTTONDOWN, This, "_MessageHandlerHostWm_lButtonDown", 1)

*!* Catch clicks in links

If Pemstatus(Thisform,"_WM_NOTIFY_HWND", 5) = FALSE Then
	Thisform.AddProperty("_WmNotifyHwnd", 0)
	Thisform.AddProperty("_WmNotifyMsg", 0)
	Thisform.AddProperty("_WmNotifyWparam", 0)
	Thisform.AddProperty("_WmNotifyLparam", 0)
Endif

Bindevent(This._HosthWnd, WM_NOTIFY, This, "_MessageHandlerHostWm_Notify", 1)
Bindevent(Thisform, "_WmNotifyMsg", This, "_PropertyHandlerFormWmNotifyMsg", 1)


ENDPROC
PROCEDURE _create
*!* _Create()

*!*	CON_STYLE_BALLOON						1
*!*	CON_STYLE_RECT							2
*!*	CON_STYLE_NOBORDER						3


*!* This procedure creates the Window common control and sets its initial properties

*!* Destroy current tooltip window if present
If This._ControlHwnd <> 0 Then
    apiDestroyWindow(This._ControlHwnd)
    This._ControlHwnd = 0
Endif

This._Creating = TRUE

Local ;
    dwExStyle As Integer, ;
    lpClassName As String, ;
    lpWindowName As String, ;
    dwStyle As Integer, ;
    hWndParent As Integer, ;
    hMenu As Integer, ;
    hInstance As Integer, ;
    lpParam As Integer, ;
    lcToolInfo As String

*!* Set apiCreateWindowEx parameters
m.dwExStyle = 0
m.lpClassName = TOOLTIPS_CLASSA
m.lpWindowName = ""

*!* 20070830 TTS_USEVISUALSTYLE property removed, makes text all blue in Vista
m.dwStyle = Bitor(TTS_NOANIMATE, TTS_NOPREFIX)

If This.ctlStyle = CON_BTSTYLE_BALLOON
    m.dwStyle = Bitor(m.dwStyle, TTS_BALLOON)
Endif

If This.ctlCloseButton = TRUE Then
    m.dwStyle = Bitor(m.dwStyle, TTS_CLOSE)
Endif

If This.ctlFadeIn = FALSE Then
    m.dwStyle = Bitor(m.dwStyle, TTS_NOFADE)
Endif

m.hWndParent = 0

m.hMenu = 0
m.hInstance = 0
m.lpParam = 0

This._ControlHwnd = apiCreateWindowEx( ;
    m.dwExStyle, ;
    m.lpClassName, ;
    m.lpWindowName, ;
    m.dwStyle, ;
    CW_USEDEFAULT, ;
    CW_USEDEFAULT, ;
    CW_USEDEFAULT, ;
    CW_USEDEFAULT, ;
    m.hWndParent, ;
    m.hMenu, ;
    m.hInstance, ;
    m.lpParam)

*!* Add TOOL
This.oToolInfo.uFlags   = Bitor(TTF_IDISHWND, TTF_TRACK, TTF_TRANSPARENT, TTF_PARSELINKS, TTF_BITMAP)

*!* If tooltip does not have balloon style, then position is absolute:
If This.ctlStyle <> CON_BTSTYLE_BALLOON Then
    This.oToolInfo.uFlags   = Bitor(This.oToolInfo.uFlags, TTF_ABSOLUTE)
Endif

*!* Check if we have a centered balloon tip:
If This.ctlStyle = CON_BTSTYLE_BALLOON ;
        And Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER) Then
    This.oToolInfo.uFlags   = Bitor(This.oToolInfo.uFlags, TTF_CENTERTIP)
Endif

This.oToolInfo.hWnd			= This._HosthWnd
This.oToolInfo.hInst    	= 0
This.oToolInfo.uId      	= This._HosthWnd
This.oToolInfo.Rect.Left	= 0
This.oToolInfo.Rect.Top		= 0
This.oToolInfo.Rect.Right	= 0
This.oToolInfo.Rect.Bottom	= 0

This.oToolInfo.lpszText	= NULCHAR
This.oToolInfo.lParam			= 0

m.lcToolInfo = This.oToolInfo.Value

apiSendMessage(This._ControlHwnd, TTM_ADDTOOLA, 0, @m.lcToolInfo)

*!* 20070608 Assign colors before text or color change fails:
This.ctlBackColor = This.ctlBackColor
This.ctlForeColor = This.ctlForeColor

*!* Save default system font for tooltips:
This._GetFontDefault()

*!* Set font of tooltip:
This._SetFont()

This.ctlIcon = 		This.ctlIcon && also assigns ctlTitle
This.ctlText = 		This.ctlText
This.ctlHideDelay = This.ctlHideDelay
This.ctlShowDelay = This.ctlShowDelay
This.ctlMaxWidth = 	This.ctlMaxWidth

If This.ctlMarginTop <> 0 ;
        Or This.ctlMarginLeft <> 0 ;
        Or This.ctlMarginRight <> 0 ;
        Or This.ctlMarginBottom <> 0 Then

    This._SetMargins()

Endif

If This.ctlMargin <> 0 Then
    This.ctlMargin = 	This.ctlMargin
Endif

*!* 20071022 changed bitclear to bitxor/bitor

*If This.ctlStyle = CON_BTSTYLE_NOBORDER Then
*!* Borders have no effect on Vista
If ctlGetOsVersion() < NTDDI_VISTA Then
    m.dwStyle = apiGetWindowLong(This.ctlHWnd, GWL_STYLE)

    If This.ctlStyle = CON_BTSTYLE_NOBORDER Then

        m.dwStyle = Bitxor(Bitor(m.dwStyle, WS_BORDER), WS_BORDER)

    Endif

    *!* Have to remove TTS_CLOSE button:
    If This.ctlCloseButton = FALSE Then
        m.dwStyle = Bitxor(Bitor(m.dwStyle, TTS_CLOSE), TTS_CLOSE)
    Endif

    apiSetWindowLong(This.ctlHWnd, GWL_STYLE, m.dwStyle)

    *!* This makes the window "refresh"
    *        apiSendMessage(This.ctlHWnd, TTM_UPDATE, 0, 0)
    *        apiSetWindowPos(This.ctlHWnd, ;
    0, ;
    0, ;
    0, ;
    0, ;
    0, ;
    BITOR(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_NOACTIVATE, SWP_FRAMECHANGED))
Endif
*Endif

This._Creating = FALSE



ENDPROC
PROCEDURE _eventhandlerformmoved
*!* _EventHandlerFormMoved

If This.ctlVisible And This.ctlActive Then
	This.ctlVisible = FALSE
	Raiseevent(This, "ctlHide", 6)
Endif

ENDPROC
PROCEDURE _eventhandlerformresize
*!* _EventHandlerFormResize

If This.ctlVisible and This.ctlActive Then
	This.ctlVisible = FALSE
	Raiseevent(This, "ctlHide", 6)
Endif

ENDPROC
PROCEDURE _eventhandlerscreenmoved
*!* _EventHandlerScreenMoved

If This.ctlVisible And This.ctlActive Then
	This.ctlVisible = FALSE
	Raiseevent(This, "ctlHide", 6)
Endif

ENDPROC
PROCEDURE _getfontdefault
*!* _GetFontDefault()

*!* Here we save the original system default font for tooltips, so we can
*!* use it later in ctlSetDefaultFont()

*!* This method is called only from _Create()

*!* If default system font for tooltips has been saved, return:
If This._DefaultFontSaved = TRUE Then
    Return
Endif

Local ;
	lnFont As Integer, ;
    lcLogFont As String, ;
    lnLen As Integer

*!* Get a handle to the current font of the tooltip:
m.lnFont = apiSendMessage(This._ControlHwnd, WM_GETFONT, 0, 0)

*!* Initialize an empty logfont structure:
m.lcLogFont = This.oLogFont.Value
m.lnLen = Len(m.lcLogFont)

*!* Get font info from font handle, as a logfont stucture:
apiGetobject(m.lnFont, m.lnLen, @m.lcLogFont)

*!* Save logfont structure:
This._DefaultLogFont = m.lcLogFont

*!* Use oLogFont object to obtain structure members
This.oLogFont.Value = m.lcLogFont

*!* Disable font updates to the tooltip:
This._SetFontEnable = FALSE

*!* Here we fill the empty font properties with the default values:
If Empty(This.ctlFontBold) Then
    This.ctlFontBold = This.oLogFont.FontBold
Endif

If Empty(This.ctlFontCharSet) Then
    This.ctlFontCharSet = This.oLogFont.FontCharSet
Endif

If Empty(This.ctlFontItalic) Then
    This.ctlFontItalic = This.oLogFont.FontItalic
Endif

If Empty(This.ctlFontName) Then
    This.ctlFontName = This.oLogFont.FontName
Endif

If Empty(This.ctlFontSize) Then
    This.ctlFontSize = This.oLogFont.FontSize
Endif

If Empty(This.ctlFontStrikethru) Then
    This.ctlFontStrikethru = This.oLogFont.FontStrikethru
Endif

If Empty(This.ctlFontUnderline) Then
    This.ctlFontUnderline = This.oLogFont.FontUnderline
Endif

This._SetFontEnable = TRUE

m.lnFont = Null

This._DefaultFontSaved = TRUE

ENDPROC
PROCEDURE _gettrackposparam
*!* _GetTrackPosParam()

Lparameters m.tnX As Integer, m.tnY As Integer

Local ;
    lnX As Integer, ;
    lnY As Integer, ;
    lnParam As Integer

Local lcPoint As String

*!* Convert form coordinates to screen coordinates:
m.lcPoint = ctlMakePoint(m.tnX, m.tnY)
*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
apiClientToScreen(This._HostHWnd, @m.lcPoint)
m.lnX = ctlGetXFromPoint(m.lcPoint)
m.lnY = ctlGetYFromPoint(m.lcPoint)

*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
m.lnParam = ctlMakelParam(m.lnX, m.lnY)

Return m.lnParam

ENDPROC
PROCEDURE _messagehandlerformwm_keydown
*!* _MessageHandlerFormWm_KeyDown

Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer

Local lnResult As Number

If This.ctlActive
	If This.ctlCapsLockStyle Then
		*!* If last key pressed was CAPS LOCK
		If m.pnWparam = VK_CAPITAL
			*!* If CAPS LOCK was set to on:
			If Bittest(apiGetKeyState(VK_CAPITAL), 0) = TRUE Then
				This.ctlVisible = TRUE
			Endif
			*!* If CAPS LOCK was set to off and the balloontip is visible:
			If Bittest(apiGetKeyState(VK_CAPITAL), 0) = FALSE And This.ctlVisible Then
				This.ctlVisible = FALSE
				Raiseevent(This, "ctlHide", 5)
			Endif
		Else
			*!* Key pressed was not CAPS LOCK, hide the balloontip is visible
			If This.ctlVisible  Then
				This.ctlVisible = FALSE
				Raiseevent(This, "ctlHide", 4)
			Endif
		Endif
	Else
		*!* Not ctlCapsLockStyle, Hide balloontip with any key
		If This.ctlVisible  Then
			This.ctlVisible = FALSE
			Raiseevent(This, "ctlHide", 4)
		Endif
	Endif

Endif

m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)

Return m.lnResult

ENDPROC
PROCEDURE _messagehandlerhostwm_lbuttondown
*!* _MessageHandlerHostWm_lButtonDown

*!*	Here we detect a mouseclick on the form. The Balloontip transfers its mouse events to the form
*!*	HWND. When the user clicks on the form or the balloontip, we hide the balloontip.
*!*	IF the user clicked on the form, the form gets the click. If the user clicked on the balloontip
*!*	we discard the click to prevent undesired clicks on the underlying form. For example, if underneath
*!*	the balloontip there is a button, and the user clicks the balloontip to hide it, the button
*!*	will get the click. This method prevents that.

Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer

Local lnResult As Number, lnX, lnY, lcPoint, lnOption, loRect, lcRect

m.lnOption = -1		&& not used

If This.ctlVisible And This.ctlActive Then

	m.lnOption = 0		&& do not discard click

	*!* Get form coordinates of mouse click from lParam

	m.lnX = ctlGet_X_lParam(m.pnLparam)
	m.lnY = ctlGet_Y_lParam(m.pnLparam)

	*!* Convert form coordinates to screen coordinates:
	m.lcPoint = ctlMakePoint(m.lnX, m.lnY)
	*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
	apiClientToScreen(This._HostHWnd, @m.lcPoint)
	m.lnX = ctlGetXFromPoint(m.lcPoint)
	m.lnY = ctlGetYFromPoint(m.lcPoint)

	*!* apiWindowFromPoint only works on XP and up, in 98 and 2K returns hwnd of form
	If ctlGetOsVersion() >= NTDDI_WINXP Then
		*!* We will check if the mouse click is in the ballontip or in the form
		*!* If the mouse click is on the balloontip, we do not pass the click to the form
		If apiWindowFromPoint(m.lnX, m.lnY) = This.ctlHwnd Then
			m.lnOption = 1	&& discard
		Endif
	Else
		*!* Not XP, use WindowRect that is not as exact, but close

		m.lcRect = This.oRect.Value
		apiGetWindowRect(This.ctlHwnd, @m.lcRect)
		This.oRect.Value = m.lcRect
		If Between(m.lnY, This.oRect.Top, This.oRect.Bottom) And ;
				between(m.lnX, This.oRect.Left, This.oRect.Right) Then
			m.lnOption = 1 	&& Discard
		Endif
	Endif

	*!* Hide BalloonTip
	This.ctlVisible = FALSE

Endif

Do Case

	Case m.lnOption = -1	&& BalloonTip not visible and active
		m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)

	Case m.lnOption = 0		&& BalloonTip visible, click was outside balloontip
		m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)
		Raiseevent(This, "ctlHide", 2)

	Case m.lnOption = 1		&& BalloonTip visible, click was inside balloontip
		m.lnResult  = 1
		Raiseevent(This, "ctlHide", 1)
Endcase

Return m.lnResult

ENDPROC
PROCEDURE _messagehandlerhostwm_notify
*!* _MessageHandlerHostWm_Notify

Lparameters pnHWnd As Integer, pnMsg As Integer, pnWparam As Integer, pnLparam As Integer

Local lnResult As Integer

m.lnResult  = apiCallWindowProc(This._VFPWndProc, m.pnHWnd, m.pnMsg, m.pnWparam, m.pnLparam)

Thisform._WmNotifyHwnd		= m.pnHWnd
Thisform._WmNotifyWparam	= m.pnWparam
Thisform._WmNotifyLparam	= m.pnLparam
Thisform._WmNotifyMsg		= m.pnMsg

Return m.lnResult

ENDPROC
PROCEDURE _propertyhandlerformwmnotifymsg
*!* _PropertyHandlerFormWmNotifyMsg

*!* This fires when the WM_NOTIFY_MSG property of the form changes

Local lnCode, loNmhdr As ctlNMHDR

m.loNmhdr = Createobject("ctlNMHDR", Thisform._WmNotifyLparam)

If This._ControlHwnd <> m.loNmhdr.hwndFrom Then
	Return
Endif

m.lnCode = m.loNmhdr.Code

If m.lnCode = TTN_LINKCLICK Then
	This.ctlVisible = FALSE
	Raiseevent(This, "ctlHide", -1)
Endif

If m.lnCode = TTN_POP Then
	This.ctlVisible = FALSE
	Raiseevent(This, "ctlHide", 3)
Endif

m.loNmhdr = .Null.

ENDPROC
PROCEDURE _setfont
*!* _SetFont()

*!*	typedef struct tagLOGFONT {
*!*	  LONG lfHeight;
*!*	  LONG lfWidth;
*!*	  LONG lfEscapement;
*!*	  LONG lfOrientation;
*!*	  LONG lfWeight;
*!*	  BYTE lfItalic;
*!*	  BYTE lfUnderline;
*!*	  BYTE lfStrikeOut;
*!*	  BYTE lfCharSet;
*!*	  BYTE lfOutPrecision;
*!*	  BYTE lfClipPrecision;
*!*	  BYTE lfQuality;
*!*	  BYTE lfPitchAndFamily;
*!*	  TCHAR lfFaceName[LF_FACESIZE];
*!*	} LOGFONT, *PLOGFONT;

*!*	    *!* Get default font for tooltips
*!*	    Local m.lcNonClientMetrics As String

*!*	    m.lcNonClientMetrics = This.oNonClientMetrics._Struct
*!*	    ?apiSystemParametersInfo(SPI_GETNONCLIENTMETRICS, Len(m.lcNonClientMetrics), @m.lcNonClientMetrics, 0)
*!*	    This.oNonClientMetrics._Struct = m.lcNonClientMetrics

*!*	    m.lcLogFont = This.oNonClientMetrics._lfStatusFontStruct


If This._SetFontEnable = FALSE Then
    Return
Endif

If This._ControlHwnd = 0 Then
    Return
Endif

This._SetFontEnable = FALSE

Local lcLogFont As String

*!* Set default values:
This.oLogFont.Value = This._DefaultLogFont

*!* Fill members of font structure:
With This.oLogFont
    .FontBold			= This.ctlFontBold
    .FontCharSet		= This.ctlFontCharSet
    .FontItalic 		= This.ctlFontItalic
    .FontName 			= This.ctlFontName
    .FontSize			= This.ctlFontSize
	.FontStrikethru 	= This.ctlFontStrikethru
	.FontUnderline 		= This.ctlFontUnderline
Endwith

m.lcLogFont = This.oLogFont.Value

*!* Release Font object if we already have one:
If This.oFont <> 0 Then
    apiDeleteObject(This.oFont)
Endif

*!* Create a new font object:
This.oFont = apiCreateFontIndirect(@m.lcLogFont)

*!* Set tooltip font to this font object:
apiSendMessage(This._ControlHwnd, WM_SETFONT, This.oFont, 1)

This._SetFontEnable = TRUE


ENDPROC
PROCEDURE _seticonandtitle
*!* _SetIconAndTitle()

If This._ControlHwnd = 0 Then
    Return
Endif

Local ;
    lnIcon As Integer, ;
    lcTitle As String

m.lnIcon = This.ctlIcon

*!* Check if a large icon is desired
If ctlGetOsVersion() >= NTDDI_VISTA And This.ctlIconLarge = TRUE Then
    If Between(m.lnIcon, 1, 3) Then
        m.lnIcon = m.lnIcon + 3
    Endif
Endif

m.lcTitle = Alltrim(Transform(This.ctlTitle))

If Empty(m.lcTitle) And (This.ctlIcon > 0 Or This.ctlCloseButton = TRUE) Then
    m.lcTitle = " "
Endif

m.lcTitle = m.lcTitle + Chr(0)

apiSendMessage(This._ControlHwnd, TTM_SETTITLEA, m.lnIcon, @m.lcTitle)

ENDPROC
PROCEDURE _setlocalestrings
*!* _SetLocaleStrings()

*!* 20061011 Added space at end in some strings to avoid compilation errors in DBCS Windows
*!* language strings extracted from comctl32.dll version 6 using String Extractor: http://www.zexersoft.com/products.html

Local lcLocaleInfo As Character, ;
    lcTitle As Character ;
    lcText As Character, ;
    lnLangID As Number, ;
    lnPrimaryLangID As Number, ;
    lnSubLangID As Number


If This.ctlLangID = 0x0 Then
    m.lnPrimaryLangID = ctlGetPrimaryLangID(LOCALE_USER_DEFAULT)
    m.lnSubLangID     = ctlGetSubLangID(LOCALE_USER_DEFAULT)
Else
    *!* If ctlLangID is <> 0 then it overrides the system locale language
    m.lnPrimaryLangID = ctlGetPrimaryLangIDFromLangID(This.ctlLangID)
	m.lnSubLangID = 	ctlGetSubLangIDFromLangID(This.ctlLangID)
Endif

Do Case
    Case m.lnPrimaryLangID = LANG_BASQUE	&& 0x2d
        m.lcTitle = "Blok Maius piztuta dago"
        m.lcText = "Blok Maius piztuta edukiz gero, zure pasahitza behar ez den bezala sar dezakezu.\r\n\r\nSakatu Blok Maius piztuta egon ez dadila zure pasahitza sartu baino lehen."

    Case m.lnPrimaryLangID = LANG_CATALAN	&& 0x03
        m.lcTitle = "La tecla Bloq Maj est activada"
        m.lcText = "Si teniu la tecla Bloq Maj activada, podreu introduir la contrasenya incorrectament.\r\n\r\nHaureu de prmer Bloq Maj per desactivar-la abans d'escriure la vostra contrasenya."

    Case m.lnPrimaryLangID = LANG_CHINESE And m.lnSubLangID = SUBLANG_CHINESE_TRADITIONAL && 0x04  0x01 Traditional Chinese for Taiwan and Hong Kong
        m.lcTitle = "jgwwҥ "
        m.lcText = "ҥΤjgwiవzKXJ~C\r\n\r\nzӫ@UjgwANAJzKXC "

    Case m.lnPrimaryLangID = LANG_CHINESE And m.lnSubLangID = SUBLANG_CHINESE_SIMPLIFIED && 0x04 0x02
        m.lcTitle = "д򿪡 "
        m.lcText = "ִд򿪿ܻʹ롣\r\n\r\nǰӦðCaps Lockرա "

    Case m.lnPrimaryLangID = LANG_CROATIAN And m.lnSubLangID = SUBLANG_CROATIAN_CROATIA		&& 0x1a 0x01
        m.lcTitle = "Caps Lock je ukljucen"
        m.lcText = "Ako je ukljucen Caps Lock moe se dogoditi da upiete krivu lozinku.\r\n\r\nTrebate pritisnuti Caps Lock kako biste ga iskljucili prije unosa lozinke."

    Case m.lnPrimaryLangID = LANG_CZECH		&& 0x05
        m.lcTitle = Trim("Reim Caps Lock je aktivn ")
        m.lcText = "Zapnut reimu Caps Lock mue zpusobit nesprvn zadn hesla.\r\n\r\nPred zadnm hesla vypnete reim Caps Lock stisknutm klvesy Caps Lock."

    Case m.lnPrimaryLangID = LANG_DANISH	&& 0x06
        m.lcTitle = "Caps Lock er slet til"
        m.lcText = "Hvis Caps Lock er slet til, kan det det medfre, at adgangskoden bliver skrevet forkert.\r\n\r\nDu br trykke p Caps Lock for at sl den fra, fr du skriver adgangskoden."

    Case m.lnPrimaryLangID = LANG_DUTCH		&& 0x13
        m.lcTitle = "De toets CapsLock staat aan"
        m.lcText = "Als de toets CapsLock is ingeschakeld, wordt het wachtwoord mogelijk onjuist ingevoerd.\r\n\r\nDruk op CapsLock alvorens het wachtwoord in te voeren."

    Case m.lnPrimaryLangID = LANG_ENGLISH	&& 0x09
        m.lcTitle = "Caps Lock is On"
        m.lcText = "Having Caps Lock on may cause you to enter your password incorrectly.\r\n\r\nYou should press Caps Lock to turn it off before entering your password."

    Case m.lnPrimaryLangID = LANG_ESTONIAN	&& 0x25
        m.lcTitle = "Suurthelukk on sisse llitatud"
        m.lcText = "Sissellitatud suurthelukk vib phjustada teie parooli vale sisestamise.\r\n\r\nEnne parooli sisestamist peaksite suurtheluku klahvi Caps Lock vajutamisega vlja llitama."

    Case m.lnPrimaryLangID = LANG_FINNISH	&& 0x0b
        m.lcTitle = Trim("Caps Lock on pll ")
        m.lcText = "Jos Caps Lock on pll salasanan isot ja pienet kirjaimet saattavat vaihtua.\r\n\r\nOta Caps Lock pois plt ennen salasanan kirjoittamista."

    Case m.lnPrimaryLangID = LANG_FRENCH	&& 0x0c
        m.lcTitle = "La touche Verr. Maj. est active"
        m.lcText = "La touche Verr. Maj. est enfonce, ce qui peut fausser la saisie de votre mot de passe.\r\n\r\nAppuyez sur Verr. Maj. pour la dsactiver, puis entrez votre mot de passe."

    Case m.lnPrimaryLangID = LANG_GALICIAN	&& 0x56
        m.lcTitle = "A tecla Bloq Mais est activada"
        m.lcText = "Coa tecla Bloq Mais activada  probbel que introduza o seu contrasinal de forma incorrecta.\r\n\r\nPrmaa para a desactivar antes de introducir o seu contrasinal."

    Case m.lnPrimaryLangID = LANG_GERMAN	&& 0x07
        m.lcTitle = "Feststelltaste ist aktiviert"
        m.lcText = "Das Kennwort wird eventuell falsch eingegeben, wenn die Feststelltaste aktiviert ist.\r\n\r\nSie sollten die Feststelltaste deaktivieren, bevor Sie ein Kennwort eingeben."

    Case m.lnPrimaryLangID = LANG_HUNGARIAN	&& 0x0e
        m.lcTitle = "A Caps Lock be van kapcsolva"
        m.lcText = "Ha be van kapcsolva a Caps Lock, elofordulhat, hogy hibsan adja meg a jelszt.\r\n\r\nA jelsz bersa elott rdemes kikapcsolnia a Caps Lock billentyu megnyomsval."

    Case m.lnPrimaryLangID = LANG_ICELANDIC	&& 0x0f
        m.lcTitle = "Stafals er virkur"
        m.lcText = "Ef stafals er virkur gti agangsor veri frt inn  rangan htt.\r\n\r\nStyja tti  stafals til a gera hann virkan ur en agangsori er frt inn."

    Case m.lnPrimaryLangID = LANG_INDONESIAN	&& 0x21
        m.lcTitle = "Caps Lock dalam posisi On"
        m.lcText = "Bila Caps Lock dalam posisi ON, ada kemungkinan Anda keliru memasukkan sandi.\r\n\r\nAnda harus menekan Caps Lock untuk mematikannya sebelum memasukkan sandi."

    Case m.lnPrimaryLangID = LANG_ITALIAN	&& 0x10
        m.lcTitle = "BLOC MAIUSC - Attivato"
        m.lcText = "Se il tasto BLOC MAIUSC  attivo pu accadere di digitare la password in modo errato.\r\n\r\nPremere il tasto BLOC MAIUSC per disattivarlo prima di digitare la password."

    Case m.lnPrimaryLangID = LANG_LATVIAN	&& 0x26
        m.lcTitle = "Ir ieslegts taustin Caps Lock"
        m.lcText = "Ja ir ieslegts taustin Caps Lock, parole, iespejams, tiks ievadita nepareizi.\r\n\r\nLai to izslegtu, pirms paroles ievadianas taustin Caps Lock janospie."

    Case m.lnPrimaryLangID = LANG_LITHUANIAN	&& 0x27
        m.lcTitle = "Ijungtas mygtukas Caps Lock"
        m.lcText = "Jei mygtukas Caps Lock yra ijungtas, del to galite neteisingai ivesti slaptaodi.\r\n\r\nPrie ivesdami slaptaodi spustelekite mygtuka Caps Lock, kad ji ijungtumete."

    Case m.lnPrimaryLangID = LANG_MALAY		&& 0x3e
        m.lcTitle = "Caps Lock Dipasang"
        m.lcText = "Penggunaan Caps Lock mungkin akan menyebabkan anda memasukkan kata laluan yang salah.\r\n\r\nAnda sepatutnya menekan Caps Lock untuk mematikannya sebelum memasukkan kata laluan."

    Case m.lnPrimaryLangID = LANG_NORWEGIAN		&& 0x14
        m.lcTitle = Trim("Caps Lock er p ")
        m.lcText = "Hvis Caps Lock er p, kan det fre til at passord skrives inn feil.\r\n\r\nPass p at Caps Lock er sltt av fr du skriver inn passordet."

    Case m.lnPrimaryLangID = LANG_POLISH	&& 0x15
        m.lcTitle = "Klawisz Caps Lock jest wlaczony"
        m.lcText = "Wpisywanie przy wlaczonym klawiszu Caps Lock moze spowodowac niepoprawne wprowadzenie hasla.\r\n\r\nPrzed wprowadzeniem hasla nacisnij klawisz Caps Lock, aby go wylaczyc."

    Case m.lnPrimaryLangID = LANG_PORTUGUESE And m.lnSubLangID = SUBLANG_PORTUGUESE_BRAZILIAN	&& 0x16 0x01
        m.lcTitle = "Caps Lock est ativada"
        m.lcText = "Se Caps Lock estiver ativado, isso pode fazer com que voc digite a senha incorretamente.\r\n\r\nVoc deve pressionar a tecla Caps Lock para desativ-la antes de digitar a senha."

    Case m.lnPrimaryLangID = LANG_PORTUGUESE And m.lnSubLangID = SUBLANG_PORTUGUESE_PORTUGAL	&& 0x16 0x02
        m.lcTitle = "Caps Lock est ligado"
        m.lcText = "Ter Caps Lock ligado pode fazer com que introduza incorrectamente a palavra-passe.\r\n\r\nDeve premir Caps Lock para desactivar antes de introduzir a sua palavra-passe."

    Case m.lnPrimaryLangID = LANG_ROMANIAN	&& 0x18
        m.lcTitle = "Tasta Caps Lock este activata"
        m.lcText = "Daca tasta Caps Lock este activata exista posibilitatea sa introduceti parola incorect.\r\n\r\nApasati tasta Caps Lock pentru a o dezactiva nainte de a introduce parola."

    Case m.lnPrimaryLangID = LANG_SERBIAN And m.lnSubLangID = SUBLANG_SERBIAN_LATIN		&& 0x1a 0x02
        m.lcTitle = "Taster Caps Lock je ukljucen"
        m.lcText = "Ako je ukljucen taster Caps Lock, moe se desiti da unesete pogrenu lozinku.\r\n\r\nTrebalo bi da pritisnete taster Caps Lock da biste ga iskljucili pre unoenja lozinke."

    Case m.lnPrimaryLangID = LANG_SLOVAK	&& 0x1b
        m.lcTitle = Trim("Klves Caps Lock je zapnut ")
        m.lcText = "Ak je zapnut klves Caps Lock, heslo me byt zadan nesprvne.\r\n\r\nPred zadanm hesla vypnite klves Caps Lock."

    Case m.lnPrimaryLangID = LANG_SLOVENIAN	&& 0x24
        m.lcTitle = "Tipka Caps Lock je vkljucena"
        m.lcText = "Ce je vkljucena tipka Caps Lock, se lahko zgodi, da boste nepravilno vnesli svoje geslo.\r\n\r\nPreden vnesete geslo, pritisnite tipko Caps Lock, da izklopite funkcijo."

    Case m.lnPrimaryLangID = LANG_SPANISH	&& 0x0a
        m.lcTitle = "Bloq Mays activado"
        m.lcText = "Si tiene activada la tecla Bloq Mays es posible que escriba incorrectamente su contrasea.\r\n\r\nPresione la tecla Bloq Mays para desactivarla antes de escribir su contrasea."

    Case m.lnPrimaryLangID = LANG_SWEDISH	&& 0x1d
        m.lcTitle = "Caps Lock r aktiverat"
        m.lcText = "Om Caps Lock r aktiverat kanske du skriver in ditt lsenord felaktigt.\r\n\r\nInaktivera Caps Lock innan du anger ditt lsenord."

    Case m.lnPrimaryLangID = LANG_TURKISH	&& 0x1f
        m.lcTitle = "Caps Lock Aik"
        m.lcText = "Aik Caps Lock parolanizi yanlis girmenize sebep olabilir.\r\n\r\nParolanizi girmeden nce  kapatmak iin Caps Lock tusuna basmalisiniz."

    Otherwise
        m.lcTitle = "Caps Lock is On"
        m.lcText = "Having Caps Lock on may cause you to enter your password incorrectly.\r\n\r\nYou should press Caps Lock to turn it off before entering your password."

Endcase

This._LangTitle = m.lcTitle
This._LangText  = Strtran(m.lcText, "\r\n", CRLF)



ENDPROC
PROCEDURE _setmargins
*!* _SetMargins()

If This._ControlHwnd = 0 Then
	Return
Endif

Local lcRect As String

With This.oRect
    .Top 		= This.ctlMarginTop
    .Left 		= This.ctlMarginLeft
    .Right 		= This.ctlMarginRight
    .Bottom 	= This.ctlMarginBottom
Endwith

m.lcRect = This.oRect.Value
apiSendMessage(This._ControlHwnd, TTM_SETMARGIN, 0, @m.lcRect)

ENDPROC
PROCEDURE _show
*!* _Show()

*!*	CON_BTPOS_NONE 							1
*!*	CON_BTPOS_LEFTTOP						1
*!*	CON_BTPOS_ACTIVECTRL 					2
*!*	CON_BTPOS_CARET							3
*!*	CON_BTPOS_SYS1270						4
*!*	CON_BTPOS_CTRLREF						5
*!*	CON_BTPOS_MOUSE							6

Lparameters m.tnPositionStyle As Integer

*!* If balloonTip is not active, dont show, just return
If This.ctlActive = FALSE Then
    Return
Endif

Local ;
    lbReturn As Boolean, ;
    lnPositionStyle As Integer, ;
    lnLeft As Integer, ;
    lnTop As Integer, ;
    lnWidth As Integer, ;
    lnHeight As Integer, ;
    loControl As Control, ;
    lcPoint As String, ;
    lnOffsetX As Integer, ;
    lnOffsetY As Integer, ;
    lnPosition As Integer

*!* lbReturn is set to TRUE when this procedure is called again
*!* with a different position style
m.lbReturn = FALSE

*!* If we have a parameter, this method has called itself with a
*!* different position style as a parameter

If Pcount() = 0 Then
    m.lnPositionStyle = This.ctlPositionStyle
Else
    m.lnPositionStyle = m.tnPositionStyle
Endif

*!* Now we check which positioning method we should use:

Do Case

    Case m.lnPositionStyle = CON_BTPOS_LEFTTOP && 1
        *!* This.ctlLeft and This.ctlTop should have been defined
        *!* by user before getting here.
        m.lnTop  = This.ctlTop
        m.lnLeft = This.ctlLeft

    Case m.lnPositionStyle = CON_BTPOS_ACTIVECTRL && 2
        If Type("Thisform.ActiveControl") = T_OBJECT Then
            m.loControl = Thisform.ActiveControl
        Else
            This._Show(CON_BTPOS_SYS1270)
            m.lbReturn = TRUE
        Endif

    Case m.lnPositionStyle = CON_BTPOS_CARET && 3
        *!* If object has selected text, just call this method again with CON_BTPOS_ACTIVECTRL

        *!* 20070608 added check for caret in control:
        If Type("Thisform.ActiveControl") = T_OBJECT ;
                And Pemstatus(Thisform.ActiveControl, "SelLength", CON_PEMSTAT_DEFINED) ;
                And Thisform.ActiveControl.SelLength = 0

            m.lcPoint = Space(8)
            *!* Get position of caret
            apiGetCaretPos(@m.lcPoint)
            *!* Save coordinates of caret
            m.lnLeft = ctlGetXFromPoint(m.lcPoint) + 5
            
            If This.ctlStyle = CON_BTSTYLE_BALLOON Then
                m.lnTop  = ctlGetYFromPoint(m.lcPoint) + 10
            Else
                m.lnTop  = ctlGetYFromPoint(m.lcPoint) + 20
            Endif
        Else
            This._Show(CON_BTPOS_ACTIVECTRL)
            m.lbReturn = TRUE
        Endif

    Case m.lnPositionStyle = CON_BTPOS_SYS1270 && 4

        *!* This control reference was saved in CtlVisible_Assign
        If Type("This.ctlControl") = T_OBJECT
            m.loControl = This.ctlControl
 
            If m.loControl.BaseClass = "Form" Then
                This._Show(CON_BTPOS_MOUSE)
                m.lbReturn = TRUE
            Endif
        Else
            This._Show(CON_BTPOS_MOUSE)
            m.lbReturn = TRUE
        Endif

    Case m.lnPositionStyle = CON_BTPOS_CTRLREF && 5
        If Type("This.ctlControl") = T_OBJECT
            m.loControl = This.ctlControl
        Else
            This._Show(CON_BTPOS_SYS1270)
            m.lbReturn = TRUE
        Endif

    Case m.lnPositionStyle >= CON_BTPOS_MOUSE && 6
        m.lcPoint = Space(8)
        *!* Get position of mouse cursor
        apiGetCursorPos(@m.lcPoint)
        *!* 20070603 Changed Thisform.hWnd to This._HosthWnd
        apiScreenToClient(This._HostHWnd, @m.lcPoint)
        m.lnLeft = ctlGetXFromPoint(m.lcPoint)
        m.lnTop  = ctlGetYFromPoint(m.lcPoint)

        *!* 20070612
    Otherwise
        This._Show(CON_BTPOS_MOUSE)
        m.lbReturn = TRUE
Endcase

*!* If _Show was called again with another position style, just return now:
If m.lbReturn = TRUE Then
    m.loControl = Null
    Return
Endif

*!* If the position style is active control, control under mouse, or control reference,
*!* we calculate position based on control position and size

Do Case

    Case m.lnPositionStyle = CON_BTPOS_LEFTTOP
        m.lnWidth 	= 0
        m.lnHeight 	= 0
        m.lnPosition = This.ctlAlignment

    Case m.lnPositionStyle = CON_BTPOS_CARET
        m.lnWidth 	= 0
        m.lnHeight 	= 0
        m.lnPosition = This.ctlAlignment

    Case m.lnPositionStyle = CON_BTPOS_MOUSE
        m.lnWidth 	= 16
        m.lnHeight 	= 16
        m.lnPosition = This.ctlAlignment

    Otherwise
        *!* Get position and size of control:
        m.lnLeft 	= Objtoclient(m.loControl, CON_OBJTOCLI_LEFT)
        m.lnTop 	= Objtoclient(m.loControl, CON_OBJTOCLI_TOP)
        m.lnWidth 	= Objtoclient(m.loControl, CON_OBJTOCLI_WIDTH)
        m.lnHeight 	= Objtoclient(m.loControl, CON_OBJTOCLI_HEIGHT)

        *!* Get offset dimensions from size of control:
        m.lnPosition = This.ctlPosition
Endcase

m.lnOffsetX = m.lnWidth  * This.ctlOffsetX - m.lnWidth
m.lnOffsetY = m.lnHeight * This.ctlOffsetY - m.lnHeight
*!* Check ctlPosition and adjust left and top:

*!*	*!* Alignment Values
*!*	CON_ALIGN_MIDDLELEFT		0
*!*	CON_ALIGN_MIDDLERIGHT		1
*!*	CON_ALIGN_MIDDLECENTER		2
*!*	CON_ALIGN_AUTOMATIC			3
*!*	CON_ALIGN_TOPLEFT			4
*!*	CON_ALIGN_TOPRIGHT			5
*!*	CON_ALIGN_TOPCENTER			6
*!*	CON_ALIGN_BOTTOMLEFT		7
*!*	CON_ALIGN_BOTTOMRIGHT		8
*!*	CON_ALIGN_BOTTOMCENTER		9

*!* Vertical:
Do Case

        *!* Middle (0,1,2):
    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLELEFT, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_MIDDLECENTER)
        m.lnTop  = m.lnTop + Int(m.lnHeight / 2)

        *!* Top (4,5,6):
    Case Inlist(m.lnPosition, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
        m.lnTop  = m.lnTop - m.lnOffsetY

        *!* Bottom (7,8,9):
    Case Inlist(m.lnPosition, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
        m.lnTop  = m.lnTop + m.lnHeight + m.lnOffsetY

    Otherwise
        *!* (3) Defaults to Bottom:
        m.lnTop  = m.lnTop + m.lnHeight + m.lnOffsetY

Endcase

*!* Horizontal:
Do Case

        *!* Left (0,4,7):
    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
        m.lnLeft = m.lnLeft - m.lnOffsetX

        *!* Right (1,5,8):
    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
        m.lnLeft = m.lnLeft + m.lnWidth + m.lnOffsetX

        *!* Center (2,6,9):
    Case Inlist(m.lnPosition, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
        m.lnLeft = m.lnLeft + Int(m.lnWidth / 2)

    Otherwise
        *!* (3) Defaults to Right:
        m.lnLeft = m.lnLeft + m.lnWidth + m.lnOffsetX

Endcase

*!* Now that we have our Left, Top coordinates, we continue

*!* Now we have two different methods, if the style is ballon, or if the style is
*!* rectangular tooltip.

*!* For balloon tips, we have to calculate the x,y values to where the tip will point.

If This.ctlStyle = CON_BTSTYLE_BALLOON Then

    This._ShowStyle1(m.lnPositionStyle, m.lnLeft, m.lnTop)

Else && This.ctlStyle = CON_STYLE_BALLOON

    This._ShowStyle2(m.lnPositionStyle, m.lnLeft, m.lnTop)
Endif

*!* Reset HIDE timer and enable it, so tooltip autohides.
*!* if tmrHide.Interval is 0 the tooltip will not autohide
If This.ctlHideDelay > 0 Then
    This.tmrHide.Reset()
    This.tmrHide.Enabled = TRUE
Endif


m.loControl = Null

ENDPROC
PROCEDURE _showstyle1
*!* _ShowStyle1()

*!* For Balloontips

*!* Check ctlAlignment

*!* As this is a balloon shaped tip, in the case of alignment I have not found a
*!* way to force the orientation of the balloon in respect to the tip.
*!* What we do is first create the balloontip in certain positions of the screen
*!* that we now will give us a balloon with the desired orientation, for example
*!* if we choose tip coordinates equal to thw width and height of the screen,
*!* we get a balloon with the tip in its lower right corner

Lparameters m.lnPositionStyle As Integer, m.lnLeft As Integer, m.lnTop As Integer

Local ;
    lcPoint As String, ;
    lnX As Integer, ;
    lnY As Integer, ;
    lnX2 As Integer, ;
    lnY2 As Integer, ;
    lbReposition As Boolean, ;
    lcToolInfo As String, ;
    lnParam As Integer, ;
    lcRect As String

*!* Convert form coordinates to screen coordinates:
m.lcPoint = ctlMakePoint(m.lnLeft, m.lnTop)

*!* 20070603 Changed Thisform.hWnd to This._HosthWnd
apiClientToScreen(This._HostHWnd, @m.lcPoint)
m.lnX = ctlGetXFromPoint(m.lcPoint)
m.lnY = ctlGetYFromPoint(m.lcPoint)

m.lbReposition = FALSE

*!* Vertical: (No middle alignment for balloon tips)

Do Case
*!*	    Case Inlist(m.lnPositionStyle, CON_BTPOS_CARET)
*!*	        m.lnY2 = m.lnY

        *!* Top :
    Case Inlist(This.ctlAlignment, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
        m.lnY2 = 8192
        m.lbReposition = TRUE

        *!* Bottom :
    Case Inlist(This.ctlAlignment, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
        m.lnY2 = m.lnY

    Otherwise
        *!* Defaults to Bottom:
        m.lnY2 = m.lnY
Endcase

*!* Horizontal:
Do Case
*!*	    Case Inlist(m.lnPositionStyle, CON_BTPOS_CARET)
*!*	        m.lnX2 = m.lnX

        *!* Left :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
        m.lnX2 = Sysmetric(1) - 32
        m.lbReposition = TRUE

        *!* Right :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
        m.lnX2 = m.lnX

        *!* Center : (TTF_CENTERTIP style set in _Create())
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
        m.lnX2 = m.lnX

    Otherwise
        *!* Defaults to Right:
        m.lnX2 = m.lnX
Endcase

**************************************************************************

*!* First position BallonTip in temp coordinates so ballontip gets created with
*!* the tip in the desired position:

m.lcToolInfo = This.oToolInfo.Value

*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
m.lnParam = ctlMakelParam(m.lnX2, m.lnY2)

*!* Set tooltip position
apiSendMessage(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)

*!* Activate tooltip so we can get size of window:
apiSendMessage(This._ControlHwnd, TTM_TRACKACTIVATE, 1, @m.lcToolInfo)
This._TrackActive = 1

*!* Do we have to reposition the balloon tip to its final position?
If m.lbReposition = TRUE Then
    *!* Get size of balloontip:

    m.lcRect = This.oRect.Value
    apiGetWindowRect(This.ctlHwnd, @m.lcRect)
    This.oRect.Value = m.lcRect

    *!* Check vertical position of tip
    If This.oRect.Top < m.lnY2 Then
        *!* Tip is on bottom
        m.lnY = m.lnY - This.oRect.Height
    Else
        *!* Tip is on top
        m.lnY = m.lnY
    Endif

    *!* Check horizontal position of tip
    If Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER) Then
        *!* Tip is centered
        m.lnX = m.lnX - Int(This.oRect.Width / 2)
    Else
        If This.oRect.Left < m.lnX2 - 16 Then
            *!* Tip is on right
            m.lnX = m.lnX - This.oRect.Width + 16
        Else
            *!* Tip is on left
            m.lnX = m.lnX - 16
        Endif
    Endif

    **! Reposition balloon tip
    apiSetWindowPos(This._ControlHwnd, ;
        0, ;
        m.lnX, ;
        m.lnY, ;
        0, ;
        0, ;
        Bitor(SWP_NOSIZE, SWP_NOZORDER, SWP_NOACTIVATE))
Endif

ENDPROC
PROCEDURE _showstyle2
*!* _ShowStyle2()

*!* For rectangular tooltips

Lparameters m.lnPositionStyle As Integer, m.lnLeft As Integer, m.lnTop As Integer


Local ;
    lcToolInfo As String, ;
    lnParam As Integer, ;
    lcRect As String, ;
    lnTipHeight As Integer, ;
    lnTipWidth As Integer

*!* We activate tooltip off screen to get tooltip size:

m.lcToolInfo = This.oToolInfo.Value

*!* Set Tooltip position way off screen
m.lnParam = ctlMakelParam(16000, 16000)

*!* Set tooltip position
apiSendMessage(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)

*!* Activate tooltip
apiSendMessage(This._ControlHwnd, TTM_TRACKACTIVATE, 1, @m.lcToolInfo)
This._TrackActive = 1

*!* Now Get size of balloontip:

m.lcRect = This.oRect.Value
apiGetWindowRect(This.ctlHwnd, @m.lcRect)

This.oRect.Value = m.lcRect

m.lnTipHeight = This.oRect.Height
m.lnTipWidth  = This.oRect.Width

**************************************************************************

*!* Check ctlAlignment:

*!* Vertical:
Do Case
        *!* Middle :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_MIDDLECENTER)
        m.lnTop  = m.lnTop - Ceiling(m.lnTipHeight / 2)

        *!* Top :
    Case Inlist(This.ctlAlignment, CON_ALIGN_TOPLEFT, CON_ALIGN_TOPRIGHT, CON_ALIGN_TOPCENTER)
        m.lnTop  = m.lnTop - m.lnTipHeight

        *!* Bottom :
    Case Inlist(This.ctlAlignment, CON_ALIGN_BOTTOMLEFT, CON_ALIGN_BOTTOMRIGHT, CON_ALIGN_BOTTOMCENTER)
        m.lnTop  = m.lnTop

    Otherwise
        m.lnTop  = m.lnTop
Endcase

*!* Horizontal:
Do Case
        *!* Left :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLELEFT, CON_ALIGN_TOPLEFT, CON_ALIGN_BOTTOMLEFT)
        m.lnLeft = m.lnLeft - m.lnTipWidth

        *!* Right :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLERIGHT, CON_ALIGN_TOPRIGHT, CON_ALIGN_BOTTOMRIGHT)
        m.lnLeft = m.lnLeft

        *!* Center :
    Case Inlist(This.ctlAlignment, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
        m.lnLeft = m.lnLeft - Int(m.lnTipWidth / 2)

    Otherwise
        m.lnLeft = m.lnLeft
Endcase

**************************************************************************

*!* Now we position the tip:

*!* Get lParam for TTM_TRACKPOSITION message
m.lnParam = This._GetTrackPosParam(m.lnLeft, m.lnTop)

*!* Set tooltip position, already activated off screen
apiSendMessage(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)

ENDPROC
PROCEDURE ctlactive_assign
Lparameters vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

This.ctlActive = m.vNewVal

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlCapsLockStyle And This.ctlActive And Capslock() Then
	This.ctlVisible = TRUE
Endif

*!* Hide if not Active
If This.ctlActive = FALSE Then
	This.ctlVisible = FALSE
Else
	apiSendMessage(This._ControlHwnd, TTM_ACTIVATE, 1, 0)
Endif


ENDPROC
PROCEDURE ctlalignment_assign
Lparameters m.vNewVal

Local ;
	lnAlignmentNew As Integer, ;
	lnAlignmentOld As Integer, ;
	lbRecreate As boolean

m.lbRecreate = FALSE

m.lnAlignmentOld = This.ctlAlignment
m.lnAlignmentNew = m.vNewVal

This.ctlAlignment = m.vNewVal

If This.ctlStyle = CON_BTSTYLE_BALLOON Then
	If Inlist(m.lnAlignmentOld, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
		If Not Inlist(m.lnAlignmentNew, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
			m.lbRecreate = TRUE
		Endif
	Else
		If Inlist(m.lnAlignmentNew, CON_ALIGN_MIDDLECENTER, CON_ALIGN_TOPCENTER, CON_ALIGN_BOTTOMCENTER)
			m.lbRecreate = TRUE
		Endif
	Endif
Endif

If m.lbRecreate = TRUE Then
	*!* Recreate BalloonTip
	This._Create()
Endif

ENDPROC
PROCEDURE ctlbackcolor_assign
*!* ctlBackColor_Assign

Lparameters m.vNewVal

If Type("m.vNewVal") <> T_NUMERIC Then
    m.vNewVal = -1
Endif

This.ctlBackColor = m.vNewVal

If This.ctlBackColor = -1 Then
    This.ctlBackColor = apiGetSysColor(COLOR_INFOBK)
Endif

If This._ControlHwnd = 0 Then
	Return
Endif

If This._ControlHwnd > 0 Then
    apiSendMessage(This._ControlHwnd, TTM_SETTIPBKCOLOR, This.ctlBackColor, 0)
Endif

ENDPROC
PROCEDURE ctlcapslockstyle_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

This.ctlCapsLockStyle = m.vNewVal

If This.ctlCapsLockStyle Then
	This.ctlVisible = FALSE
	*!* Set HideDelay
	This.ctlHideDelay = 5000

	*!* Set TipPositionStyle to CARET
	This.ctlPositionStyle = CON_BTPOS_CARET

	*!* Set Icon
	This.ctlIcon = TTI_WARNING

	*!* Set title and text
	This.ctlTitle = This._LangTitle
	This.ctlText = This._LangText
Else
	This.ctlVisible = FALSE
Endif

If This.ctlCapsLockStyle And This.ctlActive And Capslock() Then
	This.ctlVisible = TRUE
Endif

ENDPROC
PROCEDURE ctlclosebutton_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
ENDIF

This.ctlCloseButton = m.vNewVal

*!* Recreate BalloonTip
This._Create()


ENDPROC
PROCEDURE ctlfadein_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

This.ctlFadeIn = m.vNewVal

*!* Recreate BalloonTip
This._Create()


ENDPROC
PROCEDURE ctlfadeout_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

This.ctlFadeOut = m.vNewVal

ENDPROC
PROCEDURE ctlfontbold_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal >= FW_BOLD Then
		m.vNewVal = TRUE
	Else
		m.vNewVal = FALSE
	Endif
Endif

This.ctlFontBold = m.vNewVal

This._SetFont()

ENDPROC
PROCEDURE ctlfontcharset_assign
Lparameters m.vNewVal

This.ctlFontCharSet = m.vNewVal

This._SetFont()


ENDPROC
PROCEDURE ctlfontitalic_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

This.ctlFontItalic = m.vNewVal

This._SetFont()

ENDPROC
PROCEDURE ctlfontname_assign
Lparameters m.vNewVal

This.ctlFontName = m.vNewVal

This._SetFont()

ENDPROC
PROCEDURE ctlfontsize_assign
Lparameters m.vNewVal

This.ctlFontsize = m.vNewVal

This._SetFont()

ENDPROC
PROCEDURE ctlfontstrikethru_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
    If m.vNewVal = 0 Then
        m.vNewVal = FALSE
    Else
        m.vNewVal = TRUE
    Endif
Endif

This.ctlFontStrikethru = m.vNewVal

This._SetFont()

ENDPROC
PROCEDURE ctlfontunderline_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
    If m.vNewVal = 0 Then
        m.vNewVal = FALSE
    Else
        m.vNewVal = TRUE
    Endif
Endif

This.ctlFontUnderline = m.vNewVal

This._SetFont()


ENDPROC
PROCEDURE ctlforecolor_assign
*!* ctlForecolor_Assign

Lparameters m.vNewVal

If Type("m.vNewVal") <> T_NUMERIC Then
    m.vNewVal = -1
Endif

This.ctlForeColor = m.vNewVal

If m.vNewVal = -1 Then
    This.ctlForeColor = apiGetSysColor(COLOR_INFOTEXT)
Endif

If This._ControlHwnd = 0 Then
	Return
Endif

If This._ControlHwnd > 0 Then
    apiSendMessage(This._ControlHwnd, TTM_SETTIPTEXTCOLOR, This.ctlForeColor, 0)
Endif

ENDPROC
PROCEDURE ctlhide
*!* ctlHide()

Lparameters m.tnHideCode As Integer

Do Case
    Case m.tnHideCode = -1		&& Link CLICKED
        This.ctlOpenLink()

    Case m.tnHideCode = 0		&& Hide Delay timeout
    Case m.tnHideCode = 1		&& Click Inside BalloonTip
    Case m.tnHideCode = 2		&& Click Outside BalloonTip
    Case m.tnHideCode = 3		&& Click X Close Button
    Case m.tnHideCode = 4		&& Key Pressed
    Case m.tnHideCode = 5		&& CAPS LOCK key set to off
    Case m.tnHideCode = 6		&& Form moved, resized
        *!* 20070610 New Hide Code
    Case m.tnHideCode = 7		&& ctlVisible set to FALSE
Endcase

ENDPROC
PROCEDURE ctlhidedelay_assign
Lparameters m.vNewVal

If m.vNewVal < 0 Then
	m.vNewVal = 0
Endif

This.ctlHideDelay = m.vNewVal

This.tmrHide.Interval = m.vNewVal


ENDPROC
PROCEDURE ctlhwnd_access
Return This._ControlHwnd

ENDPROC
PROCEDURE ctlhwnd_assign
Lparameters m.vNewVal

Return


ENDPROC
PROCEDURE ctlicon_assign
*!* ctlIcon_Assign()

*!*	TTI_NONE								0
*!*	TTI_INFO								1
*!*	TTI_WARNING								2
*!*	TTI_ERROR								3
*!*	TTI_INFO_LARGE          				4		&& VISTA
*!*	TTI_WARNING_LARGE       				5		&& VISTA
*!*	TTI_ERROR_LARGE         				6		&& VISTA

Lparameters vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
    If m.vNewVal < 0 Then
        m.vNewVal = 0
    Endif
    *!*	    If m.vNewVal > 6 Then
    *!*	        m.vNewVal = 0
    *!*	    Endif
Endif

This.ctlIcon = m.vNewVal

This.oIcon = Null

If Type("This.ctlIcon") = T_CHARACTER Then
    If ctlGetOsVersion() >= NTDDI_WINXPSP2 Then	&& Custom icons only work in xp sp2 and up
        If File(This.ctlIcon) Then
            This.oIcon = Null
            This.oIcon = LoadPicture(This.ctlIcon)
            This.ctlIcon = This.oIcon.Handle
        Else
            This.ctlIcon = 0
        Endif
    Else
        This.ctlIcon = 0
    Endif
Endif

This._SetIconAndTitle()

ENDPROC
PROCEDURE ctliconlarge_assign
Lparameters m.vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

If This.ctlIconLarge <> m.vNewVal Then
	This.ctlIconLarge = m.vNewVal
	This._SetIconAndTitle()
Endif



ENDPROC
PROCEDURE ctllangid_assign
Lparameters m.vNewVal

This.ctllangid = m.vNewVal

This._SetLocaleStrings()

ENDPROC
PROCEDURE ctllink_access
*!* Store Link URL in ctlLinkURL
*!* Store Link Label in ctlLinkLabel
*!* Retrieve complete Link form ctlLink

Local lcLink

m.lcLink = ""

If ctlGetOsVersion() >= NTDDI_WINXP Then
	Do Case
		Case Not Empty(This.ctlLinkURL) And Not Empty(This.ctlLinkLabel)
			m.lcLink =[<A href="] + Alltrim(This.ctlLinkURL) + [">] + Alltrim(This.ctlLinkLabel) + "</A>"

		Case Not Empty(This.ctlLinkURL) And Empty(This.ctlLinkLabel)
			m.lcLink = "<A>" + Alltrim(This.ctlLinkLabel) + "</A>"

		Case Empty(This.ctlLinkURL) And Not Empty(This.ctlLinkLabel)
			m.lcLink =Alltrim(This.ctlLinkLabel)

	Endcase
Else
	m.lcLink = Alltrim(Alltrim(This.ctlLinkLabel) + " " + Alltrim(This.ctlLinkURL))
Endif

Return m.lcLink

ENDPROC
PROCEDURE ctlmakelink
Lparameters m.tcLinkLabel As String, m.tcLinkURL As String

This.ctlLinkLabel = m.tcLinkLabel
This.ctlLinkURL = m.tcLinkURL

Return This.ctlLink

ENDPROC
PROCEDURE ctlmargin_assign
*!* Sets the margin between the text and the borders of the balloon tip

Lparameters vNewVal

This.ctlMargin = m.vNewVal

With This
    .ctlMarginTop		= .ctlMargin
    .ctlMarginLeft		= .ctlMargin
    .ctlMarginRight		= .ctlMargin
    .ctlMarginBottom	= .ctlMargin
Endwith

ENDPROC
PROCEDURE ctlmarginbottom_assign
Lparameters vNewVal

This.ctlMarginBottom = m.vNewVal

This._SetMargins()

ENDPROC
PROCEDURE ctlmarginleft_assign
Lparameters vNewVal

This.ctlMarginLeft = m.vNewVal

This._SetMargins()
ENDPROC
PROCEDURE ctlmarginright_assign
Lparameters vNewVal

This.ctlMarginRight = m.vNewVal

This._SetMargins()
ENDPROC
PROCEDURE ctlmargintop_assign
Lparameters vNewVal

This.ctlMarginTop = m.vNewVal

This._SetMargins()
ENDPROC
PROCEDURE ctlmaxwidth_assign
Lparameters vNewVal

If m.vNewVal < 0 Then
	m.vNewVal = 0
Endif

This.ctlMaxWidth = m.vNewVal

If This._ControlHwnd = 0 Then
	Return
Endif

apiSendMessage(This._ControlHwnd, TTM_SETMAXTIPWIDTH , 0, This.ctlMaxWidth)

ENDPROC
PROCEDURE ctlopenlink
*!* ctlOpenLink

*!* 20071114 removed ["] + This.ctlLinkURL + ["]
*!* Always pass string variables to api functions and not object properties

Local lcLink As String

m.lcLink = This.ctlLinkURL

If Not Empty(m.lcLink) Then
	?apiShellExecute(0, 0, m.lcLink, 0, 0, SW_SHOWNORMAL)
Endif

ENDPROC
PROCEDURE ctlreset
If Pemstatus(This, "aProperties", 5) = FALSE Then
	Return
Endif

With This
	.ctlactive			=	.aProperties(01)
	.ctlalignment		=	.aProperties(02)
	.ctlbackcolor		=	.aProperties(03)
	.ctlcapslockstyle	=	.aProperties(04)
	.ctlclosebutton		=	.aProperties(05)
	.ctlcontrol			=	.aProperties(06)
	.ctlfadein			=	.aProperties(07)
	.ctlfadeout			=	.aProperties(08)
	.ctlfontbold		=	.aProperties(09)
	.ctlfontcharset		=	.aProperties(10)
	.ctlfontitalic		=	.aProperties(11)
	.ctlfontsize		=	.aProperties(12)
	.ctlfontstrikethru	=	.aProperties(13)
	.ctlfontunderline	=	.aProperties(14)
	.ctlforecolor		=	.aProperties(15)
	.ctlhidedelay		=	.aProperties(16)
	.ctlicon			=	.aProperties(17)
	.ctliconlarge		=	.aProperties(18)
	.ctllangid			=	.aProperties(19)
	.ctlleft			=	.aProperties(20)
	.ctllinklabel		=	.aProperties(21)
	.ctllinkurl			=	.aProperties(22)
	.ctlmargin			=	.aProperties(23)
	.ctlmarginbottom	=	.aProperties(24)
	.ctlmarginleft		=	.aProperties(25)
	.ctlmarginright		=	.aProperties(26)
	.ctlmargintop		=	.aProperties(27)
	.ctlmaxwidth		=	.aProperties(28)
	.ctloffsetx			=	.aProperties(29)
	.ctloffsety			=	.aProperties(30)
	.ctlposition		=	.aProperties(31)
	.ctlpositionstyle	=	.aProperties(32)
	.ctlshowdelay		=	.aProperties(33)
	.ctlstyle			=	.aProperties(34)
	.ctltext			=	.aProperties(35)
	.ctltitle			=	.aProperties(36)
	.ctltop				=	.aProperties(37)
	.ctlvisible			=	.aProperties(38)
Endwith



ENDPROC
PROCEDURE ctlsavestate
*!* ctlSaveState

If Pemstatus(This, "aProperties", 5) = FALSE Then
	This.AddProperty("aProperties[50]", FALSE)
Endif

With This
	.aProperties(01) =	.ctlactive
	.aProperties(02) =	.ctlalignment
	.aProperties(03) =	.ctlbackcolor
	.aProperties(04) =	.ctlcapslockstyle
	.aProperties(05) =	.ctlclosebutton
	.aProperties(06) =	.ctlcontrol
	.aProperties(07) =	.ctlfadein
	.aProperties(08) =	.ctlfadeout
	.aProperties(09) =	.ctlfontbold
	.aProperties(10) =	.ctlfontcharset
	.aProperties(11) =	.ctlfontitalic
	.aProperties(12) =	.ctlfontsize
	.aProperties(13) =	.ctlfontstrikethru
	.aProperties(14) =	.ctlfontunderline
	.aProperties(15) =	.ctlforecolor
	.aProperties(16) =	.ctlhidedelay
	.aProperties(17) =	.ctlicon
	.aProperties(18) =	.ctliconlarge
	.aProperties(19) =	.ctllangid
	.aProperties(20) =	.ctlleft
	.aProperties(21) =	.ctllinklabel
	.aProperties(22) =	.ctllinkurl
	.aProperties(23) =	.ctlmargin
	.aProperties(24) =	.ctlmarginbottom
	.aProperties(25) =	.ctlmarginleft
	.aProperties(26) =	.ctlmarginright
	.aProperties(27) =	.ctlmargintop
	.aProperties(28) =	.ctlmaxwidth
	.aProperties(29) =	.ctloffsetx
	.aProperties(30) =	.ctloffsety
	.aProperties(31) =	.ctlposition
	.aProperties(32) =	.ctlpositionstyle
	.aProperties(33) =	.ctlshowdelay
	.aProperties(34) =	.ctlstyle
	.aProperties(35) =	.ctltext
	.aProperties(36) =	.ctltitle
	.aProperties(37) =	.ctltop
	.aProperties(38) =	.ctlvisible
Endwith

ENDPROC
PROCEDURE ctlsetdefaultfont
This._SetFontEnable = FALSE

This.oLogFont.Value 	= This._DefaultLogFont
This.ctlFontBold 		= This.oLogFont.FontBold
This.ctlFontCharSet		= This.oLogFont.FontCharSet
This.ctlFontItalic 		= This.oLogFont.FontItalic
This.ctlFontName 		= This.oLogFont.FontName
This.ctlFontSize 		= This.oLogFont.FontSize
This.ctlFontStrikethru 	= This.oLogFont.FontStrikethru
This.ctlFontUnderline	= This.oLogFont.FontUnderline

This._SetFontEnable = TRUE

This._SetFont()

ENDPROC
PROCEDURE ctlshow
*!* ctlShow()

*!* Displays/hides tip
Lparameters ;
    m.tnPositionStyle As Integer, ;
    m.tcText As String , ;
    m.tcTitle As String, ;
    m.tuIcon As Variant

This.ctlVisible = FALSE

If Pcount() > 0 Then
    This.ctlPositionStyle = m.tnPositionStyle
Else
    m.tnPositionStyle = 0
Endif

If Pcount() > 1 Then
    This.ctlText = m.tcText
Endif

If Pcount() > 2 Then
    This.ctlTitle = m.tcTitle
Endif

If Pcount() > 3 Then
    This.ctlIcon = m.tuIcon
Endif

*!* If the first parameter is 0 then we hide tooltip

If m.tnPositionStyle = 0 Then
    This.ctlVisible = FALSE
else
    This.ctlVisible = TRUE
Endif


ENDPROC
PROCEDURE ctlshowdelay_assign
Lparameters vNewVal

If m.vNewVal < 200 Then
    m.vNewVal = 200
Endif

This.ctlShowDelay = m.vNewVal

This.tmrShow.Interval = m.vNewVal

ENDPROC
PROCEDURE ctlstyle_assign
*!*	#Define CON_BTSTYLE_BALLOON					1
*!*	#Define CON_BTSTYLE_RECT					2
*!*	#Define CON_BTSTYLE_NOBORDER				3

Lparameters vNewVal

If This.ctlStyle <> m.vNewVal Then

    If m.vNewVal > 3 Then
        m.vNewVal = CON_BTSTYLE_BALLOON
    Endif

    If m.vNewVal < 1 Then
        m.vNewVal = CON_BTSTYLE_BALLOON
    Endif

    This.ctlStyle = m.vNewVal
Else
    Return
Endif

This._Create()





ENDPROC
PROCEDURE ctltext_assign
Lparameters m.vNewVal

Local lcText As String

This.ctlText = m.vNewVal
m.lcText = m.vNewVal

If This._ControlHwnd = 0 Then
	Return
Endif

Local lcToolInfo, lcText

*!* Replace TABS with four spaces:
m.lcText = Strtran(m.lcText, Chr(9), Space(4))

*!* Add one space at end of each line if font is italic to prevent clipping
If This.ctlFontItalic = TRUE Then
	m.lcText = Strtran(m.lcText, CRLF, " " + CRLF)
	m.lcText = m.lcText + " "
Endif

*!* Add terminating nul
If Right(m.lcText, 1) <> NULCHAR Then
	m.lcText = m.lcText + NULCHAR
Endif

This.oToolInfo.lpszText = m.lcText
m.lcToolInfo = This.oToolInfo.Value

apiSendMessage(This._ControlHwnd, TTM_UPDATETIPTEXTA, 0, @m.lcToolInfo)

ENDPROC
PROCEDURE ctltitle_assign
Lparameters vNewVal

This.ctlTitle = m.vNewVal

If This._ControlHwnd = 0 Then
	Return
Endif

This._SetIconAndTitle()



ENDPROC
PROCEDURE ctltrack
*!* ctlTrack()

Lparameters m.tcText

Local ;
    lcPoint As String, ;
    lnLeft As Integer, ;
    lnWidth As Integer, ;
    lnHeight As Integer, ;
    lnOffsetX As Integer, ;
    lnOffsetY As Integer, ;
    lnTop As Integer, ;
    lnParam As Integer, ;
	lcToolInfo as String

*!* If balloonTip is not active, dont show, just return
If This.ctlActive = FALSE Then
    Return
Endif

If This._ControlHwnd = 0 Then
    Return
Endif

If Pcount() > 0 And Vartype(m.tcText) = T_CHARACTER Then

    *!* 20070714 Check to see if text changed
    If Not This.ctlText == m.tcText Then
        This.ctlText = m.tcText
    Endif
Endif

*!* ctlTrack ignores ctlPosition and ctlAlignment

m.lcPoint = Space(8)
*!* Get position of mouse cursor
apiGetCursorPos(@m.lcPoint)

m.lnLeft = ctlGetXFromPoint(m.lcPoint)
m.lnTop =  ctlGetYFromPoint(m.lcPoint)

m.lnWidth 	= 16
m.lnHeight 	= 16

m.lnOffsetX = m.lnWidth  * This.ctlOffsetX - m.lnWidth
m.lnOffsetY = m.lnHeight * This.ctlOffsetY - m.lnHeight

m.lnTop  = Int(m.lnTop + m.lnHeight + m.lnOffsetY)
m.lnLeft = Int(m.lnLeft + m.lnWidth + m.lnOffsetX)

*!* Make DWORD for TTM_TRACKPOSITION message (MAKELPARAM)
m.lnParam = ctlMakelParam(m.lnLeft, m.lnTop)

*!* Set tooltip position
*!* 20070714 Check to see if m.lnParam (TrackPosition) changed
If This._OldTrackPosition <> m.lnParam Then
    apiSendMessage(This._ControlHwnd, TTM_TRACKPOSITION, 0, m.lnParam)
    This._OldTrackPosition = m.lnParam
Endif

If This._TrackActive = 0 Then

    m.lcToolInfo = This.oToolInfo.Value

    *!* Activate tooltip:
    apiSendMessage(This._ControlHwnd, TTM_TRACKACTIVATE, 1, @m.lcToolInfo)
    This._TrackActive = 1

Endif



ENDPROC
PROCEDURE ctlvisible_assign
Lparameters vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
    If m.vNewVal = 0 Then
        m.vNewVal = FALSE
    Else
        m.vNewVal = TRUE
    Endif
Endif

This.ctlVisible = m.vNewVal

If This._ControlHwnd = 0 Then
    Return
Endif

Local lcToolInfo As Character

If This.ctlVisible Then
    *!* We have a timer call This._Show() to overcome the
    *!* bug of setting the balloon Visible in an object getfocus,
    *!* the cursor (caret) is still in the previous control.

    *!* If ctlPositionStyle = CON_BTPOS_SYS1270, save object reference now,
    *!* This is done in case user moves mouse away from control.
    If This.ctlPositionStyle = CON_BTPOS_SYS1270 Then
        This.ctlControl = Sys(1270)
    Endif

    This.tmrShow.Enabled = TRUE
    *!* This timer just calls _Show()
Else
    This.tmrShow.Enabled = FALSE
    *!* Here we hide balloontip:
    If This.ctlFadeOut = FALSE Then
        *!* We first hide the tooltip window to prevent fade out effect, TTF_NOFADE seems to
        *!* have no effect on fade out, only on fade in
        apiShowWindow(This._ControlHwnd, SW_HIDE)
    Endif

    m.lcToolInfo = This.oToolInfo.Value
    apiSendMessage(This._ControlHwnd, TTM_TRACKACTIVATE, 0, @m.lcToolInfo)
    This._TrackActive = 0

    This.tmrHide.Enabled = FALSE
Endif

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_addproperties 
*_bindevents 
*_create 
*_eventhandlerformmoved 
*_eventhandlerformresize 
*_eventhandlerscreenmoved 
*_getfontdefault 
*_gettrackposparam 
*_messagehandlerformwm_keydown 
*_messagehandlerhostwm_lbuttondown 
*_messagehandlerhostwm_notify 
*_propertyhandlerformwmnotifymsg 
*_setfont 
*_seticonandtitle 
*_setlocalestrings 
*_setmargins 
*_show 
*_showstyle1 
*_showstyle2 
*ctlactive_assign 
*ctlalignment_assign 
*ctlbackcolor_assign 
*ctlcapslockstyle_assign 
*ctlclosebutton_assign 
*ctlfadein_assign 
*ctlfadeout_assign 
*ctlfontbold_assign 
*ctlfontcharset_assign 
*ctlfontitalic_assign 
*ctlfontname_assign 
*ctlfontsize_assign 
*ctlfontstrikethru_assign 
*ctlfontunderline_assign 
*ctlforecolor_assign 
*ctlhide 
*ctlhidedelay_assign 
*ctlhwnd_access 
*ctlhwnd_assign 
*ctlicon_assign 
*ctliconlarge_assign 
*ctllangid_assign 
*ctllink_access 
*ctlmakelink 
*ctlmargin_assign 
*ctlmarginbottom_assign 
*ctlmarginleft_assign 
*ctlmarginright_assign 
*ctlmargintop_assign 
*ctlmaxwidth_assign 
*ctlopenlink 
*ctlreset 
*ctlsavestate 
*ctlsetdefaultfont 
*ctlshow 
*ctlshowdelay_assign 
*ctlstyle_assign 
*ctltext_assign 
*ctltitle_assign 
*ctltrack 
*ctlvisible_assign 
_memberdata XML Metadata for customizable properties
ctlabout
ctlactive
ctlalignment
ctlbackcolor
ctlcapslockstyle
ctlclosebutton
ctlcontrol
ctlfadein
ctlfadeout
ctlfontbold
ctlfontcharset
ctlfontitalic
ctlfontname
ctlfontsize
ctlfontstrikethru
ctlfontunderline
ctlforecolor
ctlhidedelay
ctlhwnd Specifies the Window handle of the Window.
ctlicon
ctliconlarge
ctllangid
ctlleft
ctllink
ctllinklabel
ctllinkurl
ctlmargin Sets the top, left, bottom, and right margins for a ToolTip window. A margin is the distance, in pixels, between the ToolTip window border and the text contained within the ToolTip window. 
ctlmarginbottom
ctlmarginleft
ctlmarginright
ctlmargintop
ctlmaxwidth Sets the maximum width for a ToolTip window.
ctloffsetx
ctloffsety
ctlposition
ctlpositionstyle
ctlshowdelay
ctlstyle 1 = Balloon; 2 = Rectangular; 3 = Rectangular with no borders
ctltext
ctltitle
ctltop
ctlversion
ctlvisible
[END RESERVED3]
[START RESERVED4]
ctl32_balloontip.bmp[END RESERVED4]
[START RESERVED5]
ctl32_balloontip.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1WA0QFR6J
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_balloontip
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_balloontip"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 3
Width = 77
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1W71AGSLJ
[CLASS] timer
[BASECLASS] timer
[OBJNAME] tmrHide
[PARENT] ctl32_balloontip
[START PROPERTIES]
Enabled = .F.
Height = 23
Interval = 0
Left = 120
Name = "tmrHide"
Top = 0
Width = 23
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
If This.Parent.ctlVisible = TRUE Then
    This.Parent.ctlVisible = FALSE
    Raiseevent(This.Parent, "ctlHide", 0)
Endif

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _22I1EZZAS
[CLASS] timer
[BASECLASS] timer
[OBJNAME] tmrShow
[PARENT] ctl32_balloontip
[START PROPERTIES]
Enabled = .F.
Height = 23
Interval = 200
Left = 192
Name = "tmrShow"
Top = 24
Width = 23
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
*!* Disable this timer
This.Enabled = FALSE
This.Parent._Show()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_balloontip

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1VI17OWL7
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_color
[START PROPERTIES]
Height = 38
Name = "ctl32_color"
Width = 36
blue = 0
green = 0
hue = 0
lum = 0
red = 0
sat = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
*!* Init
External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

ENDPROC
PROCEDURE colorgetl
Lparameters tnColor
Local lnLum As Integer
m.lnLum = -1

If Between(m.tnColor, 0, Rgb(255,255,255)) Then
	This.Int2HSL(m.tnColor)
	m.lnLum = This.Lum
Endif
Return m.lnLum




ENDPROC
PROCEDURE colorsetl
*!* ColorSetL

Lparameters tnColor, tnLum

If Between(m.tnColor, 0, Rgb(255,255,255)) Then
	If Between(m.tnLum, 0, 1000) Then

		This.Int2HSL(m.tnColor)
		This.Lum = m.tnLum
		This.HSL2RGB()
		m.tnColor = Rgb(This.red, This.green, This.blue)
	Endif
Endif

Return m.tnColor

ENDPROC
PROCEDURE hsl2rgb
LOCAL lnHue, lnSat, lnLum

lnHue = This.Hue / 360
lnSat = This.Sat / 1000
lnLum = This.Lum / 1000

If  lnSat  = 0
	This.Red = lnLum * 255
	This.Green = lnLum * 255
	This.Blue = lnLum * 255

Else

	If lnLum < 0.5 Then
		var_2 = lnLum * ( 1 + lnSat )
	Else
		var_2 = ( lnLum + lnSat ) - ( lnSat * lnLum )
	Endif

	var_1 = 2 * lnLum - var_2

	This.Red =   255 * This.Hue2RGB( var_1, var_2, lnHue + ( 1 / 3 ) )
	This.Green = 255 * This.Hue2RGB( var_1, var_2, lnHue )
	This.Blue =  255 * This.Hue2RGB( var_1, var_2, lnHue - ( 1 / 3 ) )
Endif

ENDPROC
PROCEDURE hue2rgb
Lparameters v1, v2, vH

If ( vH < 0 )
	vH = vH + 1
Endif

If ( vH > 1 )
	vH = vH - 1
Endif

If ( ( 6 * vH ) < 1 )
	Return ( v1 + ( v2 - v1 ) * 6 * vH )
Endif

If ( ( 2 * vH ) < 1 )
	Return ( v2 )
Endif

If ( ( 3 * vH ) < 2 )
	Return ( v1 + ( v2 - v1 ) * ( ( 2 / 3 ) - vH ) * 6 )
Endif

Return ( v1 )


ENDPROC
PROCEDURE int2hsl
Lparameters tnColor
This.int2rgb(m.tnColor)
This.rgb2hsl()
Return

ENDPROC
PROCEDURE int2rgb
Lparameters tnColor

With This
	.Red = Bitand(tnColor, 0xFF)
	.Green = Bitand(Bitrshift(tnColor, 8), 0xFF)
	.Blue = Bitand(Bitrshift(tnColor, 16), 0xFF)
Endwith

ENDPROC
PROCEDURE rgb2hsl
var_R = ( This.Red / 255 )
var_G = ( This.Green / 255 )
var_B = ( This.Blue / 255 )

var_Min = Min( var_R, var_G, var_B )
var_Max = Max( var_R, var_G, var_B )
del_Max = var_Max - var_Min

This.Lum = ( var_Max + var_Min ) / 2

If del_Max = 0
	This.Hue = 0
	This.Sat = 0
Else
	If This.Lum < 0.5
		This.Sat = del_Max / ( var_Max + var_Min )
	Else
		This.Sat = del_Max / ( 2 - var_Max - var_Min )
	Endif

	del_R = ( ( ( var_Max - var_R ) / 6 ) + ( del_Max / 2 ) ) / del_Max
	del_G = ( ( ( var_Max - var_G ) / 6 ) + ( del_Max / 2 ) ) / del_Max
	del_B = ( ( ( var_Max - var_B ) / 6 ) + ( del_Max / 2 ) ) / del_Max

	Do Case
		Case var_R = var_Max
			This.Hue = del_B - del_G
		Case var_G = var_Max
			This.Hue = ( 1 / 3 ) + del_R - del_B
		Case var_B = var_Max
			This.Hue = ( 2 / 3 ) + del_G - del_R
	Endcase

	If ( This.Hue < 0 )
		This.Hue = This.Hue + 1
	Endif

	If ( This.Hue > 1 )
		This.Hue = This.Hue - 1
	Endif
Endif

This.Hue = This.Hue * 360
This.Sat = This.Sat * 1000
This.Lum = This.Lum * 1000

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*colorgetl Returns the luminance value of a color specified as an integer
*colorsetl Sets the luminance value of a color specified as an integer
*hsl2rgb HSL TO RGB
*hue2rgb 
*int2hsl 
*int2rgb INTEGER TO RGB
*rgb2hsl RGB TO HSL
_memberdata XML Metadata for customizable properties
blue BLUE
green GREEN
hue HUE
lum LUMINANCE
red RED
sat SATURATION
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_color

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2760A2O9L
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_contextmenu
[START PROPERTIES]
BackColor = 140,200,200
Height = 21
Name = "ctl32_contextmenu"
Visible = .F.
Width = 108
_bitmapcanvasheight = 0
_bitmapcanvaswidth = 0
_bitmapheight = 0
_bitmapwidth = 0
_brush = 0
_controlmenubuilt = .F.
_drawitemstruct = .F.
_editmenubuilt = .F.
_lookuptable = .F.
_mainhandle = 0
_measureitemstruct = .F.
_nextmenuitemid = 0
_windowprocedure = 0
formhwnd = .F.
menuitems = 
menus = 
parenthwnd = 0
showflags = 0
[END PROPERTIES]
[START PROTECTED]
onwmdrawitem^
onwmmeasureitem^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*!* Destroy

This.Clear()



ENDPROC
PROCEDURE Init
*!* Init

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

This.MenuItems = Createobject("Collection")
This.Menus     = Createobject("Collection")
*This.MenuKeys  = Createobject("Collection")

This._DrawItemStruct    = Createobject("ctlDrawItemStruct", 0)
This._MeasureItemStruct = Createobject("ctlMeasureItemStruct", 0)

This._NextMenuItemId = 1

ENDPROC
PROCEDURE _addmenu
*!* _AddMenu(ItemKey)

*!* This method is used to add menus, menu pop-ups and submenus
*!* When adding the first menu, the MenuKey must be the owner form Hwnd

Lparameters m.peItemKey

Local lcItemKey As String

*!* Transform has issues
If Vartype(m.peItemKey) = "N" Then
	m.lcItemKey = Alltrim(Str(m.peItemKey))
Else
	m.lcItemKey = m.peItemKey
Endif

If This.Menus.Count = 0 Then
	This.FormHwnd = _Screen.ActiveForm.HWnd
	This._BindEvents()
Endif

This.Menus.Add(Createobject("ctl32_menu"), m.lcItemKey)

This.Menus(m.lcItemKey).MenuID = apiCreatePopupMenu()

Local ;
	lcMenuInfo As String, ;
	loMenuInfo As ctlMenuInfo

m.loMenuInfo = Createobject("ctlMenuInfo")

m.loMenuInfo.fMask = Bitor(MIM_BACKGROUND, MIM_MAXHEIGHT, MIM_STYLE, MIM_MENUDATA)
m.loMenuInfo.dwStyle = Bitor(MNS_AUTODISMISS, MNS_CHECKORBMP)
m.loMenuInfo.cyMax = This.Menus(m.lcItemKey).Height
m.loMenuInfo.hbrBack = 0
m.loMenuInfo.dwContextHelpID = 0
m.loMenuInfo.dwMenuData = 0

m.lcMenuInfo = m.loMenuInfo.Value
apiSetMenuInfo(This.Menus(m.lcItemKey).MenuID, @m.lcMenuInfo)

Return This.Menus(m.lcItemKey).MenuID

ENDPROC
PROCEDURE _addmenuitem
*!* _AddMenuItem

Lparameters m.peItemKey1, m.peItemKey2, m.pcCaption As String, m.pePicture

Local ;
	lcItemKey1 As String, ;
	lcItemKey2 As String, ;
	loMenuItem As ctl32_menuitem

If Vartype(m.peItemKey1) = "N" Then
	m.lcItemKey1 = Alltrim(Str(m.peItemKey1))
Else
	m.lcItemKey1 = m.peItemKey1
Endif

If Vartype(m.peItemKey2) = "N" Then
	m.lcItemKey2 = Alltrim(Str(m.peItemKey2))
Else
	m.lcItemKey2 = m.peItemKey2
Endif

*!* Check if this menuitem has a parent menu:
If Empty(This.Menus.GetKey(m.lcItemKey1))
	If Empty(This.MenuItems.GetKey(m.lcItemKey1))
		*!* There is no parent with the passed m.lcItemKey1
		Return
	Else
		*!* Create a menu for the parent menuitem if needed
		If This.MenuItems(m.lcItemKey1).SubMenuId = 0 Then
			This.MenuItems(m.lcItemKey1).SubMenuId = This._AddMenu(m.lcItemKey1)
		Endif
	Endif
Endif

*!* Add menu item object to MenuItems collection
This.MenuItems.Add(Createobject("ctl32_menuitem"), m.peItemKey2)

*!* Assign values to all the menu item properties:
m.loMenuItem =  This.MenuItems(m.peItemKey2)

m.loMenuItem.Caption = m.pcCaption

*!* ID of the menu that contains this menu item
m.loMenuItem.MenuId = This.Menus(m.lcItemKey1).MenuId

m.loMenuItem.ItemId = This._NextMenuItemId
This._NextMenuItemId = This._NextMenuItemId + 1

*!* Proceed with API:

Local ;
	lcMenuItemInfo As String,;
	loMenuItemInfo As ctlMenuItemInfo

********************************************************************************
*!*	typedef struct tagMENUITEMINFO {
*!*	  UINT    cbSize;
*!*	  UINT    fMask;
*!*	  UINT    fType;
*!*	  UINT    fState;
*!*	  UINT    wID;
*!*	  HMENU   hSubMenu;
*!*	  HBITMAP hbmpChecked;
*!*	  HBITMAP hbmpUnchecked;
*!*	  ULONG_PTR dwItemData;
*!*	  LPTSTR  dwTypeData;
*!*	  UINT    cch;
*!*	  HBITMAP hbmpItem;
*!*	} MENUITEMINFO, *LPMENUITEMINFO;
********************************************************************************

m.loMenuItemInfo = Createobject("ctlMenuItemInfo")

*!*	*!* cbSize: Size of structure, in bytes.
*!*	m.loMenuItemInfo.cbSize = 12*4

*!* fMask: Members to retrieve or set
m.loMenuItemInfo.fMask = Bitor(MIIM_FTYPE, MIIM_ID, MIIM_STRING, MIIM_DATA)

m.loMenuItemInfo.fType = MFT_STRING

If m.loMenuItem.Caption = "-" Then
	m.loMenuItemInfo.fType = Bitor(m.loMenuItemInfo.fType, MF_SEPARATOR)
Endif

If ctlGetOsVersion() < NTDDI_VISTA
	m.loMenuItemInfo.fMask = Bitor(m.loMenuItemInfo.fMask, MIIM_BITMAP)
	m.loMenuItemInfo.hbmpItem = HBMMENU_CALLBACK
Else
	m.loMenuItemInfo.hbmpItem = 0
Endif

m.loMenuItemInfo.fState = 0

*!* wID: Application-defined 16-bit value that identifies the menu item.
*!* Set fMask to MIIM_ID to use wID.
m.loMenuItemInfo.wID = m.loMenuItem.ItemId

m.loMenuItemInfo.hSubMenu = 0
m.loMenuItemInfo.hbmpChecked = 0
m.loMenuItemInfo.hbmpUnchecked = 0

*!* dwItemData: Application-defined value associated with the menu item.
*!* Set fMask to MIIM_DATA to use dwItemData.
m.loMenuItemInfo.dwItemData = 0

*!* Pointer to Text string
Local lcCaption As String

m.lcCaption = Strtran(m.loMenuItem.Caption, "\t", TABCHAR)
m.lcCaption = Strtran(m.lcCaption, "\<", "&")
m.loMenuItemInfo.dwTypeData =  m.lcCaption  + NULA

*!* cch: Length of the menu item text, in TCHARs, when information is received
*!* about a menu item of the MFT_STRING type. Ignored when the content of a menu
*!* item is set by calling SetMenuItemInfo.

m.loMenuItemInfo.cch = Len(m.loMenuItemInfo.dwTypeData)

*!* Structure members have been set, now create structure string:

m.lcMenuItemInfo = m.loMenuItemInfo.Value

*!* Count number of menu items of menu, to insert new menu item at the end
apiInsertMenuItem( ;
	m.loMenuItem.MenuId, ;
	apiGetMenuItemCount(m.loMenuItem.MenuId), ;
	MF_BYPOSITION, ;
	@m.lcMenuItemInfo)

m.loMenuItem.Picture = m.pePicture

m.loMenuItem = .Null.
m.loMenuItemInfo = .Null.



Return


*!*	*!* fType: Menu item type: MFT_RADIOCHECK MFT_SEPARATOR MFT_STRING ...;
*!*	*!* Set fMask to MIIM_TYPE to use fType.

*!*	If m.loMenuItem.RadioCheck = TRUE Then
*!*		m.loMenuItemInfo.fType = Bitor(m.loMenuItemInfo.fType, MFT_RADIOCHECK)
*!*	Endif

*!*	*!* fState: Menu item state... MFS_CHECKED MFS_DEFAULT MFS_GRAYED ...
*!*	*!* Set fMask to MIIM_STATE to use fState


*!*	If m.loMenuItem.Checked = TRUE Then
*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_CHECKED)
*!*	Endif

*!*	If m.loMenuItem.DefaultItem = TRUE Then
*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_DEFAULT)
*!*	Endif

*!*	If m.loMenuItem.Enabled = FALSE Then
*!*		m.loMenuItemInfo.fState = Bitor(m.loMenuItemInfo.fState, MFS_GRAYED)
*!*	Endif



*!* hbmpChecked: Handle to the bitmap to display next to the item if it is selected.
*!* If this member is NULL, a default bitmap is used.
*!* If the MFT_RADIOCHECK type value is specified, the default bitmap is a bullet.
*!"* Otherwise, it is a check mark.
*!* Set fMask to MIIM_CHECKMARKS to use hbmpChecked.

*!* 20080324

*!* hbmpUnchecked: Handle to the bitmap to display next to the item if it is not selected.
*!* If this member is NULL, no bitmap is used.
*!* Set fMask to MIIM_CHECKMARKS to use hbmpUnchecked.

*!* 20080324



*!* Reset structure
*!*m.loMenuItemInfo = Createobject("ctlMenuItemInfo")

*!* Set callback so we process wm_measureitem and can fix the menu item height
If ctlGetOsVersion() < NTDDI_VISTA
	m.loMenuItemInfo.fMask = MIIM_BITMAP
	m.loMenuItemInfo.hbmpItem = HBMMENU_CALLBACK
	m.lcMenuItemInfo = m.loMenuItemInfo.Value
	apiSetMenuItemInfo(m.loMenuItem.MenuId, m.loMenuItem.ItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)
Else
	*!* should create and add a blank transparent bitmap in Vista
	*!* of m.loMenuItem.PictureHeight width and height and then assign it:
	*!* m.loMenuItem.PictureId = m.loMenuItem.PictureObject.GetHBitmap(m.loColor)
	*!* This._SetMenuItemInfo_hbmpItem(m.loMenuItem.MenuId, m.loMenuItem.ItemId, m.loMenuItem.PictureId)
Endif

m.loMenuItem.Picture = m.puPicture





ENDPROC
PROCEDURE _addmenuitemtocollection
*!* _AddMenuItemToCollection

Lparameters ;
	m.pcMenuKey, ;
	m.pItemKey, ;
	m.pnType, ;
	m.pcCaption, ;
	m.puPicture, ;
	m.plChecked, ;
	m.plRadioCheck, ;
	m.plDisabled, ;
	m.plDefaultItem, ;
	m.pcStatusBarText

Local loMenuItem as ctl32_menuitem

*!* Add menu item object to MenuItems collection
This.MenuItems.Add(Createobject("ctl32_menuitem"), m.pItemKey)

*!* Assign values to all the menu item properties:
m.loMenuItem =  This.MenuItems(m.pItemKey)

m.loMenuItem.Caption = m.pcCaption
m.loMenuItem.DefaultItem = m.plDefaultItem
m.loMenuItem.Enabled = Not m.plDisabled

*!* ID of the menu that contains this menu item
m.loMenuItem.MenuId = This.Menus(m.pcMenuKey).MenuId

m.loMenuItem.Shortcut = ""
m.loMenuItem.Checked = m.plChecked
m.loMenuItem.RadioCheck = m.plRadioCheck
m.loMenuItem.MenuPKey = m.pcMenuKey

*!* if puPicture is numeric, it represents a picture handle

m.loMenuItem.Picture = ""

If Vartype(m.puPicture) = "N" Then
	m.loMenuItem.Picture =  ""
	m.loMenuItem.PictureId = m.puPicture
Endif

If Vartype(m.puPicture) = "C" And File(m.puPicture) Then
	m.loMenuItem.Picture = m.puPicture
Endif

m.loMenuItem.ItemKey = m.pItemKey

*!* ItemId is a random value
m.loMenuItem.ItemId = This.MenuItems.GetKey(m.pItemKey)

m.loMenuItem.StatusBarText = Iif(Vartype(m.pcStatusBarText) = "C", m.pcStatusBarText, "")

*!* ID of the submenu called by this menu item
If m.pnType = 3
	m.loMenuItem.SubMenuId = This.Menus(m.pItemKey).MenuId
Else
	m.loMenuItem.SubMenuId = 0
Endif

m.loMenuItem = .Null.

Return m.pItemKey


*!* hbmpItem: Handle to the bitmap to be displayed,
*!* or it can be one of the values in the following table.
*!* It is used when the MIIM_BITMAP flag is set in the fMask member.
*!* HBMMENU_CALLBACK
*!*	HBMMENU_POPUP_CLOSE
*!*	HBMMENU_POPUP_MAXIMIZE
*!*	HBMMENU_POPUP_MINIMIZE
*!*	HBMMENU_POPUP_RESTORE
*!*	HBMMENU_SYSTEM
ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()
If ctlGetOsVersion() < NTDDI_VISTA Or This.OwnerDrawn Then
	This._WindowProcedure = ctlGetWindowProcedure(This.FormHwnd)
	Bindevent(This.FormHwnd, WM_MEASUREITEM,  This, "OnWmMeasureItem")
	Bindevent(This.FormHwnd, WM_DRAWITEM,     This, "OnWmDrawItem")
Endif

ENDPROC
PROCEDURE _setmenuiteminfo_hbmpitem
*!* _SetMenuItemInfo_hBmpItem

Lparameters pnHostId, pnItemId, pnBitmapId

Local ;
	lcMenuItemInfo As String, ;
	loMenuItemInfo As ctlMenuItemInfo

m.loMenuItemInfo = Createobject("ctlMenuItemInfo")

m.loMenuItemInfo.fMask = MIIM_BITMAP
m.loMenuItemInfo.hbmpItem = m.pnBitmapId
m.lcMenuItemInfo = m.loMenuItemInfo.Value

apiSetMenuItemInfo(m.pnHostId, m.pnItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)

m.loMenuItemInfo = Null

ENDPROC
PROCEDURE _setmenuiteminfo_miim_checkmarks
*!* _SetMenuItemInfo_miim_checkmarks

Lparameters pnHostId, pnItemId, pnBitmapId

Local ;
	lcMenuItemInfo As String, ;
	loMenuItemInfo As ctlMenuItemInfo

m.loMenuItemInfo = Createobject("ctlMenuItemInfo")

m.loMenuItemInfo.fMask = MIIM_CHECKMARKS

m.loMenuItemInfo.hbmpChecked = m.pnBitmapId
m.loMenuItemInfo.hbmpUnchecked = m.pnBitmapId

m.lcMenuItemInfo = m.loMenuItemInfo.Value

apiSetMenuItemInfo(m.pnHostId, m.pnItemId, MF_BYCOMMAND, @m.lcMenuItemInfo)

m.loMenuItemInfo = Null

ENDPROC
PROCEDURE add
*!* Add

*!* This method adds menu bars, menu popups, menu items,
*!* and menu items with sub menu popups

Lparameters m.peItemKey1, m.peItemKey2, m.pcCaption, m.pePicture

If Pcount() = 0 Then
	Return
Endif

If Pcount() = 1 Or Empty(m.peItemKey2) Then
	This._AddMenu(m.peItemKey1)
Else
	This._AddMenuItem(m.peItemKey1, m.peItemKey2, m.pcCaption, m.pePicture)
Endif



ENDPROC
PROCEDURE clear
*!* Clear

*!* Release all menu popups and ctlMenuPopUp objects
Do While This.Menus.Count > 0
	apiDestroyMenu(This.Menus(This.Menus.Count).MenuId)
	This.Menus.Remove(This.Menus.Count)
Enddo

*!* Release ctlMenuItem objects
Do While This.MenuItems.Count > 0
	If This.MenuItems(This.MenuItems.Count).PictureId <> 0 Then
		apiDeleteObject(This.MenuItems(This.MenuItems.Count).PictureId)
	Endif
	This.MenuItems.Remove(This.MenuItems.Count)
Enddo

*!* Reset flags that indicate that certain menus have been created
This._EditMenuBuilt = FALSE
This._ControlMenuBuilt = FALSE

This._NextMenuItemId = 1

ENDPROC
PROCEDURE getsystemmenucaptions
********************************************************************************
*!* GetSystemMenuCaptions(m.pnMenuId)
********************************************************************************
*!*	This method creates a menu from a specified menu resource id in user32.dll,
*!* reads all the menu item Texts of the created menu, destroys the menu, and
*!* returns the Texts as a "|" delimited string
********************************************************************************

*!* Menu Resource Id 1 in user32.dll:
*!*	  MENUITEM "&Deshacer", 772
*!*	  MENUITEM "", 0, MFT_SEPARATOR
*!*	  MENUITEM "Cor&tar", 768
*!*	  MENUITEM "&Copiar", 769
*!*	  MENUITEM "&Pegar", 770
*!*	  MENUITEM "&Eliminar", 771
*!*	  MENUITEM "", 0, MFT_SEPARATOR
*!*	  MENUITEM "Seleccion&ar todo", 177
*!*	  MENUITEM "", 0, MFT_SEPARATOR
*!*	  MENUITEM "Lectu&ra de derecha a izquierda", 32768, MFS_GRAYED
*!*	  MENUITEM "Mo&strar caracteres de control Unicode", 32769, MFS_GRAYED

*!* Menu Resource Id 16 in user32.dll:
*!*	  MENUITEM "&Restaurar", 61728
*!*	  MENUITEM "&Mover", 61456
*!*	  MENUITEM "&Tamao", 61440
*!*	  MENUITEM "Mi&nimizar", 61472
*!*	  MENUITEM "Ma&ximizar", 61488
*!*	  MENUITEM SEPARATOR
*!*	  MENUITEM "&Cerrar\tAlt+F4", 61536


Lparameters m.pnMenuId As Integer

Local ;
	lnModule As Integer, ;
	llReleaseLibrary As Boolean, ;
	lnMenu As Integer, ;
	lnPopPup As Integer

*!* Get module handle of user32 if it is loaded
m.lnModule = apiGetModuleHandle("user32.dll")

*!* If not loaded, load it
If m.lnModule = 0 Then
	m.llReleaseLibrary = TRUE
	m.lnModule = apiLoadLibrary("user32.dll")
Else
	m.llReleaseLibrary = FALSE
Endif

*!* Now create a menu from a menu resource
m.lnMenu = apiLoadMenu(m.lnModule, m.pnMenuId)

*!* Now get the first menu popup of the menubar
m.lnPopUp = apiGetSubMenu(m.lnMenu, 0)

Local ;
	lnMenuItemCount As Integer, ;
	lnBufferLen As Integer, ;
	lcBuffer As String, ;
	lnMenuTextLen As Integer, ;
	lcMenuCaptions As String

*!* Get number of menu items in menu
m.lnMenuItemCount = apiGetMenuItemCount(m.lnPopUp)
m.lnBufferLen = 0xff

*!* Get a string with all the menu item Texts, like: "&Undo|-|&Copy|Cu&t|&Paste|...."
m.lcMenuCaptions = ""
For m.lnx = 0 To m.lnMenuItemCount - 1
	m.lcBuffer = Space(m.lnBufferLen)
	m.lnMenuTextLen = apiGetMenuString(m.lnPopUp, m.lnx, @m.lcBuffer, m.lnBufferLen, MF_BYPOSITION)
	If m.lnMenuTextLen = 0 Then
		m.lcMenuCaptions = m.lcMenuCaptions + "-"
	Else
		m.lcMenuCaptions = m.lcMenuCaptions + Left(m.lcBuffer, m.lnMenuTextLen)
	Endif
	If m.lnx < m.lnMenuItemCount - 1 Then
		m.lcMenuCaptions = m.lcMenuCaptions + "|"
	Endif
Endfor

apiDestroyMenu(m.lnMenu)

If m.llReleaseLibrary = TRUE Then
	apiFreeLibrary(m.lnModule)
Endif

Return m.lcMenuCaptions

ENDPROC
PROCEDURE onwmdrawitem
*!* OnWmDrawItem

Lparameters m.pnHwnd As Integer, m.pnMsg As Integer, m.pnWparam As Integer, m.pnLparam As Integer

Local ;
	lnLeft, ;
	lnTop, ;
	lnWidth, ;
	lnHeight, ;
	loMenuItem As ctl32_menuitem, ;
	llFound As Boolean, ;
	llDisabled as Boolean, ;
	llHighlighted as Boolean

*!* m.pnlParam is a pointer to a DrawItemStruct structure
This._DrawItemStruct.Address = m.pnLparam

*!*	With This._DrawItemStruct
*!*		Debugout .CtlType, .CtlID, .ItemID, .itemAction, .itemState, .hwndItem, .hDC, .ItemData
*!*	Endwith

********************************************************************************
*!*	typedef struct tagDRAWITEMSTRUCT {
*!*	  UINT CtlType;
*!*	  UINT CtlID;
*!*	  UINT itemID;
*!*	  UINT itemAction;
*!*	  UINT itemState;
*!*	  HWND hwndItem;
*!*	  HDC hDC;
*!*	  RECT rcItem;
*!*	  ULONG_PTR itemData;
*!*	} DRAWITEMSTRUCT;
********************************************************************************

*!* We have a menu item in lnItemID, we are going to look it up in the menu items
*!* collection. This value is arbitrary, and is set in _AddMenuItemToCollection

m.llFound = FALSE

For m.lnIndex = 1 To This.MenuItems.Count
	If This.MenuItems(m.lnIndex).ItemId = This._DrawItemStruct.ItemID
		m.loMenuItem = This.MenuItems(m.lnIndex)
		m.llFound = TRUE
		Exit
	Endif
Endfor

*!* If menu item not found, pass message along and return
If m.llFound = FALSE Then
	Return apiCallWindowProc(This._WindowProcedure, m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam)
Endif

*!* If no picture Id, just return
If m.loMenuItem.PictureId = 0 Then
	m.loMenuItem = Null
	Return TRUE
Endif

*m.lPictureObject = m.loMenuItem.PictureObject

*!* Convert HIMETRIC of iPicture to pixels:
*!* :http://www.experts-exchange.com/Programming/Languages/Visual_Basic/Q_20024530.html

*!*	m.lnHeight 	= ctlHiMetricToPixelsY(m.loMenuItem.PictureObject.Height)
*!*	m.lnWidth 	= ctlHiMetricToPixelsX(m.loMenuItem.PictureObject.Width)

m.lnHeight = Max(16, apiGetSystemMetrics(SM_CYMENUCHECK))
m.lnWidth  = Max(16, apiGetSystemMetrics(SM_CXMENUCHECK))

m.lnLeft   	= (This._DrawItemStruct.rcItem.Right - This._DrawItemStruct.rcItem.Left - m.lnWidth) / 2 + This._DrawItemStruct.rcItem.Left
m.lnTop    	= (This._DrawItemStruct.rcItem.Bottom - This._DrawItemStruct.rcItem.Top - m.lnHeight) / 2 + This._DrawItemStruct.rcItem.Top

ApiDrawIconEx( ;
	This._DrawItemStruct.hDC, ;
	m.lnLeft, ;
	m.lnTop, ;
	m.loMenuItem.PictureId, ;
	m.lnWidth, ;
	m.lnHeight, ;
	0, ;
	0, ;
	DI_NORMAL)


*!*	With This._DrawItemStruct
*!*		?.ctlType, .ctlId, .ItemID, .ItemAction, .ItemState, .hwndItem, .hDC, .rcItem.Left, .rcItem.Top, .rcItem.Right, .rcItem.Bottom
*!*	Endwith

*!*	m.loGraphics =  _Screen.System.Drawing.Graphics.FromHdc(This._DrawItemStruct.hDC)

*!*	If m.loMenuItem.Enabled = TRUE Then
*!*		*!* This is Color:
*!*		m.loGraphics.DrawImage(m.lPictureObject, m.lnLeft, m.lnTop)
*!*	Else
*!*		*!* Draw disabled version of bitmap
*!*		*!* System.Drawing.Graphics.FromHdc FAILS in Vista when the item is disabled, so
*!*		*!* we check if we have an object
*!*		*!* TODO: clean up this code, better "disabled" version of bitmap, grayscale, but change tone
*!*		*!* emulate disabled bitmaps as much as possible maybe use the button face color

*!*		If Vartype(m.loGraphics) ="O" Then

*!*			*!* http://groups.google.kg/group/comp.lang.smalltalk.dolphin/browse_thread/thread/4ab6c6e5cf89cfad/d9a7bbe56adda9ee
*!*			#Define COLORMATRIX_DISABLED 0.2125, 0.2125, 0.2125, 0, 0, 0.2577, 0.2577, 0.2577, 0, 0, 0.0361, 0.0361, 0.0361, 0, 0, 0, 0, 0, 1, 0, 0.38, 0.38, 0.38, 0, 1

*!*			*!* http://www.codeproject.com/vb/net/colormatrix.asp North America Television Standards Committee values
*!*			*#define COLORMATRIX_DISABLED 0.299, 0.299, 0.299, 0, 0, 0.587, 0.587, 0.587, 0, 0, 0.114, 0.114, 0.114, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1

*!*			m.loClrMatrix = _Screen.System.Drawing.Imaging.ColorMatrix.New(COLORMATRIX_DISABLED)
*!*			m.loAttr = _Screen.System.Drawing.Imaging.ImageAttributes.New()
*!*			m.loAttr.SetColorMatrix(m.loClrMatrix)
*!*			m.loPixel = _Screen.System.Drawing.GraphicsUnit.Pixel
*!*			m.loCanvasRect =  _Screen.System.Drawing.Rectangle.New(m.lnLeft, m.lnTop, m.lPictureObject.Width, m.lPictureObject.Height)
*!*			m.loGraphics.DrawImage(m.lPictureObject, m.loCanvasRect, m.lPictureObject.GetBounds() , m.loPixel, m.loAttr)

*!*		Endif
*!*	Endif

Return TRUE



ENDPROC
PROCEDURE onwmmeasureitem
*!* OnWmMeasureItem
Lparameters m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam

*!* m.pnWparam contains the value of the CtlID member of the MEASUREITEMSTRUCT
*!* structure pointed to by the lpMeasureItem parameter. This value identifies
*!* the control that sent the WM_MEASUREITEM message. If the value is zero,
*!* the message was sent by a menu.

*!* Some measurements I have done in Windows XP:
*!*	Menu font size in points-SM_CYMENUCHECK-Height of item w/o pic-height of item w/ pic
*!*	6-9-17-20
*!*	8-13-17-20
*!*	9-13-18-20
*!*	10-15-20-20
*!*	11-17-22-22
*!*	12-19-23-23
*!*	13-21-25-25
*!*	14-23-27-27

Local ;
	lnHeight As Integer, ;
	lnWidth As Integer, ;
	lnBorder As Integer

*!* m.pnlParam is a pointer to a MeasureItemStruct structure
This._MeasureItemStruct.Address = m.pnLparam

With This._MeasureItemStruct
	Debugout .CtlType, .CtlID, .ItemID, .itemWidth, .itemHeight, .ItemData
Endwith
********************************************************************************
*!*	typedef struct tagMEASUREITEMSTRUCT {
*!*	  UINT CtlType;
*!*	  UINT CtlID;
*!*	  UINT itemID;
*!*	  UINT itemWidth;
*!*   UINT itemHeight;
*!*   DWORD itemData
*!*	} MEASUREITEMSTRUCT;
********************************************************************************

Local loMenuItem As Object, llFound As Boolean

*!*	m.llFound = FALSE
*!*	For m.lnIndex = 1 To This.MenuItems.Count
*!*		If This.MenuItems(m.lnIndex).ItemID = This._MeasureItemStruct.ItemID
*!*			m.loMenuItem = This.MenuItems(m.lnIndex)
*!*			m.llFound = TRUE
*!*			Exit
*!*		Endif
*!*	Endfor

If This._MeasureItemStruct.ItemID <= This.MenuItems.Count Then
	m.loMenuItem = This.MenuItems(This._MeasureItemStruct.ItemID)
Else
	Return apiCallWindowProc(This._WindowProcedure, m.pnHwnd, m.pnMsg, m.pnWparam, m.pnLparam)
Endif

*!* If menu item not found, pass message along and return
*!*	If m.llFound = FALSE Then
*!*		Return apiCallWindowProc(This._WindowProcedure, m.pnHWnd, m.pnMsg, m.pnwParam, m.pnlParam)
*!*	Endif

*!* For SM_CYMENUCHECK/SM_CXMENUCHECK lower than 15 we have to compensate
*!* 18 gives us a 20 pixel tall menu item

Local lnHeight As Integer, lnWidth As Integer

m.lnHeight = apiGetSystemMetrics(SM_CYMENUCHECK)

If m.lnHeight <= 15
	m.lnHeight = 18
Endif

m.lnWidth  = apiGetSystemMetrics(SM_CXMENUCHECK)

If m.lnWidth  <= 15
	m.lnWidth  = 18
Endif

If ctlGetOsVersion() <= NTDDI_VISTA Or This.OwnerDrawn Then
	This._MeasureItemStruct.itemWidth  = Max(m.lnWidth, This._MeasureItemStruct.itemWidth  - 1)
	This._MeasureItemStruct.itemHeight = Max(m.lnHeight, This._MeasureItemStruct.itemHeight - 1)
Else
	This._MeasureItemStruct.itemWidth  = Max(m.lnWidth, This._MeasureItemStruct.itemWidth )
	This._MeasureItemStruct.itemHeight = Max(m.lnHeight, This._MeasureItemStruct.itemHeight)
Endif

m.loMenuItem = Null

Return TRUE

ENDPROC
PROCEDURE show
*!* Show()
*!* Show(nx, ny)
*!* Show(nStyle)

Lparameters m.pnX As Integer, m.pnY As Integer, m.plAlreadyScreenCoordinates As Logical

*!* m.pnX and m.pnY specifies the point where menu should be
*!* positioned, in form coordinates! Should transform to
*!* screen coordinates

Local ;
	lnFlags As Integer, ;
	lnScreenX As Integer, ;
	lnScreenY As Integer, ;
	lnItemId As Integer

m.lnScreenX = 0
m.lnScreenY = 0

Do Case

		*!* No parameters, show at mouse cursor pos
	Case Pcount() = 0
		ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)

		*!* One parameter = 0 means show at mouse cursor, 1 means show at caret
	Case Pcount() = 1 And Vartype(m.pnX) = "N"

		If m.pnX = 0 Then
			*!* Use mouse pointer position
			ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)
		Else
			*!* Use caret position
			ctlGetCaretPos(@m.lnScreenX, @m.lnScreenY)
			ctlClientToScreen(This.FormHwnd, @m.lnScreenX, @m.lnScreenY)
			*!* add some pixels here
			m.lnScreenX = m.lnScreenX + 4
			m.lnScreenY = m.lnScreenY + 8
		Endif

		*!* At least two numeric parameters: x,y coordinates
	Case Vartype(m.pnX) + Vartype(m.pnY) = "NN"
		m.lnScreenX = m.pnX
		m.lnScreenY = m.pnY

		*!* If we dont have a third parameter, this are form coordinates,
		*!* otherwise they are already screen coordinates
		If Pcount() < 3 Then
			ctlClientToScreen(This.FormHwnd, @m.lnScreenX, @m.lnScreenY)
		Endif

		*!* show at mouse cursor pos
	Otherwise
		ctlGetCursorPos(@m.lnScreenX, @m.lnScreenY)

Endcase

If Vartype(This.ShowFlags) = "N" Then
	m.lnFlags = Bitor(This.ShowFlags, TPM_RETURNCMD)
Else
	m.lnFlags = TPM_RETURNCMD
Endif

m.lnItemId = apiTrackPopupMenuEx(This.Menus(1).MenuId, m.lnFlags, m.lnScreenX, m.lnScreenY, This.FormHwnd, Null)

For m.lnIndex = 1 To This.MenuItems.Count
	If This.MenuItems(m.lnIndex).ItemID = m.lnItemId
		Return This.MenuItems.GetKey(m.lnIndex)
		Exit
	Endif
Endfor

Return ""


ENDPROC
PROCEDURE showcontrolmenu
*!* ShowControlMenu
Lparameters m.pnX As Integer, m.pnY As Integer

Local lcCommand As String

*!* Only build menu if it is not already built
If This._ControlMenuBuilt = FALSE Then
	This.Clear

	If Pemstatus(This, "_ControlTexts", 5) = FALSE Then
		Local lcCaptions As String, lnCaptionsCount As Integer, lnx As Integer
		m.lcCaptions = This.GetSystemMenuCaptions(16)
		m.lnCaptionsCount = Getwordcount(m.lcCaptions,"|")
		This.AddProperty("_ControlTexts(" + Alltrim(Str(m.lnCaptionsCount)) + ")", "")
		For m.lnx = 1 To m.lnCaptionsCount
			This._ControlTexts(m.lnx) = Getwordnum(m.lcCaptions, m.lnx, "|")
		Endfor
	Endif

	This.Add("SMENU")

*!* Using OS images

	This.Add("SMENU", "RESTORE", 	This._ControlTexts(1), HBMMENU_POPUP_RESTORE)
	This.Add("SMENU", "MOVE",		This._ControlTexts(2))
	This.Add("SMENU", "SIZE",		This._ControlTexts(3))

	If _Screen.Activeform.MinButton Then
		This.Add("SMENU", "MINIMIZE", This._ControlTexts(4), HBMMENU_POPUP_MINIMIZE)
	Endif

	If _Screen.Activeform.MaxButton Then
		This.Add("SMENU", "MAXIMIZE", This._ControlTexts(5), HBMMENU_POPUP_MAXIMIZE)
	Endif

	If _Screen.Activeform.Closable Then
		This.Add("SMENU", "SEPARATOR1", This._ControlTexts(6))

*!* Modify Shortcut key label:
		If _Screen.Activeform.ShowWindow = 2 Then
			This.Add("SMENU", "CLOSE", This._ControlTexts(7), HBMMENU_POPUP_CLOSE)
		Else
			This.Add("SMENU", "CLOSE", Getwordnum(This._ControlTexts(7), 1, TABCHAR) + TABCHAR + "Ctrl+F4", HBMMENU_POPUP_CLOSE)
		Endif

		This.MenuItems("CLOSE").DefaultItem = TRUE
	Endif

	This._ControlMenuBuilt = TRUE
Endif

*!* Set menu items state:

Do Case
	Case _Screen.Activeform.WindowState = 0
		This.MenuItems("RESTORE").Enabled = FALSE
		This.MenuItems("MOVE").Enabled = TRUE
		This.MenuItems("SIZE").Enabled = TRUE
		If _Screen.Activeform.MinButton Then
			This.MenuItems("MINIMIZE").Enabled = TRUE
		Endif
		If _Screen.Activeform.MaxButton Then
			This.MenuItems("MAXIMIZE").Enabled = TRUE
		Endif

	Case _Screen.Activeform.WindowState = 1
		This.MenuItems("RESTORE").Enabled = TRUE
		This.MenuItems("MOVE").Enabled = FALSE
		This.MenuItems("SIZE").Enabled = FALSE
		If _Screen.Activeform.MinButton Then
			This.MenuItems("MINIMIZE").Enabled = FALSE
		Endif
		If _Screen.Activeform.MaxButton Then
			This.MenuItems("MAXIMIZE").Enabled = TRUE
		Endif

	Case _Screen.Activeform.WindowState = 2
		This.MenuItems("RESTORE").Enabled = TRUE
		This.MenuItems("MOVE").Enabled = FALSE
		This.MenuItems("SIZE").Enabled = FALSE
		If _Screen.Activeform.MinButton Then
			This.MenuItems("MINIMIZE").Enabled = TRUE
		Endif
		If _Screen.Activeform.MaxButton Then
			This.MenuItems("MAXIMIZE").Enabled = FALSE
		Endif

Endcase

m.lcCommand = This.Show(m.pnX, m.pnY)

Do Case
	Case m.lcCommand = "RESTORE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_RESTORE, 0)
	Case m.lcCommand = "MOVE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_MOVE, 0)
	Case m.lcCommand = "SIZE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_SIZE, 0)
	Case m.lcCommand = "MINIMIZE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0)
	Case m.lcCommand = "MAXIMIZE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0)
	Case m.lcCommand = "CLOSE"
		apiSendMessage(This.FormHwnd, WM_SYSCOMMAND, SC_CLOSE, 0)
	Otherwise
Endcase





ENDPROC
PROCEDURE showeditmenu
*!* ShowEditMenu
Lparameters m.pnX As Integer, m.pnY As Integer

Local lcCommand As String

This.Clear

If This._EditMenuBuilt = FALSE Then

	This.Clear

	*!* Get Edit menu Texts from Windows if we have not done it already:
	If Pemstatus(This, "_EditTexts", 5) = FALSE Then

		Local ;
			lcCaptions As String, ;
			lnCaptionsCount As Integer, ;
			lnx As Integer

		m.lcCaptions = This.GetSystemMenuCaptions(1)
		m.lnCaptionsCount = Getwordcount(m.lcCaptions,"|")

		This.AddProperty("_EditTexts(" + Alltrim(Str(m.lnCaptionsCount)) + ")", "")

		For m.lnx = 1 To m.lnCaptionsCount
			This._EditTexts(m.lnx) = Alltrim(Getwordnum(m.lcCaptions, m.lnx, "|"))
		Endfor
	Endif

	*!* Add main popup
	This.Add("_MEDIT")

	This.Add("_MEDIT", "_MED_UNDO",  This._EditTexts(1), "edit_undo_16x16.ico")
	This.Add("_MEDIT", "SEPARATOR1", This._EditTexts(2))
	This.Add("_MEDIT", "_MED_CUT", 	 This._EditTexts(3), "edit_cut_16x16.ico")
	This.Add("_MEDIT", "_MED_COPY",	 This._EditTexts(4), "edit_copy_16x16.ico")
	This.Add("_MEDIT", "_MED_PASTE", This._EditTexts(5), "edit_paste_16x16.ico")
	This.Add("_MEDIT", "_MED_CLEAR", This._EditTexts(6))
	This.Add("_MEDIT", "SEPARATOR2", This._EditTexts(7))
	This.Add("_MEDIT", "_MED_SLCTA", This._EditTexts(8))

	This._EditMenuBuilt = TRUE

Endif

*!* Set menu items state:
This.MenuItems("_MED_UNDO").Enabled = Not Skpbar("_MEDIT", _Med_undo)

*!* Skpbar(...) fails when you right click in a control that does not have the focus
*!* Skpbar still reflects the state of the previous active control

If Pemstatus(_Screen.Activeform.ActiveControl, "SelLength", 5) Then
	This.MenuItems("_MED_CUT").Enabled = _Screen.Activeform.ActiveControl.SelLength > 0
	This.MenuItems("_MED_COPY").Enabled = _Screen.Activeform.ActiveControl.SelLength > 0
	This.MenuItems("_MED_PASTE").Enabled = Not Empty(_Cliptext)
	This.MenuItems("_MED_CLEAR").Enabled = _Screen.Activeform.ActiveControl.SelLength > 0
Endif

If Pemstatus(_Screen.Activeform.ActiveControl, "ReadOnly", 5) Then
	If	_Screen.Activeform.ActiveControl.ReadOnly = TRUE Then
		This.MenuItems("_MED_CUT").Enabled = FALSE
		This.MenuItems("_MED_CLEAR").Enabled = FALSE
		This.MenuItems("_MED_PASTE").Enabled = FALSE
	Endif
Endif

m.lcCommand = This.Show(m.pnX, m.pnY)

Do Case

	Case m.lcCommand = "_MED_UNDO"
		Sys(1500, '_MED_UNDO', '_MEDIT')

	Case m.lcCommand = "_MED_CUT"
		Sys(1500, '_MED_CUT', '_MEDIT')

	Case m.lcCommand = "_MED_COPY"
		Sys(1500, '_MED_COPY', '_MEDIT')

	Case m.lcCommand = "_MED_PASTE"
		Sys(1500, '_MED_PASTE', '_MEDIT')

	Case m.lcCommand = "_MED_CLEAR"
		Sys(1500, '_MED_CLEAR', '_MEDIT')

	Case m.lcCommand = "_MED_SLCTA"
		Sys(1500, '_MED_SLCTA', '_MEDIT')

	Otherwise

Endcase


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_addmenu 
*_addmenuitem 
*_addmenuitemtocollection 
*_bindevents 
*_setbitmap 
*_setmenuiteminfo_hbmpitem 
*_setmenuiteminfo_miim_checkmarks 
*add Adds a new member to a Collection.
*clear Clears all menus and menu items.
*getsystemmenucaptions 
*onwmdrawitem Bindevent to form WM_DRAWITEM
*onwmmeasureitem Bindevent to form WM_MEASUREITEM
*show Displays a Form and specifies if the Form is modal or modeless.
*showcontrolmenu 
*showeditmenu 
_bitmapcanvasheight Item bitmap space height
_bitmapcanvaswidth Item bitmap space width
_bitmapheight Bitmap height
_bitmapwidth Bitmap width
_brush
_controlmenubuilt
_drawitemstruct
_editmenubuilt
_lookuptable
_mainhandle The handle to the top menu in the chain is saved here.
_measureitemstruct
_memberdata XML Metadata for customizable properties
_nextmenuitemid
_windowprocedure
formhwnd
menuitems
menus
ownerdrawn
parenthwnd
showflags http://msdn2.microsoft.com/en-us/library/ms648003.aspx
[END RESERVED3]
[START RESERVED4]
ctl32_contextmenu.bmp[END RESERVED4]
[START RESERVED5]
ctl32_contextmenu.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _282106X5I
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_contextmenu
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_contextmenu"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 4
Width = 94
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_contextmenu

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CD19ILD1
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_controlbase
[START PROPERTIES]

BackColor = 140,200,200
Height = 60
Name = "ctl32_controlbase"
Width = 240
_backgroundbrush = 0
_clicktime = 0
_controlhwnd = 0
_defaultheight = 0
_defaultwidth = 0
_enableupdates = .T.
_focused = .F.
_focusstart = 0
_focustimerid = 0
_focustimerinterval = 50
_fontdefaultlogfont = .F.
_fonthandle = 0
_formhasfocus = .T.
_formtype = 0
_hasfocuscue = .T.
_hostformhwnd = 0
_inpage = .F.
_memberdata =      103<VFPData><memberdata name="ctlfontname_access" type="method" display="ctlfontname_Access"/></VFPData>
_onvaluefired = .F.
_pageactive = .F.
_recreatinghandle = .F.
_visible = .T.
_windowprocedure = 0
builderx = 
ctlautosize = .T.
ctlbackcolor = -1
ctlbackgroundimage = 
ctlbackgroundimagelayout = 0
ctlbackstyle = 1
ctlbordercolor = -1
ctlbottom = 0
ctlcanfocus = .F.
ctlcontrolsource = 
ctlcreated = .F.
ctldefaultbackcolor = 0
ctldefaultbordercolor = 0
ctldefaultforecolor = 0
ctldefaultheight = 0
ctldefaultwidth = 0
ctlenabled = .T.
ctlfocused = .F.
ctlfontbold = .F.
ctlfontcharset = 1
ctlfontitalic = .F.
ctlfontname = Default
ctlfontsize = 0
ctlfontstrikethru = .F.
ctlfontunderline = .F.
ctlforecolor = -1
ctlhandle = 0
ctlhostformhwnd = 0
ctlhosthwnd = 0
ctlhwnd = 0
ctlishandlecreated = .F.
ctllocationleft = 0
ctllocationtop = 0
ctlorientation = 0
ctlrecreatinghandle = .F.
ctlright = 0
ctlshowfocuscues = .T.
ctlthemes = .T.
ctlvalue = 0
ctlvisible = .T.
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
*!* Destroy() 
*!* DO NOT REMOVE THIS CONTENT OR BINDEVENT DOES NOT WORK!
ENDPROC
PROCEDURE Init
*!* Init()

*!* This parameter is passed from host ctl32 control
Lparameters m.tnParam

This.Visible = This._Visible

This._InitLibrary()
This._InitCommonControls()
This._SetProperties()
This._AddObjects()
This._SetControlSource()
This._SetEnabled()
This._BindEvents()

*!* If we have a parameter, some other ctl32 control is parent, do no create control
*!* Let parent call ctlCreate()

If Vartype(m.tnParam) = T_LOGICAL Then
	This._Create()
Endif

Raiseevent(This, "ctlInit")

ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

This._FontDefaultLogFont = Createobject("ctlLogFont")

ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

*!* Instead of writing code in this events, we bind to them
*!* just in case code is added in subclasses without a dodefault
Bindevent(This, "GotFocus", This, "_GotFocus")
Bindevent(This, "LostFocus", This, "_LostFocus")
Bindevent(This, "Destroy", This, "ctlDispose")

*!* Manage resize and move of the control:
Bindevent(This, "Resize", This, "_OnResize", 1)
Bindevent(This, "Moved", This, "_OnMoved", 1)

*!* manage value changes of the control source
*Bindevent(This.ctlTextBox, "ProgrammaticChange", This, "_OnProgrammaticChange", 1)
Bindevent(This.ctlTextBox, "Value", This, "_OnValue", 1)

*!* Manage theme changing
Bindevent(_Screen, "Themes", This, "_OnThemes", 1)

If Thisform.Name <> _Screen.Name Then
	Bindevent(Thisform, "Themes", This, "_OnThemes", 1)
Endif

*!* We will create a background brush here
Bindevent(Thisform, "Paint", This, "_OnFormPaint", 1)

*!* If we have pages in the object hierarchy, monitor page activate/deactive
*!* to hide/show the windows control
If This._InPage = TRUE
	Local loPage As Control
	m.loPage = This._GetPage()
	Bindevent(m.loPage, "Activate", This, "_OnPageActivate", 1)
	Bindevent(m.loPage, "Deactivate", This, "_OnPageDeactivate", 1)
	m.loPage = .Null.
	Release m.loPage
Endif

*!* Add properties to form to share handling of window messages with other controls
If Type("ThisForm._2ce01ty4y_hWnd") = T_UNDEFINED Then
	Thisform.AddProperty("_2ce01ty4y_hWnd", 0)
	Thisform.AddProperty("_2ce01ty4y_Msg", 0)
	Thisform.AddProperty("_2ce01ty4y_wParam", 0)
	Thisform.AddProperty("_2ce01ty4y_lParam", 0)
	Thisform.AddProperty("_2ce01ty4y_ReturnValue", Null)
Endif

*!* Bind to general window messages proxy:
Bindevent(Thisform, "_2ce01ty4y_Msg", This, "_OnFormMessage", 1)

*!* This will tell us when there is a mouse click in a control
Bindevent(This.ctlHostFormhWnd, WM_PARENTNOTIFY, This, "_OnWindowMessage", 4)

*!* This will tell us when there is an OS theme change
Bindevent(_vfp.HWnd, WM_THEMECHANGED, This, "_OnWindowMessage", 1)

*!* This handles our API timers events
*!* WM_TIMER events
Bindevent(This.ctlHostFormhWnd, WM_TIMER, This, "_OnWindowMessage", 4)

*!* This is to monitor form deactivating/activating, to handle when
*!* a control has focus and user clicks in another form

*!* WM_ACTIVATE events
Bindevent(This.ctlHostFormhWnd, WM_ACTIVATE, This, "_OnWindowMessage", 4)

*!* This is to pass a background brush for trackbars
Bindevent(This.ctlHostFormhWnd, WM_CTLCOLORSTATIC, This, "_OnWindowMessage", 4)

*!* This is to pass a background brush for scrollbars
*!*Bindevent(This.ctlHostFormhWnd, WM_CTLCOLORSCROLLBAR, This, "_OnWindowMessage", 4)



ENDPROC
PROCEDURE _create
*!*	_Create()

If This._ControlHwnd # 0 Then
	apiDestroyWindow(This._ControlHwnd)
Endif

This._SetBackStyle()

This._PreCreate()

Local ;
	dwExStyle As Integer, ;
	lpClassName As String, ;
	lpWindowName As String, ;
	dwStyle As Integer, ;
	ny As Integer, ;
	nx As Integer, ;
	nWidth As Integer, ;
	nHeight As Integer, ;
	hWndParent As Integer, ;
	hMenu As Integer, ;
	hInstance As Integer, ;
	lpParam As Integer

If This._RecreatingHandle Then
	Return
Endif

*!* We enter Initialization Stage... 
This._RecreatingHandle = TRUE

*!* Define parameters for apiCreateWindowEx:
m.dwExStyle = 		This._GetdwExStyle()
m.lpClassName = 	This._GetlpClassName()
m.lpWindowName = 	This._GetlpWindowName()
m.dwStyle = 		This._GetdwStyle()

m.nx = 		This.ctlLocationLeft
m.ny  = 	This.ctlLocationTop
m.nWidth = 	This.Width
m.nHeight = This.Height

m.hWndParent = This.ctlHostHwnd
m.hMenu = 0
m.hInstance = 0
m.lpParam = 0

This._ControlHwnd = apiCreateWindowEx( ;
	m.dwExStyle, ;
	m.lpClassName, ;
	m.lpWindowName, ;
	m.dwStyle, ;
	m.nx, ;
	m.ny, ;
	m.nWidth, ;
	m.nHeight, ;
	m.hWndParent,  ;
	m.hMenu, ;
	m.hInstance, ;
	m.lpParam)

This._GetDefaultFont()
This._GetDefaultSize()

This._PostCreate()

This._SetValue()
This._SetThemes()
This._SetEnabled()

This._SetVisible()

*!* We finish Initialization State
This._RecreatingHandle = FALSE



ENDPROC
PROCEDURE _createbackgroundbrush
*!* _CreateBackGroundBrush()

*!* Here we create a background brush.
*!* If the control is on a themed Pageframe, this brush is a bitmap
*!* 1 pixel wide, and tall as the control, we use the column of pixels
*!* just to the left of the control.

*!* Get rid of current BackGround Brush
If This._BackGroundBrush # 0 Then
	apiDeleteObject(This._BackGroundBrush)
	This._BackGroundBrush = 0
Endif

Local loPageFrame As PageFrame

m.loPageFrame = This._GetPageFrame()

Do Case

	Case This.ctlBackStyle = 0 And This._InPage And ctlIsThemeActive(m.loPageFrame)

		Local lnTempDc, lnBitmap, lnCompatDc

		m.lnTempDc = apiGetDc(Thisform.HWnd)

		m.lnBitmap = apiCreateCompatibleBitmap(m.lnTempDc, 1, This.Height)

		m.lnCompatDc = apiCreateCompatibleDC(m.lnTempDc)

		apiSelectObject(m.lnCompatDc, m.lnBitmap)

		apiBitBlt(m.lnCompatDc, 0, 0, 1, This.Height, m.lnTempDc, Objtoclient(This, 2) - 1, Objtoclient(This, 1), SRCCOPY)

		This._BackGroundBrush = apiCreatePatternBrush(m.lnBitmap)

		apiReleaseDc(Thisform.HWnd, m.lnTempDc)
		apiDeleteObject(m.lnBitmap)
		apiDeleteObject(m.lnCompatDc)

		m.loPageFrame = .Null.
		Release m.loPageFrame

	Case This.ctlBackStyle = 0

		If Type("This.Parent.BackColor") # T_UNDEFINED
			This._BackGroundBrush = apiCreateSolidBrush(This.Parent.BackColor)
		Else
			This._BackGroundBrush = apiCreateSolidBrush(Thisform.BackColor)
		Endif

	Case This.ctlBackStyle = 1 And This.ctlBackColor = -1
		This._BackGroundBrush = apiCreateSolidBrush(This.ctlDefaultBackColor)

	Otherwise

		This._BackGroundBrush = apiCreateSolidBrush(This.ctlBackColor)

Endcase

ENDPROC
PROCEDURE _drawfocusrect
*!* _DrawFocusRect()

Local ;
	lnx, ;
	lny, ;
	lnx1, ;
	lny1, ;
	lnx2, ;
	lny2, ;
	lnDrawWidth, ;
	lnDrawMode

m.lnDrawWidth = Thisform.DrawWidth
m.lnDrawMode = Thisform.DrawMode

Thisform.DrawWidth = 1
Thisform.DrawMode = 6

m.lnx1 = This.Left - 1
m.lnx2 = This.Left + This.Width
m.lny1 = This.Top - 1
m.lny2 = This.Top + This.Height

For m.lnx = m.lnx1 To m.lnx2 Step 2
	Thisform.Line(m.lnx, m.lny1, m.lnx + 1, m.lny1)
Endfor

For m.lnx = m.lnx1 + Mod(m.lny2 - m.lny1, 2) To m.lnx2 Step 2
	Thisform.Line(m.lnx, m.lny2, m.lnx + 1, m.lny2)
Endfor

For m.lny = m.lny1 + 2 To m.lny2 - 1 Step 2
	Thisform.Line(m.lnx1, m.lny, m.lnx1, m.lny + 1 )
Endfor

For m.lny = m.lny1 + 2 - Mod(m.lnx2 - m.lnx1, 2) To m.lny2 - 1 Step 2
	Thisform.Line(m.lnx2, m.lny, m.lnx2, m.lny + 1 )
Endfor

Thisform.DrawWidth = m.lnDrawWidth
Thisform.DrawMode = m.lnDrawMode

ENDPROC
PROCEDURE _focustimertick
*!* _FocusTimerTick()

*!* This gets called when we receive a WM_TIMER message generated by our
*!* API timer to monitor key presses while the control has the focus
*!* and change focus to the next/previous control

*!* We check 150 milliseconds have passed since the control got the focus
*!* or else we would change focus with the TAB key pressed to get focus
*!* in the first place

*@1,1 Say Seconds()

Local ;
	lnKeyTab, ;
	lnKeyReturn, ;
	lnKeyShift, ;
	lnInterval

*!* SHIFT KEY
m.lnKeyShift 	= Bitand(apiGetKeyState(VK_SHIFT), 	0x8000)
*!* TAB KEY
m.lnKeyTab 		= Bitand(apiGetKeyState(VK_TAB), 	0x8000)
*!* RETURN KEY
m.lnKeyReturn 	= Bitand(apiGetKeyState(VK_RETURN), 0x8000)

m.lnInterval = apiGetTickCount() - This._FocusStart

*!* Check for apiGetTickCount overflow after 49,7 days:
If m.lnInterval < 0 Then
	m.lnInterval = 0xffffffff - This._FocusStart + apiGetTickCount()
Endif

Do Case

		*!* If this control does not have the focus, just return
	Case This._Focused = FALSE
		Return

		*!* If the form does not have focus, just return
	Case This._FormHasFocus = FALSE
		Return

		*!* If neither TAB or RETURN where pressed, just return
	Case m.lnKeyTab + m.lnKeyReturn = 0
		Return

	Case m.lnInterval < 150
		Return

		*!* SHIFT-TAB
	Case m.lnKeyTab # 0 And m.lnKeyShift # 0
		This._Focused = FALSE
		This._KillTimer(This._FocusTimerId)
		*!* Set keyboard focus to form
		apiSetfocus(Thisform.HWnd)
		Keyboard '{LEFTARROW}' Plain

		*!* TAB
	Case m.lnKeyTab # 0
		This._Focused = FALSE
		This._KillTimer(This._FocusTimerId)
		*!* Set keyboard focus to form
		apiSetfocus(Thisform.HWnd)
		Keyboard '{TAB}' Plain

		*!* ENTER
	Case m.lnKeyReturn # 0
		This._Focused = FALSE
		This._KillTimer(This._FocusTimerId)
		*!* Set keyboard focus to form
		apiSetfocus(Thisform.HWnd)
		Keyboard '{TAB}' Plain

Endcase

ENDPROC
PROCEDURE _getdefaultfont
*!* _GetDefaultFont()

*!* This saves the default font of the control

If This._ControlHwnd = 0 Then
	Return
Endif

Local ;
	lnFontHandle As Integer, ;
	lcLogFont As String

*!* Get a handle to the current font
m.lnFontHandle = apiSendMessage(This._ControlHwnd, WM_GETFONT, 0, 0)

*!* Get a LogFont structure
m.lcLogFont = This._FontDefaultLogFont.Value

*!* Get font info from font handle
apiGetObject(m.lnFontHandle, Len(m.lcLogFont), @m.lcLogFont)

*!* Save LogFont structure
This._FontDefaultLogFont.Value = m.lcLogFont

*!* Fix MonthCalendar UGLY default non-themed font:
If This._GetlpClassName() = MONTHCAL_CLASSA Then
	If ctlGetOsVersion() < CON_OS_WINVISTA Then
		This._FontDefaultLogFont.FontName = "Tahoma"
	Else
		This._FontDefaultLogFont.FontBold = FALSE
		This._FontDefaultLogFont.FontName = "Segoe UI"
		This._FontDefaultLogFont.FontSize = 8
	Endif
Endif

This._EnableUpdates = FALSE

*!* Now set value of default properties:
If Sys(1269, This, "ctlFontBold", 0) = FALSE Then
	This.ctlFontBold =  This._FontDefaultLogFont.FontBold
Endif

If Sys(1269, This, "ctlFontCharSet", 0) = FALSE Then
	This.ctlFontCharSet = This._FontDefaultLogFont.FontCharSet
Endif

If Sys(1269, This, "ctlFontStrikethru", 0) = FALSE Then
	This.ctlFontItalic = This._FontDefaultLogFont.FontItalic
Endif

If Sys(1269, This, "ctlFontName", 0) = FALSE
	This.ctlFontName = This._FontDefaultLogFont.FontName
Endif

If Sys(1269, This, "ctlFontSize", 0) = FALSE Then
	This.ctlFontSize = This._FontDefaultLogFont.FontSize
Endif

If Sys(1269, This, "ctlFontStrikethru", 0) = FALSE Then
	This.ctlFontStrikethru = This._FontDefaultLogFont.FontStrikethru
Endif

If Sys(1269, This, "ctlFontUnderline", 0) = FALSE Then
	This.ctlFontUnderline = This._FontDefaultLogFont.FontUnderline
Endif

This._EnableUpdates = TRUE

This._SetFont()




ENDPROC
PROCEDURE _getdefaultsize
*!* _GetDefaultSize()
ENDPROC
PROCEDURE _getdwexstyle
*!* _GetdwExStyle()

Return 0

ENDPROC
PROCEDURE _getdwstyle
*!* _GetdwStyle

Return 0

ENDPROC
PROCEDURE _getlpclassname
*!* _GetlpClassName()
ENDPROC
PROCEDURE _getlpwindowname
*!* _GetWindowName

Return ""


ENDPROC
PROCEDURE _getpage
*!* _GetPage()

Local loControl As Control

m.loControl = This

Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE

	If Upper(m.loControl.BaseClass) == "PAGE" Then
		Exit
	Endif

	m.loControl = m.loControl.Parent

Enddo

Return m.loControl

ENDPROC
PROCEDURE _getpageframe
*!* _GetPageFrame()

Local loControl as Control

m.loControl = This

Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE

	If Upper(m.loControl.BaseClass) == "PAGEFRAME" Then
		Exit
	Endif

	m.loControl = m.loControl.Parent

Enddo

Return m.loControl

ENDPROC
PROCEDURE _gotfocus
*!* _GotFocus()

*!* Save the moment this control got the focus, we use this
*!* to prevent focus jumping to next control
This._FocusStart = apiGetTickCount()

*!* Set Focus to control window
If This.ctlCanFocus Then
	apiSetfocus(This._ControlHwnd)
Endif

This._Focused = TRUE

If This._HasFocusCue = FALSE AND This.ctlShowFocusCues = TRUE Then
	This._DrawFocusRect()
Endif

*!* Start monitoring keystrokes, create a new API timer
This._KillTimer(This._FocusTimerId)
This._FocusTimerId = This._SetTimer(This._FocusTimerInterval)


ENDPROC
PROCEDURE _initcommoncontrols
*!* _InitCommonControls()

Local lcControls As String

*!* This is needed to make the month calendar common control work in windows 2000
If Type("_Screen._0BCB895540F84134BDF39BB58FE0D43F") = T_UNDEFINED Then

	_Screen.AddProperty("_0BCB895540F84134BDF39BB58FE0D43F", TRUE)

	m.lcControls = BinToC(8, "4rs") + BinToC(ICC_DATE_CLASSES, "4RS")
	apiInitCommonControlsEx(@m.lcControls)

Endif

ENDPROC
PROCEDURE _initlibrary
*!* _InitLibrary()

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

ENDPROC
PROCEDURE _iscontrolinpage
*!* _IsControlInPage()

Local ;
	llPageFound As Boolean, ;
	loControl As Control

m.llPageFound = FALSE

m.loControl = This

Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE

	If Upper(m.loControl.BaseClass) == "PAGE" Then
		m.llPageFound = TRUE
		Exit
	Endif

	If Type("m.loControl.Parent") # T_UNDEFINED Then
		m.loControl = m.loControl.Parent
	Else
		Exit
	Endif

Enddo

m.loControl = .Null.
Release m.loControl

Return m.llPageFound


ENDPROC
PROCEDURE _killtimer
*!* _KillTimer()

Lparameters m.pnTimerId As Integer

If m.pnTimerId = 0 Then
	Return
Endif

apiKillTimer(This.ctlHostFormhWnd, m.pnTimerId)


ENDPROC
PROCEDURE _lostfocus
*!* _LostFocus()

*!* This event happens when user clicks on another control that
*!* can get focus in the form. We have to stop monitoring focus
*!* keys and return keyboard input to the form window.

This._KillTimer(This._FocusTimerId)

This._Focused = FALSE

If This._HasFocusCue = FALSE AND This.ctlShowFocusCues = TRUE Then
	This._DrawFocusRect()
Endif

If This._FormHasFocus = TRUE
	apiSetfocus(Thisform.HWnd)
Endif


ENDPROC
PROCEDURE _objtoclient
*!* _ObjToClient(cPosition)

Lparameters m.tcPosition As String

Local ;
	lnPosition As Integer, ;
	loControl As Control

m.tcPosition = Upper(m.tcPosition)
m.lnPosition = 0
m.loControl = This

Do Case

	Case m.tcPosition $ "TOP|BOTTOM"
		*!* 20070711 Modified to account for toolbars
		Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
			If Pemstatus(m.loControl, "Top", CTLPEMSTATUS_DEFINED) Then
				m.lnPosition = m.lnPosition + m.loControl.Top
			Endif
			If Upper(m.loControl.BaseClass) == "PAGE" Then
				If m.loControl.Parent.TabOrientation = CTLTABORIENTATION_TOP Then	&& Top
					m.lnPosition = m.lnPosition + ;
						m.loControl.Parent.Height - ;
						m.loControl.Parent.PageHeight - ;
						m.loControl.Parent.BorderWidth * 2
				Else
					m.lnPosition = m.lnPosition + 1
				Endif
			Endif
			m.loControl = m.loControl.Parent
		Enddo

		If m.tcPosition == "BOTTOM" Then
			m.lnPosition = m.lnPosition + This.Height
		Endif

	Case m.tcPosition $ "LEFT|RIGHT"
		*!* 20070711 Modified to account for toolbars
		Do While Inlist(Upper(m.loControl.BaseClass), "FORM", "TOOLBAR") = FALSE
			If Pemstatus(m.loControl, "Left", CTLPEMSTATUS_DEFINED) Then
				m.lnPosition = m.lnPosition + m.loControl.Left
			Endif
			If Upper(m.loControl.BaseClass) == "PAGE"
				If m.loControl.Parent.TabOrientation = CTLTABORIENTATION_LEFT Then	&& Left
					m.lnPosition = m.lnPosition + ;
						m.loControl.Parent.Width - ;
						m.loControl.Parent.PageWidth - ;
						m.loControl.Parent.BorderWidth * 2
				Else
					m.lnPosition = m.lnPosition + 1
				Endif
			Endif
			m.loControl = m.loControl.Parent
		Enddo

		If m.tcPosition == "RIGHT" Then
			m.lnPosition = m.lnPosition + This.Width
		Endif

Endcase

m.loControl = .Null.
Release m.loControl

Return m.lnPosition

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_TIMER And Thisform._2ce01ty4y_wParam = This._FocusTimerId

		This._FocusTimerTick()

	Case Thisform._2ce01ty4y_Msg = WM_PARENTNOTIFY

		Local lnX, lnY, lcPoint

		*!* If we have a mouse click
		If This.ctlEnabled And Inlist(Thisform._2ce01ty4y_wParam, WM_LBUTTONDOWN, WM_RBUTTONDOWN, WM_MBUTTONDOWN)

			*!* Get mouse click coordinates in pixels relative to form:
			m.lnX = ctlLoWord(Thisform._2ce01ty4y_lParam)
			m.lnY = ctlHiWord(Thisform._2ce01ty4y_lParam)

			*!* Check if control window is under that point:
			*!* We can only get this messages from visible windows
			If This.ctlVisible = TRUE ;
					And Between(m.lnX, This.ctlLocationLeft, This.ctlLocationLeft + This.Width) ;
					And Between(m.lnY, This.ctlLocationTop, This.ctlLocationTop + This.Height) Then
				
				If This.ctlCanFocus Then
					This.SetFocus()
					apiSetFocus(This._ControlHwnd)
				Endif
				
				*!* Raise click/rightclick/middleclick event
				Do Case
						*!* special case if this is a monthcalendar control
					Case Thisform._2ce01ty4y_wParam = WM_LBUTTONDOWN And This._GetlpClassName() == MONTHCAL_CLASSA
						Local ;
							loMcHitTestInfo As ctlMCHITTESTINFO, ;
							lcMcHitTestInfo As String, ;
							loPoint As ctlPoint, ;
							lcPoint As String

						m.loMcHitTestInfo = Newobject("ctlMCHITTESTINFO")
						m.loPoint = Newobject("ctlPoint")

						m.lcPoint = m.loPoint.Value

						*!* Get mouse position in monthcalendar window coordinates:
						apiGetCursorPos(@m.lcPoint)
						apiScreenToClient(This._ControlHwnd, @m.lcPoint)
						m.loPoint.Value = m.lcPoint

						*!* Set coordinates of structure
						m.loMcHitTestInfo.pt.X = m.loPoint.X
						m.loMcHitTestInfo.pt.Y = m.loPoint.Y

						*!* Send MCM_HITTEST message to get where click was
						m.lcMcHitTestInfo = m.loMcHitTestInfo.Value
						apiSendMessage(This._ControlHwnd, MCM_HITTEST, 0, @m.lcMcHitTestInfo)
						m.loMcHitTestInfo.Value = m.lcMcHitTestInfo

						*?This._ControlHwnd,m.loMcHitTestInfo.uHit, MCHT_CALENDARDATE, MCHT_TODAYLINK

						If Seconds() - This._ClickTime < apiGetDoubleClickTime() / 1000 Then
							*!* Only raise DblClick if clicked on day or today
							If Inlist(m.loMcHitTestInfo.uHit, MCHT_CALENDARDATE, MCHT_TODAYLINK) Then
								Raiseevent(This, "DblClick")
							Endif
						Else
							This._ClickTime = Seconds()
							Raiseevent(This, "Click")
						Endif

						m.loMcHitTestInfo = .Null.
						m.lcPoint = .Null.

					Case Thisform._2ce01ty4y_wParam = WM_LBUTTONDOWN
						If Seconds() - This._ClickTime < apiGetDoubleClickTime() / 1000 Then
							Raiseevent(This, "DblClick")
						Else
							This._ClickTime = Seconds()
							Raiseevent(This, "Click")
						Endif

					Case Thisform._2ce01ty4y_wParam = WM_RBUTTONDOWN
						Raiseevent(This, "RightClick")

					Case Thisform._2ce01ty4y_wParam = WM_MBUTTONDOWN
						Raiseevent(This, "MiddleClick")

				Endcase
			Endif
		Endif

	Case Thisform._2ce01ty4y_Msg = WM_CTLCOLORSTATIC

		*!* here we provide a background brush

		*!* If the message is not for this control, just return
		If Thisform._2ce01ty4y_lParam # This._ControlHwnd Then
			Return
		Endif

		*!* Return a background brush (Brush can just be 0)
		Thisform._2ce01ty4y_ReturnValue = This._BackGroundBrush

	Case Thisform._2ce01ty4y_Msg = WM_ACTIVATE

		If ctlLoWord(Thisform._2ce01ty4y_wParam) = WA_INACTIVE
			This._FormHasFocus = FALSE
		Else
			This._FormHasFocus = TRUE
		Endif

	Case Thisform._2ce01ty4y_Msg = WM_THEMECHANGED
		This._SetThemes()

		*!* Update colors if needed
		This._UpdateColors()

		*!* Send a color change message to control to force redraw and
		*!* prevent glitches
		If This._ControlHwnd # 0 Then
			apiSendMessage(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)
		Endif

Endcase


ENDPROC
PROCEDURE _onformpaint
*!* _OnFormPaint()

This._CreateBackgroundBrush()

Unbindevents(Thisform, "Paint", This, "_OnFormPaint")


ENDPROC
PROCEDURE _onmoved
*!* _OnMoved()

Local ;
	lhwnd As Integer, ;
	lhWndInsertAfter As Integer, ;
	lx As Integer, ;
	ly As Integer, ;
	lcx As Integer, ;
	lcy As Integer, ;
	lwFlags As Integer, ;
	loPageFrame As PageFrame

If This._ControlHwnd = 0 Then
	Return
Endif

m.loPageFrame = This._GetPageFrame()

*!* If control is in a pageframe, update background brush since it is no longer valid
If This.ctlBackStyle = 0 And This._InPage And ctlIsThemeActive(m.loPageFrame) Then
	This._CreateBackgroundBrush()
Endif

m.loPageFrame = .Null.
Release m.loPageFrame

m.lhwnd 			= This._ControlHwnd
m.lhWndInsertAfter 	= 0
m.lx 				= This.ctlLocationLeft
m.ly  				= This.ctlLocationTop
m.lcx 				= This.Width
m.lcy 				= This.Height
m.lwFlags 			= SWP_NOZORDER

*!* This is here cause we are getting dll exception when month calendar
*!* control has more than one row and column
Try
	apiSetWindowPos( ;
		m.lhwnd, ;
		m.lhWndInsertAfter,;
		m.lx, ;
		m.ly, ;
		m.lcx, ;
		m.lcy, ;
		m.lwFlags)
Catch
Endtry


ENDPROC
PROCEDURE _onpageactivate
*!* _OnPageActivate()

This._PageActive = TRUE
This._SetVisible()
ENDPROC
PROCEDURE _onpagedeactivate
*!* _OnPageDeactivate()

This._PageActive = FALSE
This._SetVisible()
ENDPROC
PROCEDURE _onparentbackcolor
*!* _OnParentBackColor()

This._CreateBackGroundBrush()

This.ctlRefresh()

ENDPROC
PROCEDURE _onresize
*!* _OnResize()

This._OnMoved()
ENDPROC
PROCEDURE _onthemes
*!* _OnThemes()

This._SetThemes()

ENDPROC
PROCEDURE _onvalue
*!* _OnValue()

This.ctlValue = This.ctlTextBox.Value

ENDPROC
PROCEDURE _onwindowmessage
*!* _OnWindowMessage()

Lparameters m.HWnd As Integer, m.Msg As Integer, m.wParam As Integer, m.lParam As Integer

Local lnRetValue As Integer

Thisform._2ce01ty4y_hWnd 	= m.HWnd
Thisform._2ce01ty4y_wParam 	= m.wParam
Thisform._2ce01ty4y_lParam 	= m.lParam

*!* fill this value last, will trigger _OnFormMessage
Thisform._2ce01ty4y_Msg 	= m.Msg

*!* _OnFormMessage will set Thisform._2ce01ty4y_ReturnValue if it wants
*!* to return a value # to the default window procedure.

If Isnull(Thisform._2ce01ty4y_ReturnValue) Then
	m.lnRetValue = apiCallWindowProc(This._WindowProcedure, m.HWnd, m.Msg, m.wParam, m.lParam)
Else
	m.lnRetValue = Thisform._2ce01ty4y_ReturnValue
	*!* Reset return value to 0
	Thisform._2ce01ty4y_ReturnValue = Null
Endif

Return m.lnRetValue


ENDPROC
PROCEDURE _postcreate
*!* _PostCreate()


ENDPROC
PROCEDURE _precreate
*!* _PreCreate()
ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

ENDPROC
PROCEDURE _setbackcolor
*!* _SetBackColor()
ENDPROC
PROCEDURE _setbackstyle
*!* _SetBackStyle()

*!* We get here only of ctlBackStyle changed

*!* We bind to form activate if we have a ctlBackStyle = 0
If This.ctlBackStyle = 0 Then

	If Type("This.Parent.BackColor") # T_UNDEFINED
		Bindevent(This.Parent, "BackColor", This, "_OnParentBackColor", 1)
	Else
		Bindevent(Thisform, "BackColor", This, "_OnParentBackColor", 1)
	Endif

Else

	If Type("This.Parent.BackColor") # T_UNDEFINED
		Unbindevent(This.Parent, "BackColor", This, "_OnParentBackColor")
	Else
		Unbindevent(Thisform, "BackColor", This, "_OnParentBackColor")
	Endif

Endif

This._CreateBackGroundBrush()

This.ctlRefresh()


ENDPROC
PROCEDURE _setbordercolor
*!* _SetBorderColor()
ENDPROC
PROCEDURE _setcontrolsource
*!* _SetControlSource()

This.ctlTextBox.ControlSource = This.ctlControlSource

If Not Empty(This.ctlControlSource) Then
	This.ctlValue = This.ctlTextBox.Value
Endif

ENDPROC
PROCEDURE _setenabled
*!* _SetEnabled()

*!* We want the focus to go to the next enabled control if this control
*!* gets disabled while it has the focus, so we disable the dummy textbox
*!* first. We then disable the container to prevent click events to fire.
*!* Also we disable the focus timer just in case it is enabled.
*!* To be shure, we give keyboard focus to the form

If This.ctlEnabled = FALSE Then
	This._KillTimer(This._FocusTimerId)
Endif

This.ctlTextBox.Enabled = This.ctlEnabled And This.ctlCanFocus
This.Enabled = This.ctlEnabled And This.ctlCanFocus

If This.ctlEnabled = FALSE Then
	If This._FormHasFocus = TRUE
		apiSetfocus(Thisform.HWnd)
	Endif
Endif

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlEnabled = TRUE Then
	apiEnableWindow(This._ControlHwnd, TRUE)
Else
	*!* Return keyboard focus to form
	apiEnableWindow(This._ControlHwnd, FALSE)
Endif


ENDPROC
PROCEDURE _setfont
*!* _SetFont()

*!*	typedef struct tagLOGFONT {
*!*	  LONG lfHeight;
*!*	  LONG lfWidth;
*!*	  LONG lfEscapement;
*!*	  LONG lfOrientation;
*!*	  LONG lfWeight;
*!*	  BYTE lfItalic;
*!*	  BYTE lfUnderline;
*!*	  BYTE lfStrikeOut;
*!*	  BYTE lfCharSet;
*!*	  BYTE lfOutPrecision;
*!*	  BYTE lfClipPrecision;
*!*	  BYTE lfQuality;
*!*	  BYTE lfPitchAndFamily;
*!*	  TCHAR lfFaceName[LF_FACESIZE];
*!*	} LOGFONT, *PLOGFONT;

If This._ControlHwnd = 0 Then
	Return
Endif

If This._EnableUpdates = FALSE Then
	Return
Endif

Local ;
	loLogFont As ctlLogFont, ;
	lcLogFont As String

m.loLogFont = Createobject("ctlLogFont")
m.loLogFont.Value = This._FontDefaultLogFont.Value

*!* Fill members of font structure:
With m.loLogFont
	.FontBold			= This.ctlFontBold
	.FontCharSet		= This.ctlFontCharSet
	.FontItalic 		= This.ctlFontItalic
	.FontName 			= This.ctlFontName + NULA
	.FontSize			= This.ctlFontSize
	.FontStrikethru 	= This.ctlFontStrikethru
	.FontUnderline 		= This.ctlFontUnderline
Endwith

*!* Release Font object if we already have one:
If This._FontHandle <> 0 Then
	apiDeleteObject(This._FontHandle )
Endif

m.lcLogFont = m.loLogFont.Value

*!* Create a new font object:
This._FontHandle = apiCreateFontIndirect(@m.lcLogFont)

*!* Set control font to this font object:
apiSendMessage(This._ControlHwnd, WM_SETFONT, This._FontHandle, 1)

m.loLogFont = .Null.
Release m.loLogFont


ENDPROC
PROCEDURE _setforecolor
*!* _SetForeColor()
ENDPROC
PROCEDURE _setorientation
*!* _SetOrientation()
ENDPROC
PROCEDURE _setproperties
*!* _SetProperties()

*!* Specifies if control is inside a pageframe
This._InPage = This._IsControlInPage()

*This._FormType = ctlGetFormType(This)


ENDPROC
PROCEDURE _setshowfocuscues
*!* _SetShowFocusCues()

Local wParam As Integer

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlShowFocusCues Then
	m.wParam = ctlMakewParam(UIS_CLEAR, UISF_HIDEFOCUS)
Else
	m.wParam = ctlMakewParam(UIS_SET, UISF_HIDEFOCUS)
Endif

apiSendMessage(This._ControlHwnd, WM_CHANGEUISTATE, m.wParam, 0)

ENDPROC
PROCEDURE _setthemes
*!* _SetThemes()

If This._ControlHwnd = 0 Then
	Return
Endif

If ctlIsThemeActive(This) = TRUE Then
	apiSetWindowTheme(This._ControlHwnd, .Null., .Null.)
Else
	apiSetWindowTheme(This._ControlHwnd, .Null., "")
Endif


ENDPROC
PROCEDURE _settimer
*!* _SetTimer()

*!* A more reliable timer
*!* /http://hermantan.blogspot.com/2006_09_01_archive.html

Lparameters m.pnInterval As Integer

Local lnTimerId As Integer

m.lnTimerId = Int((0xffff - 0x1 + 1) * Rand( ) + 0x1)

apiSetTimer(This.ctlHostFormhWnd, m.lnTimerId, m.pnInterval, 0)

Return m.lnTimerId

ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

If Not Empty(This.ctlTextBox.ControlSource) Then
	This.ctlTextBox.Value = This.ctlValue
	Thisform.Refresh()
Endif

Raiseevent(This, "ctlValueChanged")


ENDPROC
PROCEDURE _setvisible
*!* _SetVisible()

Local m.llVisible As Logical

m.llVisible = This.ctlVisible

If This._InPage = TRUE
	m.llVisible = This._PageActive And m.llVisible
Endif

*!* Set the container control itself visible property
This.Visible = m.llVisible And This._Visible

If This._ControlHwnd = 0 Then
	Return
Endif

If m.llVisible = TRUE Then
	apiShowWindow(This._ControlHwnd, SW_SHOWNA)
Else
	apiShowWindow(This._ControlHwnd, SW_HIDE)
Endif


ENDPROC
PROCEDURE _updatecolors
*!* _UpdateColors()
ENDPROC
PROCEDURE _windowprocedure_access
*!* _WindowProcedure_Access()

If This._WindowProcedure = 0 Then
	This._WindowProcedure = ctlGetWindowProcedure()
Endif

Return This._WindowProcedure

ENDPROC
PROCEDURE ctlautosize_assign
*!* ctlAutoSize_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

*!* Always do this
*!* If This.ctlAutoSize # m.tuNewValue Then

This.ctlAutoSize = m.tuNewValue
This._SetAutoSize()

*!* Endif


ENDPROC
PROCEDURE ctlbackcolor_assign
*!* ctlBackColor_Assign(tuNewValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlBackColor # m.tuNewValue Then
	This.ctlBackColor = m.tuNewValue
	This._SetBackColor()
Endif




ENDPROC
PROCEDURE ctlbackgroundimage_assign
lparameters tuNewValue
This.ctlBackgroundImage = tuNewValue

ENDPROC
PROCEDURE ctlbackgroundimagelayout_assign
lparameters tuNewValue
This.ctlBackgroundImageLayout = tuNewValue

ENDPROC
PROCEDURE ctlbackstyle_assign
*!* ctlBackStyle_Assign()

Lparameters m.tuNewValue

If m.tuNewValue # 0 Then
	m.tuNewValue = 1
Endif

If This.ctlBackStyle # m.tuNewValue Then
	This.ctlBackStyle = m.tuNewValue
	This._SetBackStyle()
Endif

ENDPROC
PROCEDURE ctlbordercolor_assign
*!* ctlBorderColor_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlBorderColor # m.tuNewValue Then
	This.ctlBorderColor = m.tuNewValue
	This._SetBorderColor()
Endif

ENDPROC
PROCEDURE ctlbottom_access
*!* ctlBottom_Access()

Return This.Top + This.Height

ENDPROC
PROCEDURE ctlcontrolsource_assign
Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlControlSource # m.tuNewValue Then
	This.ctlControlSource = m.tuNewValue
	This._SetControlSource()
Endif


ENDPROC
PROCEDURE ctlcreatecontrol
*!* CreateControl()

This._Create()

ENDPROC
PROCEDURE ctlcreated_access
*!* ctlCreated_Access()

Return This._ControlHwnd # 0

ENDPROC
PROCEDURE ctldefaultbackcolor_access
*!* ctlDefaultBackColor_Access()

*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
*!*	AppWorkspace			= COLOR_APPWORKSPACE 
*!*	ButtonFace				= COLOR_BTNFACE
*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
*!*	ButtonShadow			= COLOR_BTNSHADOW
*!*	Control					= COLOR_BTNFACE
*!*	ControlDark				= COLOR_BTNSHADOW
*!*	ControlDarkDark			= COLOR_3DDKSHADOW
*!*	ControlLight			= COLOR_BTNHIGHLIGHT
*!*	ControlLightLight		= COLOR_3DLIGHT
*!*	ControlText				= COLOR_BTNTEXT
*!*	Desktop					= COLOR_DESKTOP
*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
*!*	GrayText				= COLOR_GRAYTEXT
*!*	Highlight				= COLOR_HIGHLIGHT
*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
*!*	HotTrack				= COLOR_HOTLIGHT
*!*	InactiveBorder			= COLOR_INACTIVEBORDER
*!*	InactiveCaption			= COLOR_INACTIVECAPTION
*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
*!*	Info					= COLOR_INFOBK
*!*	InfoText				= COLOR_INFOTEXT
*!*	Menu					= COLOR_MENU
*!*	MenuBar					= COLOR_MENUBAR
*!*	MenuHighlight			= COLOR_MENUHILIGHT 
*!*	MenuText				= COLOR_MENUTEXT
*!*	Scrollbar				= COLOR_SCROLLBAR
*!*	Window					= COLOR_WINDOW
*!*	WindowFrame				= COLOR_WINDOWFRAME
*!*	WindowText				= COLOR_WINDOWTEXT

Local lnColor As Integer

Do Case

	Case This._GetlpClassName() = TRACKBAR_CLASSA
		m.lnColor = apiGetSysColor(COLOR_BTNFACE)	&& Control

	Case This._GetlpClassName() = PROGRESS_CLASSA
		m.lnColor = apiGetSysColor(COLOR_BTNFACE)	&& Control

	Case This._GetlpClassName() = MONTHCAL_CLASSA
		m.lnColor = apiGetSysColor(COLOR_WINDOW)	&& Window
	
	Case This._GetlpClassName() = TOOLTIPS_CLASSA
		m.lnColor = apiGetSysColor(COLOR_INFOBK)	&& Info
	
	Otherwise
		m.lnColor = 0

Endcase

Return m.lnColor

ENDPROC
PROCEDURE ctldefaultbordercolor_access
*!* ctlDefaultBorderColor_Access()

*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
*!*	AppWorkspace			= COLOR_APPWORKSPACE 
*!*	ButtonFace				= COLOR_BTNFACE
*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
*!*	ButtonShadow			= COLOR_BTNSHADOW
*!*	Control					= COLOR_BTNFACE
*!*	ControlDark				= COLOR_BTNSHADOW
*!*	ControlDarkDark			= COLOR_3DDKSHADOW
*!*	ControlLight			= COLOR_BTNHIGHLIGHT
*!*	ControlLightLight		= COLOR_3DLIGHT
*!*	ControlText				= COLOR_BTNTEXT
*!*	Desktop					= COLOR_DESKTOP
*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
*!*	GrayText				= COLOR_GRAYTEXT
*!*	Highlight				= COLOR_HIGHLIGHT
*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
*!*	HotTrack				= COLOR_HOTLIGHT
*!*	InactiveBorder			= COLOR_INACTIVEBORDER
*!*	InactiveCaption			= COLOR_INACTIVECAPTION
*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
*!*	Info					= COLOR_INFOBK
*!*	InfoText				= COLOR_INFOTEXT
*!*	Menu					= COLOR_MENU
*!*	MenuBar					= COLOR_MENUBAR
*!*	MenuHighlight			= COLOR_MENUHILIGHT 
*!*	MenuText				= COLOR_MENUTEXT
*!*	Scrollbar				= COLOR_SCROLLBAR
*!*	Window					= COLOR_WINDOW
*!*	WindowFrame				= COLOR_WINDOWFRAME
*!*	WindowText				= COLOR_WINDOWTEXT

Local lnColor As Integer

Do Case

*!*		Case This._GetlpClassName() = TRACKBAR_CLASSA
*!*			m.lnColor = apiGetSysColor()

	Case This._GetlpClassName() = PROGRESS_CLASSA
		m.lnColor = apiGetSysColor(COLOR_BTNSHADOW)

	Case This._GetlpClassName() = MONTHCAL_CLASSA
		m.lnColor = apiGetSysColor(COLOR_WINDOW)	&& Window
*!*		
*!*		Case This._GetlpClassName() = TOOLTIPS_CLASSA
*!*			m.lnColor = apiGetSysColor()
	
	Otherwise
		m.lnColor = 0

Endcase

Return m.lnColor
ENDPROC
PROCEDURE ctldefaultforecolor_access
*!* ctlDefaultForeColor_Access()

*!*	ActiveBorder			= COLOR_ACTIVEBORDER 
*!*	ActiveCaption			= COLOR_ACTIVECAPTION 
*!*	ActiveCaptionText		= COLOR_CAPTIONTEXT 
*!*	AppWorkspace			= COLOR_APPWORKSPACE 
*!*	ButtonFace				= COLOR_BTNFACE
*!*	ButtonHighlight			= COLOR_BTNHIGHLIGHT
*!*	ButtonShadow			= COLOR_BTNSHADOW
*!*	Control					= COLOR_BTNFACE
*!*	ControlDark				= COLOR_BTNSHADOW
*!*	ControlDarkDark			= COLOR_3DDKSHADOW
*!*	ControlLight			= COLOR_BTNHIGHLIGHT
*!*	ControlLightLight		= COLOR_3DLIGHT
*!*	ControlText				= COLOR_BTNTEXT
*!*	Desktop					= COLOR_DESKTOP
*!*	GradientActiveCaption	= COLOR_GRADIENTACTIVECAPTION
*!*	GradientInactiveCaption	= COLOR_GRADIENTINACTIVECAPTION
*!*	GrayText				= COLOR_GRAYTEXT
*!*	Highlight				= COLOR_HIGHLIGHT
*!*	HighlightText			= COLOR_HIGHLIGHTTEXT
*!*	HotTrack				= COLOR_HOTLIGHT
*!*	InactiveBorder			= COLOR_INACTIVEBORDER
*!*	InactiveCaption			= COLOR_INACTIVECAPTION
*!*	InactiveCaptionText		= COLOR_INACTIVECAPTIONTEXT
*!*	Info					= COLOR_INFOBK
*!*	InfoText				= COLOR_INFOTEXT
*!*	Menu					= COLOR_MENU
*!*	MenuBar					= COLOR_MENUBAR
*!*	MenuHighlight			= COLOR_MENUHILIGHT 
*!*	MenuText				= COLOR_MENUTEXT
*!*	Scrollbar				= COLOR_SCROLLBAR
*!*	Window					= COLOR_WINDOW
*!*	WindowFrame				= COLOR_WINDOWFRAME
*!*	WindowText				= COLOR_WINDOWTEXT

Local lnColor As Integer

Do Case

	Case This._GetlpClassName() = TRACKBAR_CLASSA
		m.lnColor = apiGetSysColor(COLOR_WINDOWTEXT)	&& WindowText

	Case This._GetlpClassName() = PROGRESS_CLASSA
		m.lnColor = apiGetSysColor(COLOR_HIGHLIGHT)		&& Highlight

	Case This._GetlpClassName() = MONTHCAL_CLASSA
		m.lnColor = apiGetSysColor(COLOR_WINDOWTEXT)	&& WindowText
	
	Case This._GetlpClassName() = TOOLTIPS_CLASSA
		m.lnColor = apiGetSysColor(COLOR_INFOTEXT)		&& InfoText
	
	Otherwise
		m.lnColor = 0

Endcase

Return m.lnColor

ENDPROC
PROCEDURE ctldefaultheight_access
*!* ctlDefaultHeight_Access()

Return This.ctlDefaultHeight

ENDPROC
PROCEDURE ctldefaultwidth_access
*!* ctlDefaultWidth_Access()

Return This.ctlDefaultWidth

ENDPROC
PROCEDURE ctldispose
*!* ctlDispose()

If This._ControlHwnd # 0 Then
	apiDestroyWindow(This._ControlHwnd)
Endif

If This._BackGroundBrush # 0 Then
	apiDeleteObject(This._BackGroundBrush)
Endif

If This._FontHandle # 0 Then
	apiDeleteObject(This._FontHandle)
Endif

This._KillTimer(This._FocusTimerId)

This._FontDefaultLogFont = .Null.

ENDPROC
PROCEDURE ctlenabled_assign
*!* ctlEnabled_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

If This.ctlEnabled # m.tuNewValue Then
	This.ctlEnabled = m.tuNewValue
	This._SetEnabled()
Endif


ENDPROC
PROCEDURE ctlfocused_access
*!* ctlFocused_Access()

Return This._Focused

ENDPROC
PROCEDURE ctlfontbold_assign
*!* ctlFontBold_Assign(lValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

This.ctlFontBold = m.tuNewValue
This._SetFont()


ENDPROC
PROCEDURE ctlfontcharset_assign
*!* ctlFontCharSet_Assign(lValue)

Lparameters m.tuNewValue

This.ctlFontCharSet = m.tuNewValue
This._SetFont()

ENDPROC
PROCEDURE ctlfontitalic_assign
*!* ctlFontItalic_Assign(lValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

This.ctlFontItalic = m.tuNewValue
This._SetFont()

ENDPROC
PROCEDURE ctlfontname_assign
*!* ctlFontName_Assign(tuNewValue)

Lparameters m.tuNewValue

This.ctlFontName = m.tuNewValue
This._SetFont()



ENDPROC
PROCEDURE ctlfontsize_assign
*!* ctlFontSize_Assign(lValue)

Lparameters m.tuNewValue

This.ctlFontSize = m.tuNewValue
This._SetFont()

ENDPROC
PROCEDURE ctlfontstrikethru_assign
*!* ctlFontStrikethru_Assign(lValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

This.ctlFontStrikethru = m.tuNewValue
This._SetFont()

ENDPROC
PROCEDURE ctlfontunderline_assign
*!* ctlFontUnderline_Assign(lValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

This.ctlFontUnderline = m.tuNewValue
This._SetFont()

ENDPROC
PROCEDURE ctlforecolor_assign
*!* ctlForeColor_Assign(tuNewValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlForeColor # m.tuNewValue Then
	This.ctlForeColor = m.tuNewValue
	This._SetForeColor()
Endif
ENDPROC
PROCEDURE ctlhandle_access
*!* ctlHandle_Access()

Return This._ControlHwnd

ENDPROC
PROCEDURE ctlhide
*!* ctlHide()

This.ctlVisible = FALSE

ENDPROC
PROCEDURE ctlhostformhwnd_access
*!* ctlHostFormhWnd_Access()

*!* Gets hWnd of form or form inner window
If This._HostFormhWnd = 0 Then
	This._HostFormhWnd = ctlGetHostHWnd(This)
Endif

Return This._HostFormhWnd

ENDPROC
PROCEDURE ctlhosthwnd_access
*!* ctlHostHwnd_Access()

If This.ctlHostHwnd = 0 Then
	This.ctlHostHwnd = ctlGetHostHwnd(This)
Endif

Return This.ctlHostHwnd

ENDPROC
PROCEDURE ctlhwnd_access
*!* ctlHwnd_Access()

Return This._ControlHwnd

ENDPROC
PROCEDURE ctlishandlecreated_access
*!* ctlIsHandleCreated_Access()

Return This._ControlHwnd # 0

ENDPROC
PROCEDURE ctllocationleft_access
*!* ctlLocationLeft_Access()

Return This._ObjToClient("Left")


ENDPROC
PROCEDURE ctllocationtop_access
*!* ctlLocationTop_Access()

Return This._ObjToClient("Top")


ENDPROC
PROCEDURE ctlorientation_assign
*!* ctlOrientation_Assign()

Lparameters m.tuNewValue

If m.tuNewValue # 0 Then
	m.tuNewValue = 1
Endif

If This.ctlOrientation # m.tuNewValue Then
	This.ctlOrientation = m.tuNewValue
	This._SetOrientation()
Endif

ENDPROC
PROCEDURE ctlrecreatinghandle_access
*!* ctlRecreatingHandle_Access()

Return This._RecreatingHandle

ENDPROC
PROCEDURE ctlrefresh
*!* ctlRefresh()

Local lnFlags As Integer

If This._ControlhWnd = 0 Then
	Return
Endif

Do Case

	Case This._GetlpClassName() = "msctls_trackbar32"
		*!* trackbar only refreshes with this:
		apiSendMessage(This._ControlhWnd, WM_SETFOCUS, 0, 0)

	Otherwise
		m.lnFlags = Bitor(RDW_FRAME, RDW_ERASE, RDW_INVALIDATE, RDW_UPDATENOW, RDW_NOCHILDREN)
		apiRedrawWindow(This._ControlhWnd, "", 0, m.lnFlags)

Endcase




ENDPROC
PROCEDURE ctlresetbackcolor
*!* ctlResetBackColor()

This.ctlBackColor = THis.ctlDefaultBackColor

ENDPROC
PROCEDURE ctlresetbordercolor
*!* ctlResetBorderColor()

This.ctlBorderColor = This.ctlDefaultBorderColor

ENDPROC
PROCEDURE ctlresetfont
*!* ctlResetFont()

This._EnableUpdates = FALSE

This.ctlFontBold 		= This._FontDefaultLogFont.FontBold
This.ctlFontCharSet 	= This._FontDefaultLogFont.FontCharSet
This.ctlFontItalic 		= This._FontDefaultLogFont.FontItalic
This.ctlFontName 		= This._FontDefaultLogFont.FontName
This.ctlFontSize 		= This._FontDefaultLogFont.FontSize
This.ctlFontStrikethru 	= This._FontDefaultLogFont.FontStrikethru
This.ctlFontUnderline 	= This._FontDefaultLogFont.FontUnderline

This._EnableUpdates = TRUE

This._SetFont()

ENDPROC
PROCEDURE ctlresetforecolor
*!* ctlResetForeColor()

This.ctlForeColor = This.ctlDefaultForeColor

ENDPROC
PROCEDURE ctlright_access
*!* ctlRight_Access()

Return This.Left + This.Width

ENDPROC
PROCEDURE ctlshow
*!* ctlShow()

This.ctlVisible = TRUE

ENDPROC
PROCEDURE ctlshowfocuscues_assign
*!* ctlShowFocusCues_Assign(lExpression)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlShowFocusCues # m.tuNewValue Then
	This.ctlShowFocusCues = m.tuNewValue
	This._SetShowFocusCues()
Endif


ENDPROC
PROCEDURE ctlthemes_assign
*!* ctlThemes_Assign(lExpression)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlThemes # m.tuNewValue Then
	This.ctlThemes = m.tuNewValue
	This._SetThemes()
Endif



ENDPROC
PROCEDURE ctlvalue_assign
*!* ctlValue_Assign(nValue)

Lparameters m.tuNewValue

If Type("This.ctlMaximum") = T_NUMERIC Then
	m.tuNewValue = Min(This.ctlMaximum, m.tuNewValue)
Endif

If Type("This.ctlMinimum") = T_NUMERIC Then
	m.tuNewValue = Max(This.ctlMinimum, m.tuNewValue)
Endif

If This.ctlValue # m.tuNewValue Then
	This.ctlValue = m.tuNewValue
	This._SetValue()
Endif


ENDPROC
PROCEDURE ctlvaluechanged
*!* ctlValueChanged()
ENDPROC
PROCEDURE ctlvisible_assign
*!* ctlVisible_Assign(lValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlVisible # m.tuNewValue Then
	This.ctlVisible = m.tuNewValue
	This._SetVisible()
Endif




ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
*_addobjects Adds objects used by the class.
*_bindevents Binds to events used by the class.
*_create Creates the windows control
*_createbackgroundbrush Creates a brush.
*_drawfocusrect Draws a focus rectangle for controls that do not have one.
*_focustimertick Tick event of the focus timer.
*_getdefaultfont 
*_getdefaultsize 
*_getdwexstyle 
*_getdwstyle 
*_getlpclassname 
*_getlpwindowname 
*_getpage Returns an object reference to the page that contains this control.
*_getpageframe 
*_gotfocus 
*_initcommoncontrols 
*_initlibrary 
*_iscontrolinpage Returns TRUE if the control is contained in a page.
*_killtimer Kills an API timer.
*_lostfocus Binded to the LostFocus event of the container.
*_objtoclient Replaces OBJTOCLIENT that has bugs.
*_onformmessage Bindevent(Thisform, "_2ce01ty4y_Msg", This, "_OnFormMessage", 1)
*_onformpaint 
*_onmoved Bindevent(This, "Moved", This, "_OnMoved", 1)
*_onpageactivate Bindevent(m.loControl, "Activate", This, "_OnPageActivate", 1)
*_onpagedeactivate Bindevent(m.loControl, "Deactivate", This, "_OnPageDeactivate", 1)
*_onparentbackcolor 
*_onresize Bindevent(This, "Resize", This, "_OnResize", 1)
*_onthemes Bindevent(_Screen, "Themes", This, "_OnThemes", 1) / Bindevent(Thisform, "Themes", This, "_OnThemes", 1)
*_onvalue 
*_onwindowmessage 
*_postcreate 
*_precreate 
*_setautosize 
*_setbackcolor 
*_setbackstyle 
*_setbordercolor 
*_setcontrolsource 
*_setenabled 
*_setfont 
*_setforecolor 
*_setorientation 
*_setproperties 
*_setshowfocuscues 
*_setthemes 
*_settimer 
*_setvalue 
*_setvisible 
*_updatecolors 
*_windowprocedure_access 
*ctlautosize_assign 
*ctlbackcolor_assign 
*ctlbackgroundimage_assign 
*ctlbackgroundimagelayout_assign 
*ctlbackstyle_assign 
*ctlbordercolor_assign 
*ctlbottom_access 
*ctlcontrolsource_assign 
*ctlcreatecontrol Forces the creation of the control, including the creation of the handle and any child controls.
*ctlcreated_access 
*ctldefaultbackcolor_access 
*ctldefaultbordercolor_access 
*ctldefaultforecolor_access 
*ctldefaultheight_access 
*ctldefaultwidth_access 
*ctldispose Releases all resources used by the control.
*ctlenabled_assign 
*ctlfocused_access 
*ctlfontbold_assign 
*ctlfontcharset_assign 
*ctlfontitalic_assign 
*ctlfontname_assign 
*ctlfontsize_assign 
*ctlfontstrikethru_assign 
*ctlfontunderline_assign 
*ctlforecolor_assign 
*ctlhandle_access 
*ctlhide Conceals the control from the user.
*ctlhostformhwnd_access 
*ctlhosthwnd_access 
*ctlhwnd_access 
*ctlinit Occurs when anobject is created, after the Init event.
*ctlishandlecreated_access 
*ctllocationleft_access 
*ctllocationtop_access 
*ctlorientation_assign 
*ctlrecreatinghandle_access 
*ctlrefresh Forces the control to invalidate its client area and immediately redraw itself and any child controls.
*ctlresetbackcolor Resets the ctlBackColor property to its default value.
*ctlresetbordercolor Resets the ctlBorderColor property to its default value.
*ctlresetfont Resets the Font... properties to its default values.
*ctlresetforecolor Resets the ctlForeColor property to its default value.
*ctlright_access 
*ctlshow Displays the control to the user. Showing the control is equivalent to setting the ctlVisible property to true.
*ctlshowfocuscues_assign 
*ctlthemes_assign 
*ctlvalue_assign 
*ctlvaluechanged Occurs when the ctlValue property changes.
*ctlvisible_assign 
_backgroundbrush Handle to a GDI brush, passed to the control.
_clicktime Stores seconds() for click event to detect double clicks.
_controlhwnd hwnd of the control window.
_defaultheight
_defaultwidth
_enableupdates
_focused Specifies if the control has the focus.
_focusstart Specifies the time the control got focus, used by _FocusTimerTick.
_focustimerid Handle to an API timer that checks keys pressed while contrl has focus.
_focustimerinterval INterval in milliseconds of the focus timer.
_fontdefaultlogfont
_fonthandle
_formhasfocus Specifies if the form has focus.
_formtype
_hasfocuscue Specifies if the control has its own focus rect. If FALSE, class draws focus rect.
_hostformhwnd
_inpage Specifies if the control is in a page, somewhere in its object tree. Used to show/hide the control when the page becomes active/inactive.
_memberdata XML Metadata for customizable properties
_onvaluefired
_pageactive
_recreatinghandle
_visible Set to FALSE to make container NEVER Visible
_windowprocedure
builderx
ctlautosize Gets or sets a value indicating whether the height and/or width of the control is automatically sized.
ctlbackcolor Gets or sets the background color for the control.
ctlbackgroundimage Gets or sets the background image displayed in the control.
ctlbackgroundimagelayout Gets or sets the background image layout.
ctlbackstyle Specifies if the background of an object is transparent or opaque.
ctlbordercolor Gets or sets the border color of the control.
ctlbottom Gets the distance, in pixels, between the bottom edge of the control and the top edge of its container's client area.
ctlcanfocus Specifies whether the control can receive focus.
ctlcontrolsource Specifies the source of data to which an object is bound.
ctlcreated Gets a value indicating whether the control has been created.
ctldefaultbackcolor Gets the default background color of the control.
ctldefaultbordercolor Gets the default border color of the control.
ctldefaultforecolor Gets the default foreground color of the control.
ctldefaultheight Gets the default height of the control.
ctldefaultwidth Gets the default width of the control.
ctlenabled Gets or sets a value indicating whether the control can respond to user interaction.
ctlfocused Gets a value indicating whether the control has input focus.
ctlfontbold Specifies if the text is bold.
ctlfontcharset Specifies the character set, or language script, of the font.
ctlfontitalic Specifies if the text is italic.
ctlfontname Specifies the name of the font.
ctlfontsize Specifies the size of the font
ctlfontstrikethru Specifies if the text is strikethru.
ctlfontunderline Specifies if the text is underline.
ctlforecolor Gets or sets the foreground color of the control.
ctlhandle Gets the window handle that the control is bound to.
ctlhostformhwnd Specifies the window handle of the inner window of the parent form.
ctlhosthwnd Gets the windows handle of the parent object of this control, if there is one.
ctlhwnd DEPRECATED. Replaced by the .NET ctlHandle property.
ctlishandlecreated Gets a value indicating whether the control has a handle associated with it.
ctllocationleft Gets or sets the Left coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
ctllocationtop Gets or sets the Top coordinate of the upper-left corner of the control relative to the upper-left corner of its container. (ObjToClient)
ctlorientation Gets or sets a value indicating the horizontal or vertical orientation of the control.
ctlrecreatinghandle Gets a value indicating whether the control is currently re-creating its handle.
ctlright Gets the distance, in pixels, between the right edge of the control and the left edge of its container's client area. (Left + Width)
ctlshowfocuscues Gets or sets a value indicating whether the control should display focus rectangles.
ctlthemes Specifies if themes are used for the control.
ctlvalue Specifies the current value or state of the control.
ctlvisible Gets or sets a value indicating whether the control is displayed.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CN0WT966
[CLASS] textbox
[BASECLASS] textbox
[OBJNAME] ctlTextBox
[PARENT] ctl32_controlbase
[START PROPERTIES]
Height = 23
Left = 0
Name = "ctlTextBox"
Top = 32000
Width = 100
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CD19JH9W
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_controlbase
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_base"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Left = 6
Name = "lblname"
Top = 2
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_controlbase
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2DM1DWUNM
[CLASS] combobox
[BASECLASS] combobox
[OBJNAME] ctl32_datepicker
[START PROPERTIES]

ControlSource = ""
DisplayValue = ctl32_datepicker
FontName = "Tahoma"
FontSize = 8
Name = "ctl32_datepicker"
SelectOnEntry = .T.
Value = 
Width = 84
_dropdown = .F.
_enableupdates = .T.
_focused = .F.
_markkeypressed = .F.
_memberdata =      181<VFPData><memberdata name="controlsource" type="property" display="ControlSource"/><memberdata name="controlsource_assign" type="method" display="ControlSource_Assign"/></VFPData>
_shadow = 
_textbox = .F.
ctlcalendar = .F.
ctlcalendarvisible = .F.
ctlcontrolsource = 
ctlfocused = .F.
ctlmaxdate = (date(9998,12,31))
ctlmindate = (date(1800,1,1))
ctlusedatetime = .F.
ctluseinputmask = .F.
ctlvalue = ({})
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
*!* Destroy()

This.ctlCalendar = .Null.
This._TextBox = .Null.

ENDPROC
PROCEDURE GotFocus
*!* GotFocus()

*!* This is done here in case date format was changed
If Not Empty(This.ctlValue) Then
	This.ctlValue = Date(Year(This.ctlValue), Month(This.ctlValue), Day(This.ctlValue))
Endif

*!* This is done here in case date format was changed
If This.ctlUseInputMask = TRUE Then
	This._SetInputMask()
Endif

*!* In case set century value was changed
If Set("Century") = "ON" Then
	This.MaxLength = 10
Else
	This.MaxLength = 8
Endif

*!* Select whole text even if clicked
If This.SelectOnEntry
	Nodefault
	ComboBox::GotFocus()
Endif

This._Focused = TRUE

ENDPROC
PROCEDURE Init
*!* Init()

This._InitLibrary()
This._AddObjects()
This._BindEvents()
This._SetControlSource()

*!* Default to current day
If Empty(This.ctlValue) And Empty(This.ctlControlSource)
	This.ctlValue = Date()
Endif




ENDPROC
PROCEDURE KeyPress
*!* KeyPress()

Lparameters nKeyCode, nShiftAltCtrl

Local ;
	lcMark As String, ;
	lnMark1 As Integer, ;
	lnMark2 As Integer, ;
	lnSelStart As Integer, ;
	lnSelLength As Integer, ;
	lcSelected As String, ;
	lnSeconds As Integer

If Vartype(This.ctlValue) = T_DATETIME Then
	m.lnSeconds = 1 * 60 * 60 * 24
Else
	m.lnSeconds = 1
Endif

*!* Get current date separator
m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))

*!* Get position of separators
m.lnMark1 = At(m.lcMark, This.DisplayValue, 1)
m.lnMark2 = At(m.lcMark, This.DisplayValue, 2)

m.lnSelStart = This.SelStart
m.lnSelLength = This.SelLength

m.lcSelected = "D"

*!* DOWN ARROW / UP ARROW
If Inlist(m.nKeyCode, 24, 5) And m.nShiftAltCtrl = 0 And This.ctlCalendarVisible = FALSE
	*!* if the whole date is not selected, select the day, month or year
	*!* depending on where the cursor is located:
	If This.SelLength < Len(This.DisplayValue)
		Do Case
			Case This.SelStart < m.lnMark1
				This.SelStart = 0
				This.SelLength = m.lnMark1 - 1
				Do Case
					Case Set("Date", 1) = 0	&& MDY
						m.lcSelected = "M"
					Case Set("Date", 1) = 1	&& DMY
						m.lcSelected = "D"
					Case Set("Date", 1) = 2	&& YMD
						m.lcSelected = "Y"
				Endcase

			Case This.SelStart >= m.lnMark1 And This.SelStart < m.lnMark2
				This.SelStart = m.lnMark1
				This.SelLength = m.lnMark2 - m.lnMark1 - 1
				Do Case
					Case Set("Date", 1) = 0	&& MDY
						m.lcSelected = "D"
					Case Set("Date", 1) = 1	&& DMY
						m.lcSelected = "M"
					Case Set("Date", 1) = 2	&& YMD
						m.lcSelected = "M"
				Endcase

			Case This.SelStart >= m.lnMark2
				This.SelStart = m.lnMark2
				This.SelLength = Len(This.DisplayValue) - m.lnMark2
				Do Case
					Case Set("Date", 1) = 0	&& MDY
						m.lcSelected = "Y"
					Case Set("Date", 1) = 1	&& DMY
						m.lcSelected = "Y"
					Case Set("Date", 1) = 2	&& YMD
						m.lcSelected = "D"
				Endcase

		Endcase

		m.lnSelStart = This.SelStart
		m.lnSelLength = This.SelLength

	Endif

Endif

Do Case

		*!* SPACE, F4
	Case Inlist(m.nKeyCode, -3, 32, 160) And Inlist(m.nShiftAltCtrl, 0, 4)
		This.ctlCalendarVisible = Not This.ctlCalendarVisible
		Nodefault

		*!* ESC
	Case m.nKeyCode = 27 And m.nShiftAltCtrl = 0
		If This.ctlCalendarVisible = TRUE Then
			This.ctlCalendarVisible = FALSE
			Nodefault
		Endif

		*!* DOWN ARROW
	Case m.nKeyCode = 24 And m.nShiftAltCtrl = 0
		If This.ctlCalendarVisible = TRUE
			This.ctlValue = This.ctlValue + 7
		Else
			Do Case
				Case m.lcSelected = "D"
					This.ctlValue = This.ctlValue - 1 * m.lnSeconds
				Case m.lcSelected = "M"
					This.ctlValue = Gomonth(This.ctlValue, -1)
				Case m.lcSelected = "Y"
					This.ctlValue = Gomonth(This.ctlValue, -12)
			Endcase
		Endif

		If Empty(This.ctlValue) Then
			If This.ctlUseDateTime = TRUE Then
				This.ctlValue = Datetime(Year(Date()), Month(Date()), Day(Date()), 0, 0, 0)
			Else
				This.ctlValue = Date()
			Endif
		Endif
		Nodefault

		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength

		*!* UP ARROW
	Case m.nKeyCode = 5 And m.nShiftAltCtrl = 0
		If This.ctlCalendarVisible = TRUE
			This.ctlValue = This.ctlValue - 7
		Else
			Do Case
				Case m.lcSelected = "D"
					This.ctlValue = This.ctlValue + 1 * m.lnSeconds
				Case m.lcSelected = "M"
					This.ctlValue = Gomonth(This.ctlValue, 1)
				Case m.lcSelected = "Y"
					This.ctlValue = Gomonth(This.ctlValue, 12)
			Endcase
		Endif

		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		Nodefault

		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength

		*!* LEFT ARROW
	Case m.nKeyCode = 19 And m.nShiftAltCtrl = 0
		If This.ctlCalendarVisible = TRUE
			This.ctlValue = This.ctlValue - 1 * m.lnSeconds
			If Empty(This.ctlValue) Then
				This.ctlValue =Date()
			Endif
			This.SelStart = m.lnSelStart
			This.SelLength = m.lnSelLength
			Nodefault
		Else
			If This.SelLength = Len(This.DisplayValue) Then
				This.SelStart = 0
				This.SelLength = 0
				Nodefault
			Endif
		Endif

		*!* RIGHT ARROW
	Case m.nKeyCode = 4 And m.nShiftAltCtrl = 0
		If This.ctlCalendarVisible = TRUE
			This.ctlValue = This.ctlValue + 1 * m.lnSeconds
			If Empty(This.ctlValue) Then
				This.ctlValue =Date()
			Endif
			This.SelStart = m.lnSelStart
			This.SelLength = m.lnSelLength
			Nodefault
		Else
			If This.SelLength = Len(This.DisplayValue) Then
				This.SelStart = 0
				This.SelLength = 0
				Nodefault
			Endif

		Endif

		*!* NUMPAD +
	Case m.nKeyCode = 43 And m.nShiftAltCtrl = 0
		This.ctlValue = This.ctlValue + 1 * m.lnSeconds
		If Empty(This.ctlValue) Then
			This.ctlValue = Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* NUMPAD -
	Case m.nKeyCode = 45 And m.nShiftAltCtrl = 0 And This.SelLength = Len(This.DisplayValue)
		This.ctlValue = This.ctlValue - 1 * m.lnSeconds
		If Empty(This.ctlValue) Then
			This.ctlValue = Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* PAGE DOWN
	Case m.nKeyCode = 3 And m.nShiftAltCtrl = 0
		This.ctlValue = Gomonth(This.ctlValue, 1)
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* CTRL + PAGE DOWN
	Case m.nKeyCode = 30 And m.nShiftAltCtrl = 2
		This.ctlValue = Gomonth(This.ctlValue, 12)
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* PAGE UP
	Case m.nKeyCode = 18 And m.nShiftAltCtrl = 0
		This.ctlValue = Gomonth(This.ctlValue, -1)
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* CTRL + PAGE UP
	Case m.nKeyCode = 31 And m.nShiftAltCtrl = 2
		This.ctlValue = Gomonth(This.ctlValue, -12)
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* HOME
	Case m.nKeyCode = 1 And m.nShiftAltCtrl = 0
		This.ctlValue = This.ctlValue - Day(This.ctlValue)  * m.lnSeconds + 1 * m.lnSeconds
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* CTRL + HOME
	Case m.nKeyCode = 29 And m.nShiftAltCtrl = 2
		This.ctlValue = Date()
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* END
	Case m.nKeyCode = 6 And m.nShiftAltCtrl = 0
		This.ctlValue = Gomonth(This.ctlValue, 1) - Day(This.ctlValue)
		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength
		Nodefault

		*!* MARK keys
	Case Between(m.nKeyCode, 32, 126) And Chr(m.nKeyCode) $ ".,/*-"
		If This._MarkKeyPressed = FALSE Then
			If Occurs(m.lcMark, This.DisplayValue) < 2 ;
					And Right(Alltrim(This.DisplayValue), 1) # m.lcMark Then
				This._MarkKeyPressed = TRUE
				Keyboard m.lcMark Plain
			Else
				??Chr(7)
			Endif
			Nodefault
		Else
			This._MarkKeyPressed = FALSE
		Endif

		*!* Reject rest
	Case Between(m.nKeyCode, 32, 126) And Not (Chr(m.nKeyCode) $ "0123456789")
		??Chr(7)
		Nodefault

	Otherwise
Endcase

ENDPROC
PROCEDURE LostFocus
*!* LostFocus()

This.ctlCalendarVisible = FALSE
This._Focused = FALSE
This._ValiDate()


ENDPROC
PROCEDURE MouseUp
*!* MouseUp()

Lparameters nButton, nShift, nXCoord, nYCoord

*!* All this is here because the NODEFAULT in the GOTFOCUS prevents
*!* the month calendar drop down to open when the control does not
*!* have the focus and the user clicks in the dropdown arrow
*!* the NODEFAULT in the GOTFOCUS is there so the text stays selected
*!* on GOTFOCUS even if the control gets focus by a mouse click.

If This._DropDown = TRUE Then
	This._DropDown = FALSE
	Return
Endif

Local m.lnx1, m.lnx2

*!* Check if the mouse click is within the down arrow button
m.lnx1 = Objtoclient(This, 2) + This.Width - Sysmetric(7) - This.Margin
m.lnx2 = Objtoclient(This, 2) + This.Width

If Between(m.nXCoord, m.lnx1, m.lnx2) Then
 This.ctlCalendarVisible = Not This.ctlCalendarVisible
Endif
ENDPROC
PROCEDURE MouseWheel
*!* MouseWheel()

Lparameters nDirection, nShift, nXCoord, nYCoord

If This.ctlFocused = FALSE Then
	Return
Endif

Local ;
	lcMark As String, ;
	lnMark1 As Integer, ;
	lnMark2 As Integer, ;
	lnSelStart As Integer, ;
	lnSelLength As Integer, ;
	lcSelected As String, ;
	m.lnSeconds As Integer

If Vartype(This.ctlValue) = T_DATETIME Then
	m.lnSeconds = 1 * 60 * 60 * 24
Else
	m.lnSeconds = 1
Endif


*!* Get current date separator
m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))

*!* Get position of separators
m.lnMark1 = At(m.lcMark, This.DisplayValue, 1)
m.lnMark2 = At(m.lcMark, This.DisplayValue, 2)

m.lnSelStart = This.SelStart
m.lnSelLength = This.SelLength

m.lcSelected = "D"

*!* if the whole date is not selected, select the day, month or year
*!* depending on where the cursor is located:
If This.SelLength < Len(This.DisplayValue)
	Do Case
		Case This.SelStart < m.lnMark1
			This.SelStart = 0
			This.SelLength = m.lnMark1 - 1
			Do Case
				Case Set("Date", 1) = 0	&& MDY
					m.lcSelected = "M"
				Case Set("Date", 1) = 1	&& DMY
					m.lcSelected = "D"
				Case Set("Date", 1) = 2	&& YMD
					m.lcSelected = "Y"
			Endcase

		Case This.SelStart >= m.lnMark1 And This.SelStart < m.lnMark2
			This.SelStart = m.lnMark1
			This.SelLength = m.lnMark2 - m.lnMark1 - 1
			Do Case
				Case Set("Date", 1) = 0	&& MDY
					m.lcSelected = "D"
				Case Set("Date", 1) = 1	&& DMY
					m.lcSelected = "M"
				Case Set("Date", 1) = 2	&& YMD
					m.lcSelected = "M"
			Endcase

		Case This.SelStart >= m.lnMark2
			This.SelStart = m.lnMark2
			This.SelLength = Len(This.DisplayValue) - m.lnMark2
			Do Case
				Case Set("Date", 1) = 0	&& MDY
					m.lcSelected = "Y"
				Case Set("Date", 1) = 1	&& DMY
					m.lcSelected = "Y"
				Case Set("Date", 1) = 2	&& YMD
					m.lcSelected = "D"
			Endcase

	Endcase

	m.lnSelStart = This.SelStart
	m.lnSelLength = This.SelLength

Endif

Do Case
		*!* DOWN
	Case nDirection < 0
		Do Case
			Case m.lcSelected = "D"
				This.ctlValue = This.ctlValue - 1 * m.lnSeconds
			Case m.lcSelected = "M"
				This.ctlValue = Gomonth(This.ctlValue, -1)
			Case m.lcSelected = "Y"
				This.ctlValue = Gomonth(This.ctlValue, -12)
		Endcase

		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		Nodefault

		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength

		*!* UP
	Case  nDirection > 0
		Do Case
			Case m.lcSelected = "D"
				This.ctlValue = This.ctlValue + 1 * m.lnSeconds
			Case m.lcSelected = "M"
				This.ctlValue = Gomonth(This.ctlValue, +1)
			Case m.lcSelected = "Y"
				This.ctlValue = Gomonth(This.ctlValue, +12)
		Endcase

		If Empty(This.ctlValue) Then
			This.ctlValue =Date()
		Endif
		Nodefault

		This.SelStart = m.lnSelStart
		This.SelLength = m.lnSelLength

Endcase

ENDPROC
PROCEDURE Move
*!* Move()

Lparameters nLeft, nTop, nWidth, nHeight
This.ctlCalendarVisible = FALSE

ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

Local ;
	lcCalendarName As String, ;
	lcTextBox As String

m.lcTextBox = Sys(2015)
Thisform.AddObject(m.lcTextBox, "TextBox")
This._TextBox = Getpem(Thisform, m.lcTextBox)

m.lcCalendarName = Sys(2015)
Thisform.AddObject(m.lcCalendarName, "ctl32_monthcalendar")
This.ctlCalendar = Getpem(Thisform, m.lcCalendarName)

This.ctlCalendarVisible = FALSE

With This.ctlCalendar
	.ctlFontName = "Tahoma"
	.ctlFontSize = 8
	.ctlCanFocus = FALSE
	.ctlMinDate = This.ctlMinDate
	.ctlMaxDate = This.ctlMaxDate
	If ctlGetOsVersion() < NTDDI_VISTA Then
		.ctlBorderWidth = 1
	Endif
Endwith

ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

Bindevent(This.ctlCalendar, "DblClick", This, "_OnCalendarDblClick")
Bindevent(This.ctlCalendar, "ctlValueChanged", This, "_OnCalendarctlValueChanged")
Bindevent(Thisform, "Click", This, "_OnFormClick")

Bindevent(This._TextBox, "Value", This, "_OnValue", 1)

ENDPROC
PROCEDURE _getbordercolor
*!* _GetBorderColor()

*!* Returns color to use for border
Local ;
	m.lnTheme, ;
	m.lnColor

m.lnColor = 0
If ctlIsThemeActive(This.ctlCalendar) Then
	m.lnTheme = apiOpenThemeData(0, VSCLASS_EDIT)
	If m.lnTheme <> 0 Then
		apiGetThemeColor(m.lnTheme, EP_BACKGROUNDWITHBORDER, EBWBS_NORMAL, TMT_BORDERCOLOR, @m.lnColor)
		apiCloseThemeData(m.lnTheme)
	Endif
Else
	m.lnColor = apiGetSysColor(COLOR_BTNSHADOW)
Endif

Return m.lnColor

ENDPROC
PROCEDURE _initlibrary
*!* _InitLibrary()

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

ENDPROC
PROCEDURE _oncalendarctlvaluechanged
*!* _OnCalendarctlValueChanged()

If This._EnableUpdates = TRUE Then
	This.ctlValue = This.ctlCalendar.ctlValue
Endif

This._SelectAll()

ENDPROC
PROCEDURE _oncalendardblclick
*!* _OnCalendarDblClick()

This.ctlCalendarVisible = FALSE

This.ctlValue = This.ctlCalendar.ctlValue

This._SelectAll()

ENDPROC
PROCEDURE _onformclick
*!* _OnFormClick()

This.ctlCalendarVisible = FALSE
ENDPROC
PROCEDURE _onvalue
*!* _OnValue()

This.ctlValue = This._TextBox.Value


ENDPROC
PROCEDURE _selectall
*!* _SelectAll()

This.SelStart = 0
This.SelLength = Len(This.DisplayValue)

ENDPROC
PROCEDURE _setcontrolsource
*!* _SetControlSource()

Local lcTextBox As String

This._TextBox.ControlSource = This.ctlControlSource

If Not Empty(This.ctlControlSource) Then
	This.ctlValue = This._TextBox.Value
Endif


ENDPROC
PROCEDURE _setinputmask
*!* _SetInputMask()

Local ;
	m.lcYearMask As String, ;
	m.lcMask As String, ;
	m.lcMark As String

If Set("Century") = "ON" Then
	m.lcYearMask = "9999"
Else
	m.lcYearMask = "99"
Endif

m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))

Do Case
	Case Set("Date",1) = 0	&& MDY
		m.lcMask = "99" + m.lcMark + "99" + m.lcMark + m.lcYearMask
	Case Set("Date",1) = 1	&& DMY
		m.lcMask = "99" + m.lcMark + "99" + m.lcMark + m.lcYearMask
	Case Set("Date",1) = 2	&& YMD
		m.lcMask =  m.lcYearMask + m.lcMark + "99" + m.lcMark + "99"
Endcase

This.InputMask = m.lcMask

ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

If Not Empty(This.ctlControlSource) Then
	This._TextBox.Value = This.ctlValue
	Thisform.Refresh()
Endif

This.DisplayValue = Dtoc(This.ctlValue)

This._EnableUpdates = FALSE

If Empty(This.ctlValue) Then
	This.ctlCalendar.ctlValue = Date()
Else
	This.ctlCalendar.ctlValue = This.ctlValue
Endif

This._EnableUpdates = TRUE

Raiseevent(This, "ctlValueChanged")







ENDPROC
PROCEDURE _validate
*!* _Validate()

*!* Valid date ranges: 1753.01.01 to 9998.12.31

Local ;
	lcValue As String, ;
	lcMark As String, ;
	lnYear As Integer, ;
	lnMonth As Integer, ;
	lnDay As Integer, ;
	llError As Logical

m.lcValue = Alltrim(This.DisplayValue)
m.lcMark = Iif(Empty(Set("Mark")), "/", Set("Mark"))
m.llError = FALSE

If Not m.lcMark $ m.lcValue Then

	*!* if 2 digit value is greater than last day of current month,
	*!* assume 1 digit day, 1 digit month
	If Val(m.lcValue) < 100 And Val(m.lcValue) > Day(Gomonth(Date(Year(Date()), Month(Date()), 1), 1) - 1) Then
		m.lcValue = "0" + Left(m.lcValue, 1) + "0" + Right(m.lcValue, 1)
	Endif

	Do Case

			*!* 1 DIGIT: D
		Case Len(m.lcValue) = 1 And Set("Date", 1) = 0	&& mmdDyyyy
			m.lcValue = Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 1 And Set("Date", 1) = 1	&& dDmmyyyy
			m.lcValue = m.lcValue + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 1 And Set("Date", 1) = 2	&& yyyymmdD
			m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue

			*!* 2 DIGITS: DD
		Case Len(m.lcValue) = 2 And Set("Date", 1) = 0	&& mmDDyyyy
			m.lcValue = Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 2 And Set("Date", 1) = 1	&& DDmmyyyy
			m.lcValue = m.lcValue + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 2 And Set("Date", 1) = 2	&& yyyymmDD
			m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Transform(Month(Date()), "@L 99") + m.lcMark + m.lcValue

			*!* 3 DIGITS: DDM/DMM/MMD/MDD
			*!* there are 108 one digit days in a 365 days year: 30% one digit days
			*!* there are 9 one digit months in a 12 month year: 75% one digit months
			*!* so if we have a 3 digit date, let's assume the day is 2 digits and the month 1 digit,
			*!* except for special cases where we can safely assume there is a 2 digit month.
		Case Len(m.lcValue) = 3 And Set("Date", 1) = 0	&& MMdDyyyy or mMDDyyyyy
			If m.lcValue $ "101|102|103|104|105|106|107|108|109"
				m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1) + m.lcMark + Transform(Year(Date()), "@L 9999")
			Else
				m.lcValue = Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
			Endif

		Case Len(m.lcValue) = 3 And Set("Date", 1) = 1	&& DDmMyyyy or dDMMyyyy
			If m.lcValue $ "110|210|310|312|410|411|412|510|511|512|610|611|612|710|711|712|810|811|812|910|911|912"
				m.lcValue = Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")
			Else
				m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1) + m.lcMark + Transform(Year(Date()), "@L 9999")
			Endif

		Case Len(m.lcValue) = 3 And Set("Date", 1) = 2	&& yyyyMMdD or yyyymMDD
			If m.lcValue $ "101|102|103|104|105|106|107|108|109"
				m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 1)
			Else
				m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 1) + m.lcMark + Right(m.lcValue, 2)
			Endif

			*!* 4 DIGITS: DDMM/MMDD
		Case Len(m.lcValue) = 4 And Set("Date", 1) = 0	&& MMDDyyyy
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 4 And Set("Date", 1) = 1	&& DDMMyyyy
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2) + m.lcMark + Transform(Year(Date()), "@L 9999")

		Case Len(m.lcValue) = 4 And Set("Date", 1) = 2	&& yyyyMMDD
			m.lcValue = Transform(Year(Date()), "@L 9999") + m.lcMark + Left(m.lcValue, 2) + m.lcMark + Right(m.lcValue, 2)

			*!* 5 DIGITS: DDMMY/MMDDY/YMMDD
		Case Len(m.lcValue) = 5 And Set("Date", 1) = 0	&& MMDDyyyY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 1)

		Case Len(m.lcValue) = 5 And Set("Date", 1) = 1	&& DDMMyyyY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 1)

		Case Len(m.lcValue) = 5 And Set("Date", 1) = 2	&& yyyYMMDD
			m.lcValue = Left(m.lcValue, 1) + m.lcMark + Substr(m.lcValue, 2, 2) + m.lcMark + Right(m.lcValue, 2)

			*!* 6 DIGITS: DDMMYY/MMDDYY/YYMMDD
		Case Len(m.lcValue) = 6 And Set("Date", 1) = 0	&& MMDDyyYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)

		Case Len(m.lcValue) = 6 And Set("Date", 1) = 1	&& DDMMyyYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)

		Case Len(m.lcValue) = 6 And Set("Date", 1) = 2	&& yyYYMMDD
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 2)

			*!* 7 DIGITS: DDMMYYY/MMDDYYY/YYYMMDD
		Case Len(m.lcValue) = 7 And Set("Date", 1) = 0	&& MMDDyyYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 3)

		Case Len(m.lcValue) = 7 And Set("Date", 1) = 1	&& DDMMyyYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 3)

		Case Len(m.lcValue) = 7 And Set("Date", 1) = 2	&& yyYYMMDD
			m.lcValue = Left(m.lcValue, 3) + m.lcMark + Substr(m.lcValue, 4, 2) + m.lcMark + Right(m.lcValue, 2)

			*!* 8 DIGITS: DDMMYYYY/MMDDYYYY/YYYYMMDD
		Case Len(m.lcValue) = 8 And Set("Date", 1) = 0	&& MMDDYYYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 4)

		Case Len(m.lcValue) = 8 And Set("Date", 1) = 1	&& DDMMYYYY
			m.lcValue = Left(m.lcValue, 2) + m.lcMark + Substr(m.lcValue, 3, 2) + m.lcMark + Right(m.lcValue, 4)

		Case Len(m.lcValue) = 8 And Set("Date", 1) = 2	&& YYYYMMDD
			m.lcValue = Left(m.lcValue, 4) + m.lcMark + Substr(m.lcValue, 5, 2) + m.lcMark + Right(m.lcValue, 2)

	Endcase
Endif

Do Case
	Case Set("Date", 1) = 0	&& MDY
		*!* Extract month, day, year
		m.lnMonth 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
		m.lnDay 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
		m.lnYear 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
	Case Set("Date", 1) = 1	&& DMY
		*!* Extract day, month, year
		m.lnDay 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
		m.lnMonth 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
		m.lnYear 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
	Case Set("Date", 1) = 2	&& YMD
		*!* Extract year, month, day
		m.lnYear 	= Val(Getwordnum(m.lcValue, 1, m.lcMark))
		m.lnMonth 	= Val(Getwordnum(m.lcValue, 2, m.lcMark))
		m.lnDay 	= Val(Getwordnum(m.lcValue, 3, m.lcMark))
Endcase

*!* Add missing values
If m.lnMonth + m.lnDay + m.lnYear > 0 Then
	If m.lnMonth = 0 Then
		m.lnMonth = Month(Date())
	Endif
	If m.lnYear = 0 Then
		m.lnYear = Year(Date())
	Endif
Endif

*!* If year is less than 99, add century using ROLLOVER
If Between(m.lnYear, 1, 99) Then
	If m.lnYear >= Set("Century", 2) Then
		m.lnYear = m.lnYear + Set("Century", 1) * 100
	Else
		m.lnYear = m.lnYear + (Set("Century", 1) + 1) * 100
	Endif
Endif

If m.lnYear # 0 Then
	*!* Check year is between 1753, 9998 (gregorian calendar limits)
	If m.lnYear < 1753 Then
		m.llError = TRUE
		m.lnYear = 1753
	Endif
	If m.lnYear > 9998 Then
		m.llError = TRUE
		m.lnYear = 9998
	Endif
Endif

If m.lnMonth # 0 Then
	*!* Check month is between 1, 12
	If m.lnMonth < 1 Then
		m.llError = TRUE
		m.lnMonth = 1
	Endif
	If m.lnMonth > 12 Then
		m.llError = TRUE
		m.lnMonth = 12
	Endif
Endif

If m.lnDay # 0 Then
	*!* Check day is between 1, 31
	If m.lnDay < 1 Then
		m.llError = TRUE
		m.lnDay = 1
	Endif
	If m.lnDay > 31 Then
		m.llError = TRUE
		m.lnDay = 31
	Endif

	*!* Check day is not > than last day of entered month
	*!* GOMONTH() does not support dates earlier than 1753.
	If m.lnYear # 0 And m.lnMonth # 0 Then
		If m.lnDay > Day(Gomonth(Date(m.lnYear, m.lnMonth, 1), 1) - 1) Then
			m.llError = TRUE
			m.lnDay = Day(Gomonth(Date(m.lnYear, m.lnMonth, 1), 1) - 1)
		Endif
	Endif
Endif

If m.lnYear # 0 And m.lnMonth # 0 And m.lnDay # 0 Then
	This.ctlValue = Date(m.lnYear, m.lnMonth, m.lnDay)
Else
	This.ctlValue = {}
Endif

If m.llError Then
	??Chr(7)
Endif

ENDPROC
PROCEDURE controlsource_assign
lparameters tuNewValue
*This.ControlSource = tuNewValue

ENDPROC
PROCEDURE ctlcalendarvisible_assign
*!* ctlCalendarVisible_Assign()

Lparameters tuNewValue

This.ctlCalendarVisible = m.tuNewValue


If This.ctlCalendarVisible = TRUE Then

	This.ToolTipText = ""

	This.ctlCalendar.Top = Objtoclient(This, 1) + This.Height
	This.ctlCalendar.Left = Objtoclient(This, 2)

	If This.ctlCalendar.Top + This.ctlCalendar.Height > Thisform.Height Then
		This.ctlCalendar.Top = Objtoclient(This, 1) - This.ctlCalendar.Height
	Endif

	If This.ctlCalendar.Left + This.ctlCalendar.Width > Thisform.Width Then
		This.ctlCalendar.Left = This.ctlCalendar.Left - (This.ctlCalendar.Width - This.Width)
	Endif

This.ctlCalendar.ctlBorderColor = This._GetBorderColor()

Endif

This.ctlCalendar.ctlVisible = m.tuNewValue

ENDPROC
PROCEDURE ctlcontrolsource_assign
*!* ctlControlSource_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlControlSource # m.tuNewValue Then
	This.ctlControlSource = m.tuNewValue
	This._SetControlSource()
Endif
ENDPROC
PROCEDURE ctlfocused_access
*!* ctlFocused_Access()

Return This._Focused

ENDPROC
PROCEDURE ctlmaxdate_assign
*!* ctlMaxDate_Assign()

Lparameters tuNewValue

This.ctlMaxDate = m.tuNewValue

This.ctlCalendar.ctlMaxDate = This.ctlMaxDate

ENDPROC
PROCEDURE ctlmindate_assign
*!* ctlMinDate_Assign()

Lparameters tuNewValue

This.ctlMinDate = m.tuNewValue

This.ctlCalendar.ctlMinDate = This.ctlMinDate

ENDPROC
PROCEDURE ctlvalue_assign
*!* ctlValue_Assign(nValue)

Lparameters m.tuNewValue

Local llError As Boolean

m.llError = FALSE

If Not Empty(m.tuNewValue)
	If m.tuNewValue < This.ctlMinDate Then
		m.tuNewValue = This.ctlMinDate
		m.llError = TRUE
	Endif

	If m.tuNewValue > This.ctlMaxDate Then
		m.tuNewValue = This.ctlMaxDate
		m.llError = TRUE
	Endif
Endif

If This.ctlValue # m.tuNewValue Then
	If This.ctlUseDateTime = TRUE And Vartype(m.tuNewValue) # T_DATETIME Then
		This.ctlValue = Dtot(m.tuNewValue)
	Else
		This.ctlValue = m.tuNewValue
	Endif
	This._SetValue()
Else
	This.DisplayValue = Dtoc(This.ctlValue)
Endif

If This.ctlCalendarVisible = FALSE Then
	This.ToolTipText = " " + ctlGetDateFormatEx(m.tuNewValue) + " "
Endif

If m.llError Then
	??Chr(7)
Endif

ENDPROC
PROCEDURE value_access
*!* Value_Access()

Return This.ctlValue

ENDPROC
PROCEDURE value_assign
*!* Value_Assign()

Lparameters tuNewValue
This.ctlValue = m.tuNewValue

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_bindevents 
*_getbordercolor 
*_initlibrary 
*_oncalendarctlvaluechanged 
*_oncalendardblclick 
*_onformclick 
*_onvalue 
*_selectall 
*_setcontrolsource 
*_setinputmask 
*_setvalue 
*_validate 
*controlsource_assign 
*ctlcalendarvisible_assign 
*ctlcontrolsource_assign 
*ctlfocused_access 
*ctlmaxdate_assign 
*ctlmindate_assign 
*ctlvalue_assign 
*ctlvaluechanged 
*value_access 
*value_assign 
_dropdown
_enableupdates
_focused
_markkeypressed
_memberdata XML Metadata for customizable properties
_shadow
_textbox
ctlcalendar
ctlcalendarvisible
ctlcontrolsource Specifies the source of data to which an object is bound.
ctlfocused
ctlmaxdate Gets or sets the maximum date and time that can be selected in the control.
ctlmindate Gets or sets the minimum date and time that can be selected in the control.
ctlusedatetime .F.
ctluseinputmask
ctlvalue
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_datepicker
[START PROPERTIES]
Tahoma, 0, 8, 5, 13, 11, 21, 2, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _22514AP8B
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_formstate
[START PROPERTIES]

BackColor = 140,200,200
Height = 23
Name = "ctl32_formstate"
Visible = .F.
Width = 96
_autocenter = .F.
_clearstate = .F.
_memberdata =     1301<VFPData><memberdata name="ctlwindowstate" type="property" display="ctlWindowState" favorites="True"/><memberdata name="_windowstate" type="property" display="_WindowState"/><memberdata name="ctlrestoretoprimary" type="property" display="ctlRestoreToPrimary" favorites="True"/><memberdata name="ctlclearstate" type="method" display="ctlClearState" favorites="True"/><memberdata name="ctlhideminimized" type="property" display="ctlHideMinimized" favorites="True"/><memberdata name="ctlrestoremaxstate" type="property" display="ctlRestoreMaxState" favorites="True"/><memberdata name="ctlrestoreminpos" type="property" display="ctlRestoreMinPos" favorites="True"/><memberdata name="ctlautocenter" type="property" display="ctlAutoCenter" favorites="True"/><memberdata name="ctlrestoreminstate" type="property" display="ctlRestoreMinState" favorites="True"/><memberdata name="ctlrestorestate" type="method" display="ctlRestoreState" favorites="True"/><memberdata name="ctlrestorestateinide" type="property" display="ctlRestoreStateInIde" favorites="True"/><memberdata name="ctlrestorestyle" type="property" display="ctlRestoreStyle" favorites="True"/><memberdata name="_savestate" type="method" display="_SaveState"/><memberdata name="anchor" type="property" favorites="True" display="Anchor"/></VFPData>
_registrysubkey = FormState
_registryvaluename = 
_windowstate = 0
ctlautocenter = .F.
ctlhideminimized = .F.
ctlrestoremaxstate = .T.
ctlrestoreminpos = .F.
ctlrestoreminstate = .F.
ctlrestorestateinide = .T.
ctlrestorestyle = 1
ctlrestoretoprimary = .F.
ctlwindowstate = 0
[END PROPERTIES]
[START PROTECTED]
_addobjects^
_addproperties^
_autocenter^
_bindevents^
_clearstate^
_getstatefromregistry^
_getstatefromwindow^
_moveform^
_onformshow0^
_onformshow1^
_restorestateafterformshow^
_restorestatebeforeformshow^
_savestate^
_windowstate^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*!* Destroy

This._SaveState()
ENDPROC
PROCEDURE Init
*!* Init

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

*!* Add Objects
This._AddObjects()

*!* Add properties:
This._AddProperties()

*!* Decide when we are going to do the form state restore:
If This._FormType = CON_FORMTYPE_SCREEN Then
	*!* This.ctlRestoreState() should be called in main program,
	*!* After setting properties of class like ctlRestoreStyle, etc
Else
	*!* Form is not the Screen, bind to SHOW event of form:
	If Thisform.WindowType = 0 Then
		This._BindEvents()
	Endif
Endif






ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* Add registry object
This.AddObject("oRegistry", "ctl32_Registry")

*!* Define MonitorInfoEx Object
This.AddObject("oMonitorInfoEx", "ctlMonitorInfoEx")

*!* Define object to hold windowplacement data of form
This.AddObject("oWindowPlacement", "ctlWindowPlacement")


ENDPROC
PROCEDURE _addproperties
*!* _AddProperties()

*!* Specifies if the form should be restored to maximized state:
This.AddProperty("_Maximized", FALSE)

*!* Stores the hWnd of the host window
This.AddProperty("_hWnd", 0)

*!* Stores Form Type:
This.AddProperty("_FormType", ctlGetFormType(Thisform))

*!* Save form HWnd or VFP HWnd if form is _Screen:
If This._FormType = CON_FORMTYPE_SCREEN Then
  This._HWnd = _vfp.HWnd
Else
  This._HWnd = Thisform.HWnd
Endif


ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

Bindevent(Thisform, "Init", This, "_OnFormInit", 1)
Bindevent(Thisform, "Show", This, "_OnFormShow0", 0)
Bindevent(Thisform, "Show", This, "_OnFormShow1", 1)

ENDPROC
PROCEDURE _generateformid
*!* _GenerateFormId()

*!* Try to generate a unique ID for this form, based on the checksum
*!* of the names off some of the objects in the form

Local ;
	lcId As String, ;
	loControl As Control, ;
	loSubControl As Control

m.lcId = ""

*!* We just recurse one level
For Each m.loControl In Thisform.Objects
	*!* Prevent sys(2015) names
	If (Len(m.loControl.Name) = 10 And Left(m.loControl.Name, 1) = "_")  = FALSE Then
		m.lcId = m.lcId + m.loControl.Name
	Endif

	If Pemstatus(m.loControl, "Objects", 5) Then
		For Each m.loSubControl In Thisform.Objects
			*!* Prevent sys(2015) names
			If (Len(m.loControl.Name) = 10 And Left(m.loControl.Name, 1) = "_")  = FALSE Then
				m.lcId = m.lcId + m.loControl.Name
			Endif
		Endfor
	Endif

Endfor

m.lcId = m.lcId + Thisform.Name

m.lcId = Padl(Sys(2007, m.lcId, 0, 1), 10, "0")

Return m.lcId

ENDPROC
PROCEDURE _getstatefromregistry
*!* _GetStateFromRegistry()

*!* We get the current state of form, save values in This.oWindowPlacement
This._GetStateFromWindow()

Local lcWindowPlacement As String

m.lcWindowPlacement = This.oWindowPlacement.Value

*!* Get registry data, if any, use actual form data as default

m.lcWindowPlacement = This.oRegistry.GetValue(Addbs(This._RegistrySubKey) + This._RegistryValueName, m.lcWindowPlacement)

This.oWindowPlacement.Value = m.lcWindowPlacement

ENDPROC
PROCEDURE _getstatefromwindow
*!* _GetStateFromWindow()

Local lcWindowPlacement As String

m.lcWindowPlacement = This.oWindowPlacement.Value

*!* Retrieve current WindowPlacement data from Form:
apiGetWindowPlacement(This._HWnd, @m.lcWindowPlacement)

This.oWindowPlacement.Value = m.lcWindowPlacement


ENDPROC
PROCEDURE _moveform
*!* _MoveForm()

*!* Set form/Screen out of view to prevent flicker:
If This._FormType = CON_FORMTYPE_DEFAULT Then
	Thisform.Left = - Thisform.Width - Sysmetric(4) * 2
	Thisform.Top = - Thisform.Height - Sysmetric(9) - Sysmetric(4)
Else
	Thisform.Left = apiGetSystemMetrics(SM_XVIRTUALSCREEN) - Thisform.Width - Sysmetric(4) * 2
	Thisform.Top = apiGetSystemMetrics(SM_YVIRTUALSCREEN) - Thisform.Height - Sysmetric(9) - Sysmetric(4)
Endif


ENDPROC
PROCEDURE _onforminit
*!* _OnFormInit()
Lparameters param1, param2, param3, param4, param5, param6, param7, param8, param9, param10

This._RegistryValueName =This._GenerateFormId()

ENDPROC
PROCEDURE _onformshow0
*!* _BeforeFormShow

*!* This procedure should only run once in the form life:
Unbindevent(Thisform, "Show", This, "_OnFormShow0")

This._RestoreStateBeforeFormShow()

ENDPROC
PROCEDURE _onformshow1
*!* _AfterFormShow

*!* This procedure should only run once in the form life:
Unbindevent(Thisform, "Show", This, "_OnFormShow1")

*!* After the form is displayed, but out of view , we restore its state:
*!* (check _BeforeFormShow and _MoveForm)
This._RestoreStateAfterFormShow()

ENDPROC
PROCEDURE _restorestateafterformshow
*!* _RestoreStateAfterFormShow()

Local ;
	loRect As ctlRect, ;
	lcRect As String, ;
	lnHeight As Integer, ;
	lnWidth As Integer, ;
	lnParentHeight As Integer, ;
	lnParentWidth As Integer, ;
	loParentForm As Form, ;
	lnHMonitor, ;
	lcMonitorInfoEx, ;
	lnResult, ;
	lcWindowPlacement As String

m.loRect = Createobject("ctlRect")

*!* 20080329 commented out
*!* Define object to hold data of parent window of form:
*!* This.AddObject("oParentRect", "ctlRect")

*!* After the form is displayed

*!* ctlRestoreStyle values: 0, 1, 2, 3
If This.ctlRestoreStyle = 0 Then
	Return
Endif

*!* If we are in the IDE, dont do anything unless
*!* ctlRestoreStateInIde is set
If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
	Return
Endif

*!* 20080329 Modified, add form rect calculation
*!* Check if form does not have sizeable border, use form default size then:
If Thisform.BorderStyle <> 3 Then
	*!* Get current form rect, so we dont have to add title bar height, etc
	m.lcRect = m.loRect.Value
	apiGetWindowRect(Thisform.HWnd,@m.lcRect)
	m.loRect.Value = m.lcRect

	With This.oWindowPlacement.rcNormalPosition
		.Right = .Left + m.loRect.Width
		.Bottom = .Top + m.loRect.Height
	Endwith
Endif

*!* Always set minimized form coordinates:

This.oWindowPlacement.Flags = Bitset(This.oWindowPlacement.Flags, WPF_SETMINPOSITION - 1)

*!*	Check if minimized WindowState Status should be restored:
If This.ctlRestoreMinState = FALSE Or Thisform.MinButton = FALSE Then
	If This.oWindowPlacement.ShowCmd = SW_SHOWMINIMIZED
		If Bittest(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1) = TRUE
			This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
		Else
			This.oWindowPlacement.ShowCmd = SW_SHOWNORMAL
		Endif
	Endif
Endif

*!*	Check if maximized WindowState Status should be restored:
If This.ctlRestoreMaxState = FALSE Or Thisform.MaxButton = FALSE Then
	If Bittest(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1) = TRUE Then
		Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
		This.oWindowPlacement.Flags = Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
		If This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
			This.oWindowPlacement.ShowCmd = SW_SHOWNORMAL
		Endif
	Endif
Endif

*!* Should form always show minimized
If This._WindowState = 1 And Thisform.MinButton = TRUE Then
	This.oWindowPlacement.Flags = Bitclear(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
	This.oWindowPlacement.ShowCmd = SW_SHOWMINIMIZED
Endif

*!* Should form always show maximized
If This._WindowState = 2 And Thisform.MaxButton = TRUE Then
	This.oWindowPlacement.Flags = Bitset(This.oWindowPlacement.Flags, WPF_RESTORETOMAXIMIZED - 1)
	This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED
Endif

*!* Check if minimized WindowState Position should be restored:
If This.ctlRestoreMinPos = FALSE Then
	This.oWindowPlacement.ptMinPosition.X = -1
	This.oWindowPlacement.ptMinPosition.Y = -1
Endif

*!* Check if minimized form should be hidden:
If This.ctlHideMinimized = TRUE Then
	*!* set minimized WindowState Position out of screen:
	This.oWindowPlacement.ptMinPosition.X = 0
	This.oWindowPlacement.ptMinPosition.Y = apiGetSystemMetrics(SM_YVIRTUALSCREEN) + ;
		apiGetSystemMetrics(SM_CYVIRTUALSCREEN)
Endif

*!*	 We will maximize the form now if needed:
If This.oWindowPlacement.ShowCmd = SW_SHOWMAXIMIZED Then
	If This._FormType = CON_FORMTYPE_DEFAULT
		Thisform.WindowState = WINDOWSTATE_MAXIMIZED
	Else
		If apiGetSystemMetrics(SM_CMONITORS) = 1 Then
			Thisform.WindowState = WINDOWSTATE_MAXIMIZED
		Else
			This.oWindowPlacement.ShowCmd = SW_SHOW
			This._Maximized = TRUE
		Endif
	Endif
Endif

*!* Get parent form container coordinates, if this is a standard
*!* form, get coordinates of parent Top Level Form or Screen
*!* if this is a Top Level Form or Screen, get coordinates of Windows
*!* Desktop

If This._FormType = CON_FORMTYPE_DEFAULT Then
	*!* we have a standard form, get coordinates of parent.
	*!* Parent can be a Top Level Form or the VFP _Screen
	m.loParentForm = ctlGetParentForm(Thisform)

	*!* Save parent position/size:
	With m.loRect
		.Left = 0
		.Top = 0
		.Right = m.loParentForm.Width
		.Bottom = m.loParentForm.Height
	Endwith
	m.loParentForm = .Null.
Else
	*!* We have a Top Level Form or the _Screen

	*!* We already have the form Rect stored in last 16 bytes of This.oWindowPlacement.Value

	*!* Get work space Rect of monitor that contains most of form Rect,
	*!* or the nearest monitor, if form Rect is not in any monitor

	m.lcRect = Right(This.oWindowPlacement.Value, 16)
	m.lcMonitorInfoEx = This.oMonitorInfoEx.Value

	If This.ctlRestoreToPrimary = TRUE Then
		*!* Form should restore to primary monitor if form Rect is outside any monitor:
		m.lnHMonitor = apiMonitorFromRect(@m.lcRect, MONITOR_DEFAULTTONULL)

		If m.lnHMonitor = Null Then
			m.lnHMonitor = apiMonitorFromRect(@m.lcRect, MONITOR_DEFAULTTOPRIMARY)
		Endif
	Else
		*!* Get nearest monitor to form Rect:
		m.lnHMonitor = apiMonitorFromRect(@m.lcRect, MONITOR_DEFAULTTONEAREST)
	Endif

	m.lnResult = apiGetMonitorInfo(m.lnHMonitor, @m.lcMonitorInfoEx)

	If m.lnResult <> 0 Then
		*!* GetMonitorInfo success!
		This.oMonitorInfoEx.Value = m.lcMonitorInfoEx
		With m.loRect
			.Left = This.oMonitorInfoEx.rcWork.Left
			.Top = This.oMonitorInfoEx.rcWork.Top
			.Right = This.oMonitorInfoEx.rcWork.Right
			.Bottom = This.oMonitorInfoEx.rcWork.Bottom
		Endwith
		m.lnHMonitor = Null

	Else
		*!* GetMonitorInfo failed, use primary monitor info
		With m.loRect
			.Left = 0
			.Top = 0
			.Right = Sysmetric(SYSMETRIC_CLIENTWIDTH)
			** BUG! VFP reports this as too small, add one title bar height to value:
			.Bottom = Sysmetric(SYSMETRIC_CLIENTHEIGHT) + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT)
		Endwith
	Endif

Endif

*!* Now adjust form position depending on ctlRestoreStyle:
With This

	*!* Just move form barely into view if needed:
	If .ctlRestoreStyle = 1 Then
		*!* Move up, display title bar
		If .oWindowPlacement.rcNormalPosition.Top > m.loRect.Bottom - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) Then
			m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
			.oWindowPlacement.rcNormalPosition.Top = m.loRect.Bottom - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) - Sysmetric(SYSMETRIC_SIZINGBORDERHEIGHT)
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
		Endif

		*!* Move left, 4 title bar heights, if needed
		If .oWindowPlacement.rcNormalPosition.Left > m.loRect.Right - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 4 Then
			m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
			.oWindowPlacement.rcNormalPosition.Left = m.loRect.Right - Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 4
			.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
		Endif

		*!* Move down, display title bar
		If .oWindowPlacement.rcNormalPosition.Top < m.loRect.Top Then
			m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
			.oWindowPlacement.rcNormalPosition.Top = m.loRect.Top
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
		Endif

		*!* 20070901 make it 5 title bar heights to account for vista buttons
		*!* Move right, 4 title bar heights
		If .oWindowPlacement.rcNormalPosition.Right <= m.loRect.Left + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 6 Then
			m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
			.oWindowPlacement.rcNormalPosition.Right = m.loRect.Left + Sysmetric(SYSMETRIC_WINDOWTITLEHEIGHT) * 6
			.oWindowPlacement.rcNormalPosition.Left = .oWindowPlacement.rcNormalPosition.Right - m.lnWidth
		Endif
	Endif

	*!* Move form fully into view if needed
	If .ctlRestoreStyle >= 2 Then
		*!* Move up
		If .oWindowPlacement.rcNormalPosition.Bottom > m.loRect.Bottom Then
			m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
			.oWindowPlacement.rcNormalPosition.Top = m.loRect.Bottom - m.lnHeight
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
		Endif

		*!* Move left
		If .oWindowPlacement.rcNormalPosition.Right > m.loRect.Right Then
			m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
			.oWindowPlacement.rcNormalPosition.Left = m.loRect.Right - m.lnWidth
			.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
		Endif

		*!* Move down
		If .oWindowPlacement.rcNormalPosition.Top < m.loRect.Top Then
			m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
			.oWindowPlacement.rcNormalPosition.Top = m.loRect.Top
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
		Endif

		*!* Move right
		If .oWindowPlacement.rcNormalPosition.Left < m.loRect.Left Then
			m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
			.oWindowPlacement.rcNormalPosition.Left = m.loRect.Left
			.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
		Endif
	Endif

	*!* Adjust form size to fit in parent, form already moved into view:
	If .ctlRestoreStyle = 3 .And. Thisform.BorderStyle = 3 Then

		m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
		m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
		m.lnParentHeight = m.loRect.Bottom - m.loRect.Top
		m.lnParentWidth = m.loRect.Right - m.loRect.Left

		*!* Adjust height
		If m.lnHeight > m.lnParentHeight Then
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnParentHeight
		Endif

		*!* Adjust width
		If m.lnWidth > m.lnParentWidth Then
			.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnParentWidth
		Endif
	Endif

	*!* Center if requested:
	If This._AutoCenter = TRUE Then

		m.lnHeight = .oWindowPlacement.rcNormalPosition.Height
		m.lnWidth = .oWindowPlacement.rcNormalPosition.Width
		m.lnParentHeight = m.loRect.Bottom - m.loRect.Top
		m.lnParentWidth = m.loRect.Right - m.loRect.Left

		If m.lnWidth < m.lnParentWidth Then
			.oWindowPlacement.rcNormalPosition.Left = Int(m.lnParentWidth / 2 - m.lnWidth / 2) + m.loRect.Left
			.oWindowPlacement.rcNormalPosition.Right = .oWindowPlacement.rcNormalPosition.Left + m.lnWidth
		Endif
		If m.lnHeight < m.lnParentHeight Then
			.oWindowPlacement.rcNormalPosition.Top = Int(m.lnParentHeight / 2 - m.lnHeight / 2) + m.loRect.Top
			.oWindowPlacement.rcNormalPosition.Bottom = .oWindowPlacement.rcNormalPosition.Top + m.lnHeight
		Endif
	Endif
Endwith

m.lcWindowPlacement = This.oWindowPlacement.Value

*!* Send structure to form:
apiSetWindowPlacement(This._HWnd, @m.lcWindowPlacement)

If This._Maximized = TRUE Then
	Thisform.WindowState = WINDOWSTATE_MAXIMIZED
Endif


m.loRect = .Null.

ENDPROC
PROCEDURE _restorestatebeforeformshow
*!* _RestoreStateBeforeFormShow()

*!* Before the form is displayed

*!* ctlRestoreStyle values: 0, 1, 2, 3
If This.ctlRestoreStyle = 0 Then
	Return
Endif

*!* If we are in the IDE, dont do anything unless
*!* ctlRestoreStateInIde is set
If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
	Return
Endif

*!* Setup some values based in saved data existance:

If This.oRegistry.SeekValue(Addbs(This._RegistrySubKey) + This._RegistryValueName) = TRUE Then
	This._AutoCenter = This.ctlAutoCenter
	This._WindowState = This.ctlWindowState
Else
	This._AutoCenter = Thisform.AutoCenter Or This.ctlAutoCenter
	This._WindowState = Max(Thisform.WindowState, This.ctlWindowState)
Endif

Thisform.WindowState = 0

If Thisform.MaxButton = FALSE And This._WindowState = 2 Then
	This._WindowState = 0
Endif

*!* Get form state Data from registry:
This._GetStateFromRegistry()

*!* Just before form displays, we send it out of view to prevent flicker
This._MoveForm()

ENDPROC
PROCEDURE _savestate
*!* _SaveState()

Local lcWindowPlacement As String

*!* ctlRestoreStyle values: 0, 1, 2, 3
If This.ctlRestoreStyle = 0 Then
	Return
Endif

*!* If we are in the IDE, dont do anything unless
*!* ctlRestoreStateInIde is set
If _vfp.StartMode = 0 .And. This.ctlRestoreStateInIDE = FALSE Then
	Return
Endif

*!* Check if registry data was deleted:
If This._ClearState = TRUE Then
	Return
Endif

This._GetStateFromWindow()

If This.ctlHideMinimized = TRUE Then
	*!* Restore minimized coordinates to default, so as not to save
	*!* off-screen coordinates:
	This.oWindowPlacement.ptMinPosition.x = -1
	This.oWindowPlacement.ptMinPosition.Y = -1
Endif

m.lcWindowPlacement = This.oWindowPlacement.Value

*!* Store data in Windows registry:
This.oRegistry.SetValue(Addbs(This._RegistrySubKey) + This._RegistryValueName, m.lcWindowPlacement)

ENDPROC
PROCEDURE ctlclearstate
*!* ctlClearState()

*!* Deletes state data from registry and prevents saving on exit

This.oRegistry.DeleteValue(Addbs(This._RegistrySubKey) + This._RegistryValueName)

This._ClearState = TRUE

ENDPROC
PROCEDURE ctlrestorestate
*!* ctlRestoreState()

If This._FormType = CON_FORMTYPE_SCREEN Then
  *!* Move VFP window out of sight:
  This._RestoreStateBeforeFormShow()
  *!* _Screen should start hidden via SCREEN=OFF in config.fpw
  _Screen.Visible = TRUE
  This._RestoreStateAfterFormShow()
Endif



ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_addproperties 
*_bindevents 
*_generateformid 
*_getstatefromregistry 
*_getstatefromwindow 
*_moveform 
*_onforminit 
*_onformshow0 
*_onformshow1 
*_restorestateafterformshow 
*_restorestatebeforeformshow 
*_savestate 
*ctlclearstate Removes the state data from the registry.
*ctlrestorestate 
_autocenter
_clearstate
_memberdata XML Metadata for customizable properties
_registrysubkey
_registryvaluename Specifies the value name to use for storing form data in the registry
_windowstate
ctlautocenter Specifies if the Form should be always be displayed centered, regardless of the saved settings.
ctlhideminimized Specifies if the minimized form should be hidden.
ctlrestoremaxstate Specifies if the maximized state of the form should be restored.
ctlrestoreminpos Specifies if the minimized position of the form should be restored.
ctlrestoreminstate Specifies if the minimized state of the form should be restored.
ctlrestorestateinide Specifies if form settings should be saved/restored while using IDE.
ctlrestorestyle Specifies how the forms settings should be restored. 0: No restore. 1: Restore and move form into view 2: Move form fully into view 3: Resize to fit.
ctlrestoretoprimary Specifies if the form should be restored in the primary monitor if it is out of the vistual screen area. For top level forms only.
ctlwindowstate Especifies the initial Form State, regardless of the saved settings.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _22A02124X
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_formstate
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_formstate"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Left = 6
Name = "lblname"
Top = 4
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_formstate

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _24N142DQT
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_ftp
[START PROPERTIES]
BackColor = 140,200,200
Height = 21
Name = "ctl32_ftp"
Visible = .F.
Width = 96
ctlabout = ctl32_ftp
ctlversion = 20070800
flagcacheasync = .F.
flagcacheifnetfail = .F.
flaghyperlink = .F.
flagneedfile = .F.
flagnocachewrite = .F.
flagpassive = .F.
flagreload = .F.
flagresynchronize = .F.
flagtransferbinary = .T.
ftpcommanddata = 
ftperrorcode = 0
ftperrorfunction = 
ftperrortext = 
ftpfiledata = 
ftpfileinfo = 
ftppassword = 
ftpresponsecode = 0
ftpresponsefunction = 
ftpresponsetext = 
ftptransfercancelled = .F.
ftptransferinfo = 
ftptransferpaused = .F.
ftpusername = 
hconnect = 0
hfile = 0
hfind = 0
hftpcommand = 0
hinternet = 0
internetaccesstype = 0
internetflagasync = .F.
internetflagfromcache = .F.
internetflagoffline = .F.
internetproxybypass = <local>
internetproxyname = 
internetuseragent = Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)
optiondebug = .F.
urlextrainfo = 
urlhostname = 
urlpassword = 
urlpath = 
urlport = 0
urlschemecode = 0
urlschemename = 
urltext = 
urlusername = 
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
This.OptionDebug = FALSE

This._Destroying = TRUE

This.InternetClose()


ENDPROC
PROCEDURE Init
*!* Init

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

This._AddObjects()
This._AddProperties()
This._SetProperties()

ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* Add File Info object
*This.AddProperty("oWin32FindData", Createobject("ctlStrwin32FindData"))

This.AddProperty("FtpTransferInfo", Createobject("Empty"))

AddProperty(This.FtpTransferInfo, "FtpRemoteFile", "")
AddProperty(This.FtpTransferInfo, "FtpBytesTotal", 0)
AddProperty(This.FtpTransferInfo, "FtpBytesComplete", 0)
AddProperty(This.FtpTransferInfo, "FtpBytesLeft", 0)
AddProperty(This.FtpTransferInfo, "FtpBytesPercent", 0)
AddProperty(This.FtpTransferInfo, "FtpBytesSpeed", 0)
AddProperty(This.FtpTransferInfo, "FtpTimeTotal", 0)
AddProperty(This.FtpTransferInfo, "FtpTimeElapsed", 0)
AddProperty(This.FtpTransferInfo, "FtpTimeLeft", 0)
AddProperty(This.FtpTransferInfo, "FtpStatus", FALSE)

This.AddProperty("FtpFileInfo", Createobject("Empty"))

With This
	AddProperty(.FtpFileInfo, "FileName", "")
	AddProperty(.FtpFileInfo, "FilePath", "")
	AddProperty(.FtpFileInfo, "FileShortName", "")
	AddProperty(.FtpFileInfo, "FileSize", 0)
	AddProperty(.FtpFileInfo, "FileCreationTime", 0)
	AddProperty(.FtpFileInfo, "FileLastAccessTime", 0)
	AddProperty(.FtpFileInfo, "FileLastWriteTime", 0)
	AddProperty(.FtpFileInfo, "FileAttribute", Createobject("Empty"))
	AddProperty(.FtpFileInfo, "Adir1", 0)
	AddProperty(.FtpFileInfo, "Adir2", 0)
	AddProperty(.FtpFileInfo, "Adir3", 0)
	AddProperty(.FtpFileInfo, "Adir4", 0)
	AddProperty(.FtpFileInfo, "Adir5", 0)
Endwith

With This.FtpFileInfo
	AddProperty(.FileAttribute, "Archive", FALSE)
	AddProperty(.FileAttribute, "Compressed", FALSE)
	AddProperty(.FileAttribute, "Directory", FALSE)
	AddProperty(.FileAttribute, "Encrypted", FALSE)
	AddProperty(.FileAttribute, "Hidden", FALSE)
	AddProperty(.FileAttribute, "Normal", FALSE)
	AddProperty(.FileAttribute, "NotContentIndexed", FALSE)
	AddProperty(.FileAttribute, "Offline", FALSE)
	AddProperty(.FileAttribute, "ReadOnly", FALSE)
	AddProperty(.FileAttribute, "ReparsePoint", FALSE)
	AddProperty(.FileAttribute, "SparseFile", FALSE)
	AddProperty(.FileAttribute, "System", FALSE)
	AddProperty(.FileAttribute, "Temporary", FALSE)
	AddProperty(.FileAttribute, "Virtual", FALSE)
Endwith

ENDPROC
PROCEDURE _addpath
*!* _AddPath(cFileName)

*!* Adds the current ftp directory path to a filename

Lparameters m.tcFileName As String

Local ;
	lcFileName As String, ;
	lcFilePath As String, ;
	lcFileName As String, ;
	lcCurrentDirectory As String

m.lcFileName = Alltrim(m.tcFileName)
m.lcFilePath = Justpath(m.lcFileName)
m.lcFileName = Justfname(m.lcFileName)

*!* if no path in lcFilePath, use current FTP directory:
If Empty(m.lcFilePath) Then

	m.lcCurrentDirectory = ""

	If This.FtpGetCurrentDirectory(@m.lcCurrentDirectory) = TRUE Then
		m.lcFilePath = This.FtpAddfs(m.lcCurrentDirectory)
	Else
		m.lcFilePath = "/"
	Endif

Else
	*!* Add a forward slash if needed at the end of lcFilePath:
	m.lcFilePath = This.FtpAddfs(m.lcFilePath)
Endif

m.lcFileName =  m.lcFilePath + m.lcFileName

Return m.lcFileName

ENDPROC
PROCEDURE _addproperties
*!* Save Kernel32.dll module handle:
This.AddProperty("_hKernel32", apiGetModuleHandle("kernel32.dll"))

*!* Save WinInet.dll module handle:
This.AddProperty("_hWinInet", apiGetModuleHandle("wininet.dll"))

*!* Indicates if the Destroy event is happening:
This.AddProperty("_Destroying", FALSE)

ENDPROC
PROCEDURE _addtoarray
*!* _AddToArray()

*!* This method is called by FtpDirToArray, adds one array row to the FtpFiles array
*!* The file info is stored in the FtpFileInfo object, and was filled by _FtpFindFile()

*!* The FtpFiles array mimics the array created by the Adir VFP function, with the
*!* only difference that the complete file spec is stored in the first column, file path
*!* and name. Also "/" is used instead of "\", as "/" is used in FTP servers.

Lparameters m.tnIndex As Integer

If m.tnIndex = 0 Then
	Dimension This.FtpFiles(1, 5)
	This.FtpFiles(1, 1) = ".."
	This.FtpFiles(1, 2) = 0
	This.FtpFiles(1, 3) = Date()
	This.FtpFiles(1, 4) = This.FormatSeconds(Seconds())
	This.FtpFiles(1, 5) = "....D"

Else

	m.tnIndex = m.tnIndex + 1

	Dimension This.FtpFiles(m.tnIndex, 5)

	This.FtpFiles(m.tnIndex, 1) = This.FtpFileInfo.Adir1
	This.FtpFiles(m.tnIndex, 2) = This.FtpFileInfo.Adir2
	This.FtpFiles(m.tnIndex, 3) = This.FtpFileInfo.Adir3
	This.FtpFiles(m.tnIndex, 4) = This.FtpFileInfo.Adir4
	This.FtpFiles(m.tnIndex, 5) = This.FtpFileInfo.Adir5

Endif


ENDPROC
PROCEDURE _clearlasterror
*!* _ClearLastError()

This.FtpErrorFunction = ""
This.FtpErrorCode	 = 0
This.FtpErrorText	 = ""


ENDPROC
PROCEDURE _clearlastresponse
*!* _ClearLastResponse()

This.FtpResponseFunction = ""
This.FtpResponseCode	 = 0
This.FtpResponseText	 = ""
ENDPROC
PROCEDURE _fillftpfileinfo



ENDPROC
PROCEDURE _ftpfindfile
*!* _FtpFindFile(cFileSkeleton)

*!* This method is called by FtpDirToArray as FtpGetFileInfo
*!* cFileSkeleton ALWAYS includes the full path at this stage

*!* _FtpFindFile encapsulates the use of FtpFindFirstFile and the following
*!* InternetFindNextFile calls into one Method

*!* FtpFindFile just encapsulates a simple LIST command to the FTP server.
*!* subsequent calls to InternetFindNextFile gives us that list one by one
*!* This is an attempt by MS to emulate the functions for local files

*!* WARNING! The file size returned by these functions is limited to 4GB

Lparameters m.tcFileSkeleton As String

m.tcFileSkeleton = Alltrim(m.tcFileSkeleton)

Local ;
	lnApiRetVal As Integer, ;
	loWin32FindData, ;
	lcWin32FindData As String, ;
	lnFlags As Integer, ;
	lnContext As Integer, ;
	lcSearchFile As String, ;
	lnLastError As Integer, ;
	lnRetVal As Integer, ;
	lnFileAttributes As Integer

m.lnLastError = 0

m.loWin32FindData =  Createobject("CTLWIN32_FIND_DATA")
m.lcWin32FindData = m.loWin32FindData.Value

*!* If we do not have a FtpFindFirstFile handle, get one:
If This.hFind = 0 Then

	m.lcSearchFile = m.tcFileSkeleton + NULA

	*!* Set flags:
	m.lnFlags = This._GetFlags()

	m.lnContext = 0

	m.lnApiRetVal = apiFtpFindFirstFile( ;
		This.hConnect, ;
		m.lcSearchFile, ;
		@m.lcWin32FindData, ;
		m.lnFlags, ;
		m.lnContext)

	This.hFind = m.lnApiRetVal

	*!* This is here so we get the dir list transfer msg from the FTP server,
	This._ClearLastError()
	This._GetLastResponse("FtpFindFirstFile")

	If m.lnApiRetVal = 0
		m.lnLastError = apiGetLastError()
		This._GetLastError("FtpFindFirstFile")
	Endif

Else
	*!* Just get the next file
	m.lnApiRetVal = apiInternetFindNextFile(This.hFind, @m.lcWin32FindData)

	If m.lnApiRetVal = 0
		m.lnLastError = apiGetLastError()
		This._GetLastError("InternetFindNextFile")
	Endif

Endif

If m.lnApiRetVal = 0 Then
	*!* Close hFind Handle:
	This.hFind = This._InternetCloseHandle(This.hFind)

	If m.lnLastError = ERROR_NO_MORE_FILES
		*!* Return 0 when there are no more files
		m.lnRetVal = 0
	Else
		*!* Return -1 if there was an error
		m.lnRetVal = -1
	Endif
Else
	*!* Return 1 if there is a file
	m.lnRetVal = 1
Endif

If m.lnRetVal = 1 Then
	*!* Copy returned structure and path to WIN32_FIND_DATA object
	m.loWin32FindData.Value = m.lcWin32FindData
	*	This.FtpFileInfo._SetStructure(m.lcWin32FindData, This.FtpAddfs(Justpath(m.tcFileSkeleton)))
Endif

With This.FtpFileInfo

	.FilePath = This.FtpAddfs(Justpath(m.tcFileSkeleton))
	.FileName = m.loWin32FindData.cFileName
	.FileShortName = m.loWin32FindData.cAlternateFileName

	.FileSize = m.loWin32FindData.nFileSizeHigh * 2^32 + m.loWin32FindData.nFileSizeLow

	If .FileSize = 0xffffffff Then
		.FileSize = This.FtpGetFileSize(.FilePath + .FileName)
	Endif

	.FileCreationTime 	= ctlFileTimeToDateTime(m.loWin32FindData.ftCreationTime)
	.FileLastAccessTime = ctlFileTimeToDateTime(m.loWin32FindData.ftLastAccessTime)
	.FileLastWriteTime 	= ctlFileTimeToDateTime(m.loWin32FindData.ftLastWriteTime)

	m.lnFileAttributes = m.loWin32FindData.dwFileAttributes

	.FileAttribute.Archive 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_ARCHIVE) = FILE_ATTRIBUTE_ARCHIVE)
	.FileAttribute.Compressed 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_COMPRESSED) = FILE_ATTRIBUTE_COMPRESSED)
	.FileAttribute.Directory 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY)
	.FileAttribute.Encrypted 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_ENCRYPTED) = FILE_ATTRIBUTE_ENCRYPTED)
	.FileAttribute.Hidden 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_HIDDEN) = FILE_ATTRIBUTE_HIDDEN)
	.FileAttribute.Normal 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_NORMAL) = FILE_ATTRIBUTE_NORMAL)
	.FileAttribute.NotContentIndexed	= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED) = FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
	.FileAttribute.Offline 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_OFFLINE) = FILE_ATTRIBUTE_OFFLINE)
	.FileAttribute.ReadOnly 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_READONLY) = FILE_ATTRIBUTE_READONLY)
	.FileAttribute.ReparsePoint 		= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_REPARSE_POINT) = FILE_ATTRIBUTE_REPARSE_POINT)
	.FileAttribute.SparseFile 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_SPARSE_FILE) = FILE_ATTRIBUTE_SPARSE_FILE)
	.FileAttribute.System 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_SYSTEM) = FILE_ATTRIBUTE_SYSTEM)
	.FileAttribute.Temporary 			= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_TEMPORARY) = FILE_ATTRIBUTE_TEMPORARY)
	.FileAttribute.Virtual 				= (Bitand(m.lnFileAttributes, FILE_ATTRIBUTE_VIRTUAL) = FILE_ATTRIBUTE_VIRTUAL)


	.Adir1 = .FilePath + .FileName
	.Adir2 = .FileSize
	.Adir3 = Ttod(.FileLastWriteTime)

	.Adir4 = Padl(Transform(Hour(.FileLastWriteTime)), 2, "0") + ":" ;
		+ Padl(Transform(Minute(.FileLastWriteTime)), 2, "0") + ":" ;
		+ Padl(Transform(Sec(.FileLastWriteTime)), 2, "0")

	.Adir5 = ""

	If .FileAttribute.ReadOnly Then
		.Adir5 = .Adir5 + "R"
	Else
		.Adir5 = .Adir5 + "."
	Endif
	If .FileAttribute.Archive Or .FileAttribute.Normal Then
		.Adir5 = .Adir5 + "A"
	Else
		.Adir5 = .Adir5 + "."
	Endif
	If .FileAttribute.System Then
		.Adir5 = .Adir5 + "S"
	Else
		.Adir5 = .Adir5 + "."
	Endif
	If .FileAttribute.Hidden Then
		.Adir5 = .Adir5 + "H"
	Else
		.Adir5 = .Adir5 + "."
	Endif
	If .FileAttribute.Directory Or Not .FileAttribute.Normal Then
		.Adir5 = .Adir5 + "D"
	Else
		.Adir5 = .Adir5 + "."
	Endif


Endwith


m.loWin32FindData = .Null.

Return m.lnRetVal

ENDPROC
PROCEDURE _ftpgetfilesize
*!* _FtpGetFileSize(cRemoteFile, @nFileSize)

*!* Returns the size of a file (up to 4gb)

Lparameters m.tcRemoteFile As String, m.tnFileSize As Integer

Local ;
    lnFileSizeLow As Integer, ;
    lnFileSizeHigh As Integer, ;
    llRetVal As Boolean

If This._FtpOpenFile(m.tcRemoteFile, GENERIC_READ) = TRUE Then

    m.lnFileSizeHigh = 0
    m.lnFileSizeLow = apiFtpGetFileSize(This.hFile, @m.lnFileSizeHigh)
    *!* ?m.lnFileSizeLow, m.lnFileSizeHigh
    *!* Convert signed integer to unsigned:
    If m.lnFileSizeLow < 0 Then
        m.lnFileSizeLow = m.lnFileSizeLow + MAXDWORD + 1
    Endif

    If apiGetLastError() = NO_ERROR Then
        m.tnFileSize = m.lnFileSizeHigh * MAXDWORD + m.lnFileSizeLow
        m.llRetVal = TRUE
    Else
        m.llRetVal = FALSE
    Endif

    *!* Close file handle:
    This.hFile = This._InternetCloseHandle(This.hFile)

Else
    m.llRetVal = FALSE
Endif

Return m.llRetVal

ENDPROC
PROCEDURE _ftpopenfile
*!* _FtpOpenFile(cRemoteFile, nAccess)

Lparameters m.tcRemoteFile As String, m.tnAccess As Integer

*!* close open file if we have one:
This.hFile = This._InternetCloseHandle(This.hFile)

Local ;
	lcRemoteFile As String, ;
	lnAccess As Integer, ;
	lnFlags As Integer, ;
	lnContext As Integer, ;
	lnApiRetVal As Integer, ;
	lcFunction as String, ;
	llRetVal As Boolean

m.lcRemoteFile = Alltrim(m.tcRemoteFile) + NULA
m.lnAccess = m.tnAccess

*!* Set flags:
m.lnFlags = This._GetFlags()

m.lnContext = 0

m.lnApiRetVal = apiFtpOpenFile( ;
	This.hConnect, ;
	m.lcRemoteFile, ;
	m.lnAccess, ;
	m.lnFlags, ;
	m.lnContext)

This.hFile = m.lnApiRetVal

m.lcFunction = "FtpOpenFile"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE _ftpreadcommand
*!* _FtpReadCommand

*!* Reads response from FtpCommand when lExpectRespose is TRUE

Local ;
	lnBytesRead, ;
	lnReadBufferSize, ;
	lcReadBuffer, ;
	lnNumberOfBytesRead, ;
	lnApiRetVal, ;
	llRetVal

m.lnBytesRead = 0
m.lnReadBufferSize = 1024
m.lcReadBuffer = Space(m.lnReadBufferSize)
m.lnNumberOfBytesRead = 0
m.lnApiRetVal = 0

This.FtpCommandData = ""

*!* Enter loop where we download response:
Do While TRUE

	m.lnApiRetVal = apiInternetReadFile( ;
		This.hFtpCommand, ;
		@m.lcReadBuffer, ;
		m.lnReadBufferSize, ;
		@m.lnNumberOfBytesRead)

	If m.lnApiRetVal = 0 Then
		This._GetLastError("InternetReadFile")
		m.llRetVal = FALSE
	Else
		m.llRetVal = TRUE
	Endif

	*!* This so user can cancel download
	DoEvents

	If m.lnApiRetVal <> 0 Then
		*!* 16711680 bytes is the maximum size of a string in VFP:
		If m.lnBytesRead + m.lnNumberOfBytesRead > VFP_MAX_STRING_SIZE Then
			m.lnNumberOfBytesRead = VFP_MAX_STRING_SIZE - m.lnBytesRead
			m.llRetVal = FALSE
		Endif
		This.FtpCommandData = This.FtpCommandData + Left(m.lcReadBuffer, m.lnNumberOfBytesRead)
		m.lnBytesRead = m.lnBytesRead + m.lnNumberOfBytesRead
	Endif

	*!* If InternetReadFile has no more data
	If m.lnNumberOfBytesRead = 0 Then
		Exit
	Endif

	If m.llRetVal = FALSE Then
		Exit
	Endif

Enddo

ENDPROC
PROCEDURE _getflags
*!* _GetFlags(cFunction)

Lparameters m.tcFunction As String

Local lnFlags As Integer

m.lnFlags = 0

*!* Allows a lazy cache write
If This.FlagCacheAsync Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_CACHE_ASYNC)
Endif

*!* Returns the resource from the cache if the network request for the resource
*!* fails due to an ERROR_INTERNET_CONNECTION_RESET or ERROR_INTERNET_CANNOT_CONNECT error
If This.FlagCacheIfNetFail Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_CACHE_IF_NET_FAIL)
Endif

*!* Forces a reload if there is no Expires time and no LastModified time returned
*!* from the server when determining whether to reload the item from the network.
If This.FlagHyperlink = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_HYPERLINK)
Endif

*!* Causes a temporary file to be created if the file cannot be cached.
If This.FlagNeedFile = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_NEED_FILE)
Endif

*!* Does not add the returned entity to the cache.
If This.FlagNoCacheWrite = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_NO_CACHE_WRITE)
Endif

*!* Uses passive FTP semantics. Only InternetConnect and
*!* InternetOpenUrl use this flag
If This.FlagPassive = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_PASSIVE)
Endif


*!* Forces a download of the requested file, object,
*!* or directory listing from the origin server, not from the cache
If This.FlagReload = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_RELOAD)
Endif

*!* Reloads HTTP resources if the resource has been modified since
*!* the last time it was downloaded. All FTP and Gopher resources are reloaded.
If This.FlagResynchronize = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_RESYNCHRONIZE)
Endif

*!* Transfers file as binary or ASCII (FTP only).
If This.FlagTransferBinary = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, FTP_TRANSFER_TYPE_BINARY)
Else
	m.lnFlags = Bitor(m.lnFlags, FTP_TRANSFER_TYPE_ASCII)
Endif

Return m.lnFlags

ENDPROC
PROCEDURE _getflagsinternet
Local lnFlags As Integer

m.lnFlags = 0

*!* This flags only apply to InternetOpen

If This.InternetFlagAsync = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_ASYNC)
Endif

*!* Does not make network requests. All entities are returned from the cache.
*!* If the requested item is not in the cache, a suitable error, such as
*!* ERROR_FILE_NOT_FOUND, is returned. Only the InternetOpen function uses this flag.

If This.InternetFlagFromCache = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_FROM_CACHE)
Endif

*!*	Identical to INTERNET_FLAG_FROM_CACHE. Does not make network requests.
*!*	All entities are returned from the cache. If the requested item is not
*!*	in the cache, a suitable error, such as ERROR_FILE_NOT_FOUND, is returned.
*!*	Only the InternetOpen function uses this flag.

If This.InternetFlagOffline = TRUE Then
	m.lnFlags = Bitor(m.lnFlags, INTERNET_FLAG_OFFLINE)
Endif

Return m.lnFlags

ENDPROC
PROCEDURE _getlasterror
*!* _GetLastError(cFunction)

Lparameters m.tcFunction As String

*!* We are here only because an error was raised, so we clear last response info:
This._ClearLastResponse()

Local ;
	lnErrorCode As Integer, ;
	lcErrorInfo As String, ;
	lnBuffer As Integer, ;
	lcBuffer As String, ;
	lnBufferLen As Integer, ;
	lnRetVal As Integer

*!* Init vars:
m.lnErrorCode = 0
m.lcErrorInfo = "-"

*!* Get Last error code:
m.lnErrorCode = apiGetLastError()

*!* Get last error text:

*!* Initialize buffer vars:
m.lnBuffer = 0
m.lnBufferLen = 1024
m.lcBuffer = Replicate(NULA, m.lnBufferLen)

m.lnRetVal = apiFormatMessage( ;
	FORMAT_MESSAGE_FROM_HMODULE, ;
	This._hKernel32, ;
	m.lnErrorCode, ;
	0, ;
	@m.lcBuffer, ;
	m.lnBufferLen, ;
	0)

*!* If nothing found then search in wininet.dll
If m.lnRetVal = 0 Then

	m.lnRetVal = apiFormatMessage( ;
		FORMAT_MESSAGE_FROM_HMODULE, ;
		This._hWinInet, ;
		m.lnErrorCode, ;
		0, ;
		@m.lcBuffer, ;
		m.lnBufferLen, ;
		0)

Endif

*!* If something was found, get the text from the buffer:
If m.lnRetVal <> 0 Then
	m.lcErrorInfo = Left(m.lcBuffer, m.lnRetVal)

	*!* Remove last carriage return/line feed
	If Right(m.lcErrorInfo, 2) = CRLF Then
		m.lcErrorInfo = Left(m.lcBuffer, m.lnRetVal - 2)
	Endif
Endif

This.FtpErrorFunction = m.tcFunction
This.FtpErrorCode	 = m.lnErrorCode
This.FtpErrorText	 = m.lcErrorInfo

If This.OptionDebug = TRUE Then
	?"ErrorFunction: ", This.FtpErrorFunction
	?"ErrorCode: ", This.FtpErrorCode
	?"ErrorInfo:"
	?This.FtpErrorText
	?"---------------------------------------"
Endif

If This.FtpErrorCode = ERROR_INTERNET_EXTENDED_ERROR Then
	This._GetLastResponse(m.tcFunction, FALSE)
Endif



ENDPROC
PROCEDURE _getlastresponse
*!* _GetLastResponse(cFunction, [lClearLastError])

Lparameters m.tcFunction As String, m.tlClearLastError As Boolean

If m.tlClearLastError = TRUE Then
    This._ClearLastError()
Endif

This.FtpResponseFunction = m.tcFunction

Local ;
    lnResponseCode As Integer, ;
    lcResponseInfo As String, ;
    lnBuffer As Integer, ;
    lcBuffer As String, ;
    lnBufferLen As Integer, ;
    lnRetVal As Integer

*!* FTP PROTOCOL SPECIFIC

*!* Init vars:
m.lnResponseCode = 0
m.lcResponseInfo = ""

*!* Get last internet response:

m.lnBuffer = 0
m.lnBufferLen = 255
m.lcBuffer = Replicate(NULA, m.lnBufferLen)

m.lnRetVal = apiInternetGetLastResponseInfo(;
    @m.lnBuffer, ;
    @m.lcBuffer, ;
    @m.lnBufferLen)

If m.lnRetVal = 0 And apiGetLastError() = ERROR_INSUFFICIENT_BUFFER
    m.lcBuffer = Replicate(NULA, m.lnBufferLen)
    m.lnRetVal = apiInternetGetLastResponseInfo(;
        @m.lnBuffer, ;
        @m.lcBuffer, ;
        @m.lnBufferLen)
Endif

If m.lnRetVal = 1 Then
    m.lnResponseCode = m.lnBuffer
    m.lcResponseInfo = Left(m.lcBuffer, m.lnBufferLen)
Endif

This.FtpResponseCode = m.lnResponseCode
This.FtpResponseText = m.lcResponseInfo

If m.lnResponseCode = 0 Then
    This.FtpResponseCode = Int(Val(Left(Getwordnum(m.lcResponseInfo, Getwordcount(m.lcResponseInfo, LF), LF), 3)))
Else
    This.FtpResponseCode = m.lnResponseCode
Endif

If This._Destroying = FALSE And Not Empty(This.FtpResponseText) Then
    Raiseevent(This, "FtpResponse")
Endif

If This.OptionDebug = TRUE Then
    ?"ResponseFunction", This.FtpResponseFunction
    ?"ResponseCode: ", This.FtpResponseCode
    ?"ResponseInfo:"
    ?This.FtpResponseText
    ?"---------------------------------------"
Endif


ENDPROC
PROCEDURE _internetclosehandle
*!* _InternetCloseHandle()

Lparameters m.lnHandle As Integer

Local lnApiRetVal As Integer

If m.lnHandle <> 0 Then

	m.lnApiRetVal = apiInternetCloseHandle(m.lnHandle)

	If m.lnApiRetVal = 0 Then
		This._GetLastError("InternetCloseHandle")
	Endif

Endif

Return 0

ENDPROC
PROCEDURE _internetcrackurl
*!* _InternetCrackUrl

Lparameters m.lcUrlString As String

Local ;
	lcUrlStruct As String, ;
	lnScheme As Integer, ;
	lnPos As Integer, ;
	lnLen As Integer, ;
	oURL As CTLURL_COMPONENTS

m.oURL = Createobject("CTLURL_COMPONENTS")

*!* Set FTP as default scheme:
m.lnScheme = INTERNET_SCHEME_FTP

*!* Find Scheme and strip scheme prefix:
Do Case
	Case Lower(Left(m.lcUrlString, 6)) == "ftp://"
		m.lnScheme = INTERNET_SCHEME_FTP
		m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 6)

	Case Lower(Left(m.lcUrlString, 7)) == "http://"
		m.lnScheme = INTERNET_SCHEME_HTTP
		m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 7)

	Case Lower(Left(m.lcUrlString, 8)) == "https://"
		m.lnScheme = INTERNET_SCHEME_HTTPS
		m.lcUrlString = Right(m.lcUrlString, Len(m.lcUrlString) - 8)

	Case Lower(Left(m.lcUrlString, 4)) == "ftp."
		m.lnScheme = INTERNET_SCHEME_FTP

	Case Lower(Left(m.lcUrlString, 4)) == "www."
		m.lnScheme = INTERNET_SCHEME_HTTP

Endcase

*!* lets see if we still have some other scheme in the URL
*!* maximum scheme len is INTERNET_MAX_SCHEME_LENGTH

m.lnPos = Atc("://", Left(m.lcUrlString, INTERNET_MAX_SCHEME_LENGTH))

If m.lnPos > 0 Then
	m.lnLen = Len(m.lcUrlString) - (m.lnPos + 2)
	m.lcUrlString = Right(m.lcUrlString, m.lnLen)
Endif

*!* Add protocol prefix based on scheme found:
Do Case
	Case m.lnScheme = INTERNET_SCHEME_FTP
		m.lcUrlString = "ftp://" + m.lcUrlString

	Case m.lnScheme = INTERNET_SCHEME_HTTP
		m.lcUrlString = "http://" + m.lcUrlString

	Case m.lnScheme = INTERNET_SCHEME_HTTPS
		m.lcUrlString = "https://" + m.lcUrlString
Endcase

*!* Initialize oUrl structure
With m.oURL
	.lpszExtraInfo	= Replicate(NULCHAR, INTERNET_MAX_PATH_LENGTH)
	.lpszHostName	= Replicate(NULCHAR, INTERNET_MAX_HOST_NAME_LENGTH)
	.lpszPassword	= Replicate(NULCHAR, INTERNET_MAX_PASSWORD_LENGTH)
	.lpszScheme		= Replicate(NULCHAR, INTERNET_MAX_SCHEME_LENGTH)
	.lpszUrlPath	= Replicate(NULCHAR, INTERNET_MAX_PATH_LENGTH)
	.lpszUserName	= Replicate(NULCHAR, INTERNET_MAX_USER_NAME_LENGTH)
Endwith

*!* get a copy of the structure to a memory variable:
m.lcUrlStruct = m.oURL.Value

apiInternetCrackUrl( ;
	m.lcUrlString, ;
	Len(m.lcUrlString), ;
	ICU_DECODE, ;
	@m.lcUrlStruct)

*!* Assign returned structure to url object:
m.oURL.Value = m.lcUrlStruct

This.UrlText		= m.oURL.lpszScheme + "://" + m.oURL.lpszHostName
This.UrlExtraInfo	= m.oURL.lpszExtraInfo
This.UrlHostName	= m.oURL.lpszHostName
This.UrlPassword	= m.oURL.lpszPassword
This.UrlPath		= m.oURL.lpszUrlPath
This.UrlPort		= m.oURL.nPort
This.UrlSchemeName	= m.oURL.lpszScheme
This.UrlSchemeCode	= m.oURL.nScheme
This.UrlUsername	= m.oURL.lpszUserName

*!* Add port to url if using non-default
Do Case

	Case This.UrlSchemeName == "http" And This.UrlPort <> 80
		This.UrlText = This.UrlText + ":" + Transform(This.UrlPort)

	Case This.UrlSchemeName == "https" And This.UrlPort <> 443
*This.Urltext = This.Urltext + ":" + Transform(This.UrlPort)

	Case This.UrlSchemeName == "ftp" And This.UrlPort <> 21
		This.UrlText = This.UrlText + ":" + Transform(This.UrlPort)

Endcase

*!* add path and extra info:
This.UrlText = This.UrlText + This.UrlPath + This.UrlExtraInfo

This._UpdateUrlProperties()

*!*	?This.UrlHostName
*!*	?This.UrlPort
*!*	?This.UrlSchemeName
*!*	?This.Urltext
*!*	?This.UrlSchemeCode
*!*	?This.UrlPath
*!*	?This.UrlExtraInfo
*!*	?This.UrlUsername
*!*	?This.UrlPassword

m.oURL = .Null.
Release m.oURL

Return

ENDPROC
PROCEDURE _internetqueryoption
*!* _InternetQueryOption(nHandle, nOption, @vValue)

Lparameters m.tnHandle As Integer, m.tnOption As Integer, m.tvValue As Variant

Local ;
	lcBuffer As String, ;
	lcBufferLen As Integer, ;
	lnApiRetVal As Integer, ;
	llRetVal As Boolean

m.lcBufferLen = 255
m.lcBuffer = Space(m.lcBufferLen)

m.lnApiRetVal = apiInternetQueryOption(m.tnHandle, m.tnOption, @m.lcBuffer, @m.lcBufferLen)

If m.lnApiRetVal = 0 And apiGetLastError() = ERROR_INSUFFICIENT_BUFFER Then
	m.lcBuffer = Space(m.lcBufferLen)
	m.lnApiRetVal = apiInternetQueryOption(m.tnHandle, m.tnOption, @m.lcBuffer, @m.lcBufferLen)
Endif

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
Else
	m.llRetVal = TRUE
	If Vartype(m.tvValue) = T_numeric Then
		m.tvValue = CToBin(Left(m.lcBuffer, m.lcBufferLen), "4RS")
	Else
		m.tvValue = Left(m.lcBuffer, m.lcBufferLen)
	Endif

Endif

Return m.llRetVal

ENDPROC
PROCEDURE _internetsetoption
*!* _InternetSetOption(nHandle, nOption, vValue)

Lparameters m.tnHandle As Integer, m.tnOption As Integer, m.tvValue As Variant

Local ;
	lcBuffer As String, ;
	lnBufferLen As Integer, ;
	lnApiRetVal As Integer, ;
	llRetVal As Boolean

If Vartype(m.tvValue) = T_NUMERIC Then
	m.lcBuffer = BinToC(m.tvValue, "4RS")
Else
	m.lcBuffer = Alltrim(m.tvValue)
Endif

m.lnBufferLen = Len(m.lcBuffer)

m.lnApiRetVal = apiInternetSetOption(;
	m.tnHandle, ;
	m.tnOption, ;
	m.lcBuffer, ;
	m.lnBufferLen)


If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
Else
	m.llRetVal = TRUE
Endif

Return m.llRetVal

ENDPROC
PROCEDURE _setproperties

*!* _SetProperties()

If Type("This.InternetAccessType") <> T_NUMERIC Then
	This.InternetAccessType = 0
Endif

If Type(This.InternetUserAgent) <> T_CHARACTER Then
	This.InternetUserAgent = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
Endif

This.FtpErrorCode = 0
This.FtpErrorFunction = ""
This.FtpErrorText = ""

This.FtpResponseCode = 0
This.FtpResponseFunction = ""
This.FtpResponseText = ""

If Type("This.InternetProxyBypass") <> T_CHARACTER Then
	This.InternetProxyBypass = "<local>"
Endif

If Type("This.FtpUsername") <> T_CHARACTER Then
	This.FtpUsername = Transform(This.FtpUsername)
Endif

If Type("This.FtpPassword") <> T_CHARACTER Then
	This.FtpPassword = Transform(This.FtpPassword)
Endif


Dimension This.FtpFiles(1, 5)



ENDPROC
PROCEDURE _updateurlproperties
*!* _UpdateUrlProperties()

Local ;
	lcOptPassword As String, ;
	lcOptUserName As String

If This.hConnect <> 0 Then

	m.lcOptPassword = ""
	m.lcOptUserName = ""

	If This._InternetQueryOption(This.hConnect, INTERNET_OPTION_PASSWORD, @m.lcOptPassword) Then
		This.UrlPassword = m.lcOptPassword
	Endif

	If This._InternetQueryOption(This.hConnect, INTERNET_OPTION_USERNAME, @m.lcOptUserName)
		This.UrlUsername = m.lcOptUserName
	Endif

Else

	If Not Empty(This.FtpPassword) And Empty(This.UrlPassword) Then
		This.UrlPassword = Alltrim(This.FtpPassword)
	Endif

	If Not Empty(This.FtpUsername) And Empty(This.UrlUsername) Then
		This.UrlUsername = Alltrim(This.FtpUsername)
	Endif

Endif

*!* Check for empty username and existing password:
If Empty(This.UrlUsername) Then
	This.UrlPassword = ""
Endif

ENDPROC
PROCEDURE formatbytes
*!* FormatBytes(nBytes)

Lparameters m.tnBytes As Integer

Return ctlStrFormatByteSize(m.tnBytes)

ENDPROC
PROCEDURE formatseconds
*!* FormatSeconds(nSeconds)

Lparameters m.tnSeconds As Integer

Return ctlStrFormatSeconds(m.tnSeconds)

ENDPROC
PROCEDURE ftpaddfs
*!* FtpAddfs(cPath)
*!* Adds a forward slash at the end of an FTP path, if needed.

Lparameters m.tcPath As String

If Right(m.tcPath, 1) <> "/" Then
    m.tcPath = m.tcPath + "/"
Endif

Return m.tcPath

ENDPROC
PROCEDURE ftpcancel
*!* FtpCancel()

This.FtpTransferCancelled = TRUE
ENDPROC
PROCEDURE ftpclose
*!* FtpClose()

This.hConnect = This._InternetCloseHandle(This.hConnect)

Return TRUE


ENDPROC
PROCEDURE ftpcommand
*!* FtpCommand(cCommand, [lExpectResponse])

Lparameters m.tcCommand As String, m.tlExpectResponse As Boolean

Local ;
	lnApiRetVal As Integer, ;
	lnExpectResponse As Integer, ;
	lnFlags As Integer, ;
	lcCommand As String, ;
	lnContext As Integer, ;
	lnFtpCommandHandle As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

*!* If a response is expected, clear current hFtpCommand handle:
If m.tlExpectResponse = TRUE Then
	m.lnExpectResponse = 1
	This.hFtpCommand = This._InternetCloseHandle(This.hFtpCommand)
Else
	m.lnExpectResponse = 0
Endif

*!* Get flags for FtpCommand:
If This.FlagTransferBinary = TRUE Then
	m.lnFlags = FTP_TRANSFER_TYPE_ASCII
Else
	m.lnFlags = FTP_TRANSFER_TYPE_BINARY
Endif

m.lcCommand = Alltrim(m.tcCommand) + NULA

m.lnContext = 0

m.lnFtpCommandHandle = 0

m.lnApiRetVal = apiFtpCommand( ;
	This.hConnect, ;
	m.lnExpectResponse, ;
	m.lnFlags, ;
	m.lcCommand, ;
	m.lnContext, ;
	@m.lnFtpCommandHandle)

If m.tlExpectResponse = TRUE Then
	This.hFtpCommand = m.lnFtpCommandHandle
	This._FtpReadCommand()
	This.hFtpCommand = This._InternetCloseHandle(This.hFtpCommand)
Endif

m.lcFunction = "FtpCommand"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpcreatedirectory
*!* FtpCreateDirectory(cDirectory)

Lparameters m.tcDirectory As String

Local ;
	lnApiRetVal As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

If Vartype(m.tcDirectory) = T_CHARACTER Then
	m.tcDirectory = Alltrim(m.tcDirectory) + NULA
Else
	m.tcDirectory = ""  + NULA
Endif

m.lnApiRetVal = apiFtpCreateDirectory(This.hConnect, m.tcDirectory)

m.lcFunction = "FtpCreateDirectory"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpdeletefile
*!* FtpDeleteFile(cRemoteFile)

Lparameters m.tcRemoteFile As String

Local ;
	lcRemoteFile As String, ;
	lnApiRetVal As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
	Return FALSE
Endif

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA

m.lnApiRetVal = apiFtpDeleteFile(This.hConnect, m.lcRemoteFile)

m.lcFunction = "FtpDeleteFile"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpdirtoarray
*!* FtpDirToArray([cFileSkeleton])

*!* Calls ._FtpFindFile to get files one by one
*!* Calls ._AddToArray for each file found
*!* cFileSkeleton can be a directory + filespec, just a filespec, or empty
*!* if it is just a filespec, it uses the current ftp directory
*!* if it is empty, it uses the current ftp directory and a *.* filespec

Lparameters m.tcFileSkeleton

Local ;
	lcDirSpec As String, ;
	lcFileSpec As String, ;
	lcFileSkeleton As String, ;
	lcCurrentDirectory As String, ;
	lnFileCount As Integer, ;
	lnRetVal As Integer

*!* Just in case we have an open file enumeration:
This.hFind = This._InternetCloseHandle(This.hFind)

*!* Init array and add first row (".." directory entry row)
This._AddToArray(0)

If Vartype(m.tcFileSkeleton) = T_CHARACTER Then
	m.tcFileSkeleton = Alltrim(m.tcFileSkeleton)
Else
	m.tcFileSkeleton = ""
Endif

m.lcFileSkeleton = m.tcFileSkeleton

*!* m.lcFileSkeleton = m.lcDirSpec + m.lcFileSpec
*!* Split file skeleton in path and file spec:

m.lcDirSpec = Justpath(m.lcFileSkeleton)
m.lcFileSpec = Justfname(m.lcFileSkeleton)

*!* if no path in file skeleton, use current directory:
If Empty(m.lcDirSpec) Then

	m.lcCurrentDirectory = ""
	If This.FtpGetCurrentDirectory(@m.lcCurrentDirectory) = FALSE Then
		*!* could not get current directory, return with error
		Return -1
	Else
		m.lcDirSpec = This.FtpAddfs(m.lcCurrentDirectory)
	Endif

Else
	*!* Add a forward slash if needed at the end of dirspec:
	m.lcDirSpec = This.FtpAddfs(m.lcDirSpec)
Endif

If Empty(m.lcFileSpec) Then
	m.lcFileSpec = "*.*"
Endif

m.lcFileSkeleton =  m.lcDirSpec + m.lcFileSpec

m.lnFileCount = 0

m.lnRetVal = 1

Do While m.lnRetVal = 1
	m.lnRetVal = This._FtpFindFile(m.lcFileSkeleton)

	If m.lnRetVal = 1 Then
		m.lnFileCount  = m.lnFileCount  + 1
		This._AddToArray(m.lnFileCount)
	Endif

	If m.lnRetVal = -1 Then
		m.lnFileCount = m.lnRetVal
	Endif
Enddo

Return m.lnFileCount




ENDPROC
PROCEDURE ftpdirtocursor
*!* FtpDirToCursor(cCursor, [cFileSkeleton])

Lparameters m.tcCursorName As String, m.tcFileSkeleton As String

m.tcCursorName = Alltrim(m.tcCursorName)

Local ;
	lnFileCount As Integer, ;
	lnRows As Integer, ;
	lnCols As Integer, ;
	laStru(1), ;
	lnCol As Integer

m.lnFileCount = This.FtpDirToArray(m.tcFileSkeleton)

* Figure out size of array
m.lnRows = Alen(This.FtpFiles, 1)
m.lnCols = Max( Alen(This.FtpFiles, 2), 1 )

Dimension m.laStru(m.lnCols, 4)

*!* Field names:
m.laStru(1,1) = "f_name"
m.laStru(2,1) = "f_size"
m.laStru(3,1) = "f_date"
m.laStru(4,1) = "f_time"
m.laStru(5,1) = "f_attr"

*!* Field sizes:
m.laStru(1,3) = 254
m.laStru(2,3) = 12
m.laStru(3,3) = 8
m.laStru(4,3) = 8
m.laStru(5,3) = 5

For m.lnCol = 1 To m.lnCols
	*!* Field type
	m.laStru(m.lnCol, 2 ) = Vartype(This.FtpFiles( 1, m.lnCol))
	*!* Field decimals
	m.laStru(m.lnCol, 4 ) = 0
Endfor

* Make a cursor with fields defined by laStru
Create Cursor (m.tcCursorName) From Array m.laStru

Insert Into (m.tcCursorName) From Array This.FtpFiles
Go Top In (m.tcCursorName)

Return m.lnFileCount

ENDPROC
PROCEDURE ftpgetcurrentdirectory
*!* FtpGetCurrentDirectory(@cDirectory)

*!* Returns the current Ftp directory in the var passed by reference

Lparameters m.tcDirectory As String

If Pcount() = 0 Then
	Return false
Endif

Local ;
	lcDirectory As String, ;
	lnDirectoryLen As Integer, ;
	lnApiRetVal As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

m.lnDirectoryLen = MAX_PATH
m.lcDirectory = Space(m.lnDirectoryLen)

m.lnApiRetVal = apiFtpGetCurrentDirectory(;
	This.hConnect, ;
	@m.lcDirectory, ;
	@m.lnDirectoryLen)

If m.lnApiRetVal = 0 Then
	m.tcDirectory = ""
Else
	m.tcDirectory = Left(m.lcDirectory, m.lnDirectoryLen)
Endif

m.lcFunction = "FtpGetCurrentDirectory"

If m.lnApiRetVal = 0 Then
	m.llRetVal = false
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpgetfile
*!* FtpGetFile(cRemoteFile, cLocalFile, [lOverWrite], [nAttributes])

Lparameters ;
	m.tcRemoteFile As String, ;
	m.tcLocalFile As String, ;
	m.tlOverWrite As Boolean, ;
	m.tnAttributes As Integer

Local ;
	lnApiRetVal As Integer, ;
	lcRemoteFile As String, ;
	lcLocalFile As String, ;
	llOverWrite As Boolean, ;
	llFailIfExists As Boolean, ;
	lnAttributes As Integer, ;
	lnFlags As Integer, ;
	lnContext As Integer, ;
	lcFunction as String, ;
	llRetVal As Boolean

If Vartype(m.tcRemoteFile) <> T_CHARACTER ;
		OR Vartype(m.tcLocalFile) <> T_CHARACTER Then
	Return FALSE
Endif

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA
m.lcLocalFile  = Alltrim(m.tcLocalFile) + NULA

If Pcount() < 3 Then
	If Set("Safety") = "OFF" Then
		m.llOverWrite = TRUE
	Else
		m.llOverWrite = FALSE
	Endif
Else
	m.llOverWrite = m.tlOverWrite
Endif

*!* Set flags:
m.lnFlags = This._GetFlags()

If m.tlOverWrite = TRUE Then
	m.llFailIfExists = 0
Else
	m.llFailIfExists = 1
Endif

If Vartype(m.tnAttributes) <> T_NUMERIC Then
	m.lnAttributes = 0
Else
	m.lnAttributes = m.tnAttributes
Endif

m.lnContext = 0

m.lnApiRetVal = apiFtpGetFile( ;
	This.hConnect, ;
	m.lcRemoteFile, ;
	m.lcLocalFile, ;
	m.llFailIfExists, ;
	m.lnAttributes, ;
	m.lnFlags, ;
	m.lnContext)

m.lcFunction = "FtpGetFile"

If m.lnApiRetVal = 0 Then
	m.llRetVal = false
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpgetfiledate
*!* FtpGetFileDate(cRemoteFile)

*!* Returns the last modified date and time of a remote file in GMT time

Lparameters m.tcRemoteFile As String

Local lcRemoteFile, lcResponse

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile)

If This.FtpCommand("MDTM " + m.lcRemoteFile) = TRUE Then
	m.lcResponse = Getwordnum(This.FtpResponseText, 2, " ")
Else
	m.lcResponse = ""
Endif

Return m.lcResponse
ENDPROC
PROCEDURE ftpgetfileinfo
*!* FtpGetFileInfo(cRemoteFile | cRemoteDir)

*!* This method places file/directory info in the FtpFileInfo object

Lparameters m.tcRemoteFile As String

Local ;
	lcDirSpec As String, ;
	lcFileSpec As String, ;
	llRetVal As Boolean, ;
	lcRemoteFile As String

If Pcount() = 0 Or Empty(m.tcRemoteFile) Then
	Return FALSE
Endif

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile)
m.lcDirSpec = This.FtpAddfs(Justpath(m.lcRemoteFile))
m.lcFileSpec = Justfname(m.lcRemoteFile)

*!* if m.lcRemoteFile is a directory, we get the first file of that
*!* directory if we use it as a filespec to _FtpFindFile
*!* so we use the parent directory and iterate thru its files until we find the
*!* one we are looking for, file or directory (yes, its a kludge)

m.llRetVal = FALSE

Do While This._FtpFindFile(m.lcDirSpec) = 1
	If This.FtpFileInfo.FilePath + This.FtpFileInfo.FileName  == m.lcRemoteFile
		m.llRetVal = TRUE
		Exit
	Endif
Enddo

*!* close hFind Handle:
This.hFind = This._InternetCloseHandle(This.hFind)

Return m.llRetVal





ENDPROC
PROCEDURE ftpgetfilesize
*!* FtpGetFileSize(cRemoteFile)

*!* Returns the size of a remote file

Lparameters m.tcRemoteFile As String

Local ;
	lcRemoteFile, ;
	lnFileSize

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile)

If This.FtpCommand("SIZE " + m.lcRemoteFile) = TRUE Then
	m.lnFileSize = Int(Val(Getwordnum(This.FtpResponseText, 2, " ")))
Else
	m.lnFileSize = -1
Endif

Return m.lnFileSize

*!* FtpGetFileSize does not work as expected for files greater then 4Gb (dwFileSizeHigh always NULL)
*!* http://groups.google.com.ar/group/microsoft.public.windows.inetexplorer.ie5.programming.wininet/browse_thread/thread/3c118ed4c7c32269/791a868311e60a00?lnk=st&q=ftpfindfirstfile+and+large+files&rnum=2&hl=es#791a868311e60a00

*!*	Local ;
*!*		m.lcRemoteFile As String, ;
*!*		m.lnFileSize As Integer

*!*	m.lcRemoteFile = Alltrim(m.tcRemoteFile)

*!*	m.lnFileSize = 0

*!*	*!* FTP PROTOCOL SPECIFIC
*!*	If This._FtpGetFileSize(m.tcRemoteFile, @m.lnFileSize) = FALSE Then
*!*		m.lnFileSize = -1
*!*	Endif

*!*	Return m.lnFileSize

ENDPROC
PROCEDURE ftpopen
*!* FtpOpen(cUrl)

*!* Encapsulates InternetConnect API call

*!* Service
*!*	#DEFINE INTERNET_SERVICE_FTP					1
*!*	#DEFINE INTERNET_SERVICE_GOPHER					2
*!*	#DEFINE INTERNET_SERVICE_HTTP					3

*!* Flags
*!*	INTERNET_FLAG_EXISTING_CONNECT	0x20000000
*!*	INTERNET_FLAG_PASSIVE	0x8000000
*!*	INTERNET_FLAG_SECURE	0x800000

Lparameters m.tcUrl As String

If Empty(m.tcUrl) Or Isnull(m.tcUrl) Then
	Return FALSE
Endif

*!* Before connecting, lets check if we have a valid internet handle,
*!* if not, try to open one:
If This.hInternet = 0 Then
	If This.InternetOpen() = FALSE Then
		Return FALSE
	Endif
Endif

*!* Close any previous InternetConnect open handles:
This.hConnect = This._InternetCloseHandle(This.hConnect)

Local ;
	lcUrlString As String, ;
	lcServerName As String, ;
	lnServerPort As Integer, ;
	lcUserName As String, ;
	lcPassword As String, ;
	lnService As Integer, ;
	lnFlags As Integer, ;
	lnContext As Integer, ;
	lnApiRetVal As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

m.lcUrlString 	= Alltrim(m.tcUrl)

This._InternetCrackUrl(m.lcUrlString)

m.lnService	= INTERNET_SERVICE_FTP

*!* Get value of lnFlags parameter:
m.lnFlags = This._GetFlags()

*!* Get what we have:
m.lcServerName = This.UrlHostName + NULA
m.lnServerPort = This.UrlPort
m.lcUserName   = This.UrlUserName + NULA
m.lcPassword   = This.UrlPassword + NULA

m.lnContext = 0

m.lnApiRetVal = apiInternetConnect( ;
	This.hInternet, ;
	m.lcServerName, ;
	m.lnServerPort, ;
	m.lcUserName, ;
	m.lcPassword, ;
	m.lnService, ;
	m.lnFlags, ;
	m.lnContext)

m.lcFunction = "InternetConnect"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

If m.lnApiRetVal = 0 Then
	*!* This is here so we get response from server
	This._GetLastResponse(m.lcFunction)
Else
	This.hConnect = m.lnApiRetVal
	This._UpdateUrlProperties()
Endif

If m.llRetVal = TRUE And Not Empty(This.UrlPath) Then
	This.FtpSetCurrentDirectory(This.UrlPath)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftppause
This.FtpTransferPaused = TRUE

ENDPROC
PROCEDURE ftpputfile
*!* FtpPutFile(cLocalFile, cRemoteFile)

Lparameters ;
	m.tcLocalFile As String, ;
	m.tcRemoteFile As String

Local ;
	lcRemoteFile, ;
	lcLocalFile, ;
	lnApiRetVal As Integer, ;
	lnFlags As Integer, ;
	lnContext As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

If Vartype(m.tcLocalFile) <> T_CHARACTER Then
	Return FALSE
Endif

If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
	m.tcRemoteFile = Justfname(m.tcLocalFile)
Endif

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile) + NULA
m.lcLocalFile  = Alltrim(m.tcLocalFile) + NULA

*!* Set flags:
m.lnFlags = This._GetFlags()

m.lnContext = 0

m.lnApiRetVal = apiFtpPutFile( ;
	This.hConnect, ;
	m.lcLocalFile, ;
	m.lcRemoteFile, ;
	m.lnFlags, ;
	m.lnContext)

m.lcFunction = "FtpPutFile"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpreadfile
*!* FtpReadFile(cRemoteFile, [cLocalFile])

#Define _MIN_READ_BUFFER_SIZE 1024
#Define _MAX_READ_BUFFER_SIZE 1024 * 1024

#Define _DOEVENTS_INTERVAL 200
#Define _UPDATE_UI_INTERVAL 1000

Lparameters m.tcRemoteFile As String, m.tcLocalFile As String

*!* Reset Cancel/Pause flags to false:
This.FtpTransferCancelled = FALSE
This.FtpTransferPaused 	  = FALSE

If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
	Return FALSE
Endif

*!* Commented, let it fail later
*!*	If This.hConnect = 0 Then
*!*		Return FALSE
*!*	Endif

Local ;
	lcReadBuffer As String, ;
	lnReadBufferSize As Integer, ;
	lnNumberOfBytesRead As Integer, ;
	lnApiRetVal As Integer

Local ;
	lcRemoteFile As String, ;
	lcLocalFile As String, ;
	lnBytesTotal As Integer, ;
	lnBytesComplete As Integer, ;
	lnBytesRead As Integer, ;
	lnBytesLeft As Integer ,;
	lnBytesSpeed As Integer , ;
	lnReadTimeStart As Integer, ;
	lnReadTime As Integer, ;
	lnUpdateTime As Integer, ;
	lnTimeStart As Integer, ;
	lnTimeElapsed As Integer, ;
	lnTimeLeft As Integer, ;
	llRetVal As Boolean, ;
	lcTempFile As String, ;
	lnLocalFileHandle As Integer, ;
	llSaveToFile As Boolean, ;
	lnRemoteFileHandle As Integer

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile)

If Vartype(m.tcLocalFile) <> T_CHARACTER  Then
	m.lcLocalFile = ""
Else
	m.lcLocalFile = Alltrim(m.tcLocalFile)
Endif

*!* If we have a m.lcLocalFile, save to file:
If Not Empty(m.lcLocalFile)  Then
	m.llSaveToFile = TRUE
Else
	m.llSaveToFile = FALSE
Endif

*!* Init Api vars:
m.lnReadBufferSize = _MIN_READ_BUFFER_SIZE
m.lcReadBuffer = Space(m.lnReadBufferSize)
m.lnNumberOfBytesRead = 0

*!* Init Counter vars:
m.lnReadTimeStart = 0
m.lnReadTime = 0
m.lnUpdateTime = _UPDATE_UI_INTERVAL

m.lnTimeStart = apiGetTickCount()
m.lnTimeElapsed = 0
m.lnTimeLeft = 0

If m.llSaveToFile = TRUE Then
	m.lcTempFile = m.lcLocalFile + ".part"
	*!* If we already have a partial temp file "*.part", get its size:
	If File(m.lcTempFile) Then
		m.lnBytesComplete = ctlFsize(m.lcTempFile)
	Else
		m.lnBytesComplete = 0
	Endif
Else
	m.lnBytesComplete = 0
	This.FtpFileData = ""
Endif

*!* Used to store hFile:
m.lnRemoteFileHandle = 0

*!* If FtpGetFileSize fails, it returns -1
m.lnBytesTotal = This.FtpGetFileSize(m.lcRemoteFile)
If m.lnBytesTotal = -1 Then
	m.lnBytesTotal = 0
Endif

*!* FTP PROTOCOL SPECIFIC

*!* Send REST "Resume" command to ftp server, this has to
*!* be done BEFORE we open file
If m.lnBytesComplete > 0 Then
	If This.FtpCommand("REST " + Transform(m.lnBytesComplete)) = TRUE Then

		If This.FtpResponseCode <> 350
			*!* Rest command NOT supported
			m.lnBytesComplete = 0
		Endif
	Else
		*!* FtpCommand failed:
		m.lnBytesComplete = 0
	Endif

Endif

*!* Try to open remote file:
If This._FtpOpenFile(m.lcRemoteFile, GENERIC_READ) = FALSE
	Return FALSE
Endif

m.lnRemoteFileHandle = This.hFile

*!* Prevent negative values:
m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)

m.lnBytesRead = 0
m.lnBytesSpeed = 0

If m.llSaveToFile = TRUE Then
	*!* Create temporary local file if we don't have one or server
	*!* does not support resume:
	If File(m.lcTempFile) = FALSE Or m.lnBytesComplete = 0 Then
		Strtofile("", m.lcTempFile, 0)
	Endif

	*!* Open local temp file:
	m.lnLocalFileHandle = ctlFopen(m.lcTempFile, 2)

	*!* Move file pointer to end of file:
	ctlFseek(m.lnLocalFileHandle, 0, FILE_END)
Endif

With This.FtpTransferInfo
	.FtpRemoteFile 		= m.lcRemoteFile
	.FtpBytesTotal 		= m.lnBytesTotal
	.FtpBytesComplete 	= m.lnBytesComplete
	.FtpBytesLeft 		= m.lnBytesLeft
	.FtpBytesSpeed 		= m.lnBytesSpeed
	.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
	.FtpTimeElapsed 	= m.lnTimeElapsed
	.FtpTimeLeft 		= m.lnTimeLeft
	.FtpStatus			= FALSE
Endwith

Raiseevent(This, "FtpTransferStart")

*!*	This._InternetSetOption(m.lnRemoteFileHandle, INTERNET_OPTION_READ_BUFFER_SIZE , 1024*512)
*!*	vValue = 0
*!*	This._InternetQueryOption(m.lnRemoteFileHandle, INTERNET_OPTION_READ_BUFFER_SIZE , @vValue)
*!*	?vValue


*!* Enter loop where we download file chunks:
Do While TRUE

	*!* This we use to calculate time it takes to read a file chunk
	m.lnReadTimeStart = apiGetTickCount()

	m.lnApiRetVal = apiInternetReadFile( ;
		m.lnRemoteFileHandle, ;
		@m.lcReadBuffer, ;
		m.lnReadBufferSize, ;
		@m.lnNumberOfBytesRead)

	If m.lnApiRetVal = 0 Then
		This._GetLastError("InternetReadFile")
		m.llRetVal = FALSE
	Else
		m.llRetVal = TRUE
	Endif

	*!* This so user can cancel download
	DoEvents

	If This.FtpTransferPaused = TRUE Then
		m.llRetVal = FALSE
	Endif

	If This.FtpTransferCancelled = TRUE Then
		m.llRetVal = FALSE
	Endif

	If m.lnApiRetVal <> 0 Then
		*!* Save data to temp file
		If m.llSaveToFile = TRUE Then
			ctlFwrite(m.lnLocalFileHandle, Left(m.lcReadBuffer, m.lnNumberOfBytesRead))
		Else
			*!* 16711680 bytes is the maximum size of a string in VFP:
			If m.lnBytesRead + m.lnNumberOfBytesRead > VFP_MAX_STRING_SIZE Then
				m.lnNumberOfBytesRead = VFP_MAX_STRING_SIZE - m.lnBytesRead
				m.llRetVal = FALSE
			Endif

			This.FtpFileData = This.FtpFileData + Left(m.lcReadBuffer, m.lnNumberOfBytesRead)
		Endif

		*!* Here we resize read buffer so DoEvents is run every _DOEVENTS_INTERVAL milliseconds
		*!* This depends on download speed

		*!* Calculate time it takes to read a file chunk:
		m.lnReadTime = apiGetTickCount() - m.lnReadTimeStart

		*!* Check for apiGetTickCount overflow after 49,7 days:
		If m.lnReadTime < 0 Then
			m.lnReadTime = 0xffffffff - m.lnReadTimeStart + apiGetTickCount()
		Endif

		*!* We want a _DOEVENTS_INTERVAL milliseconds between each call:

		*!* Adjust read buffer size downward
		If m.lnReadTime > _DOEVENTS_INTERVAL * 2 Then
			m.lnReadBufferSize = m.lnReadBufferSize / 2
		Endif

		*!* Adjust read buffer size upward
		If m.lnReadTime < _DOEVENTS_INTERVAL Then
			m.lnReadBufferSize = m.lnReadBufferSize * 2
		Endif

		*!* Limit read buffer size:
		m.lnReadBufferSize = Max(m.lnReadBufferSize, _MIN_READ_BUFFER_SIZE)
		m.lnReadBufferSize = Min(m.lnReadBufferSize, _MAX_READ_BUFFER_SIZE )
		m.lcReadBuffer = Space(m.lnReadBufferSize)

		*!* Application.StatusBar = m.lnReadBufferSize
		*!* Update byte counters:
		m.lnBytesRead = m.lnBytesRead + m.lnNumberOfBytesRead
		m.lnBytesComplete = m.lnBytesComplete + m.lnNumberOfBytesRead

		*!* Prevent negative values
		m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)

		*!* Update time counters:
		m.lnTimeElapsed = apiGetTickCount() - m.lnTimeStart

		*!* Check for apiGetTickCount overflow after 49,7 days:
		If m.lnTimeElapsed < 0 Then
			m.lnTimeElapsed = 0xffffffff - m.lnTimeStart + apiGetTickCount()
		Endif

		*!* Convert from milliseconds to seconds:
		m.lnTimeElapsed = m.lnTimeElapsed / 1000

		*!* Update average download speed:
		If m.lnTimeElapsed > 0 Then
			m.lnBytesSpeed = m.lnBytesRead / m.lnTimeElapsed
		Endif

		*!* Update estimated time left counter:
		If m.lnBytesSpeed > 0 Then
			m.lnTimeLeft = m.lnBytesLeft / m.lnBytesSpeed
		Else
			m.lnTimeLeft = 0
		Endif

		If m.lnUpdateTime >= _UPDATE_UI_INTERVAL Then

			m.lnTimeElapsed = Round(m.lnTimeElapsed, 0)
			m.lnBytesSpeed = Round(m.lnBytesSpeed, 0)
			m.lnTimeLeft = Round(m.lnTimeLeft, 0)

			With This.FtpTransferInfo
				.FtpRemoteFile 		= m.lcRemoteFile
				.FtpBytesTotal 		= m.lnBytesTotal
				.FtpBytesComplete 	= m.lnBytesComplete
				.FtpBytesLeft 		= m.lnBytesLeft
				.FtpBytesSpeed 		= m.lnBytesSpeed
				.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
				.FtpTimeElapsed 	= m.lnTimeElapsed
				.FtpTimeLeft 		= m.lnTimeLeft
				.FtpStatus			= FALSE
			Endwith

			Raiseevent(This, "FtpTransfer")
			m.lnUpdateTime = 0
		Endif

		m.lnUpdateTime = m.lnUpdateTime + m.lnReadTime

	Endif

	*!* If InternetReadFile has no more data
	If m.lnNumberOfBytesRead = 0 Then
		Exit
	Endif

	If m.llRetVal = FALSE Then
		Exit
	Endif

Enddo

*!* Last Update of counters:
With This.FtpTransferInfo
	.FtpRemoteFile 		= m.lcRemoteFile
	.FtpBytesTotal 		= m.lnBytesTotal
	.FtpBytesComplete 	= m.lnBytesComplete
	.FtpBytesLeft 		= m.lnBytesLeft
	.FtpBytesSpeed 		= m.lnBytesSpeed
	.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
	.FtpTimeElapsed 	= m.lnTimeElapsed
	.FtpTimeLeft 		= m.lnTimeLeft
	.FtpStatus			= FALSE
Endwith

Raiseevent(This, "FtpTransfer")

*!* Close temp file:
If m.llSaveToFile = TRUE Then
	ctlfClose(m.lnLocalFileHandle)
Endif

*!* If download was cancelled:
If This.FtpTransferCancelled = TRUE Then
	If m.llSaveToFile = TRUE Then
		Erase (m.lcTempFile)
	Else
		This.FtpFileData = ""
	Endif
Endif

*!* FTP PROTOCOL SPECIFIC
*!* Close file handle
This.hFile = This._InternetCloseHandle(This.hFile)

*!* Get the last response from server:
This._ClearLastError()
This._GetLastResponse("FtpReadFile")

*!* If response is code 226 Transfer OK:
If This.FtpResponseCode = 226 Then
	m.llRetVal = TRUE
Else
	m.llRetVal = FALSE
Endif

If m.llSaveToFile = TRUE And m.llRetVal = TRUE Then
	*!* Delete previous local file:
	If File(m.lcLocalFile) Then
		Erase (m.lcLocalFile)
	Endif

	*!* Rename ".part" temp file to local file:
	Rename (m.lcTempFile) To (m.lcLocalFile)
Endif

With This.FtpTransferInfo
	.FtpRemoteFile 		= m.lcRemoteFile
	.FtpBytesTotal 		= m.lnBytesTotal
	.FtpBytesComplete 	= m.lnBytesComplete
	.FtpBytesLeft 		= m.lnBytesLeft
	.FtpBytesSpeed 		= m.lnBytesSpeed
	.FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
	.FtpTimeElapsed 	= m.lnTimeElapsed
	.FtpTimeLeft 		= m.lnTimeLeft
	.FtpStatus			= m.llRetVal
Endwith

Raiseevent(This, "FtpTransferEnd")

Return m.llRetVal



ENDPROC
PROCEDURE ftpreadurl
*!* FtpReadURL(cUrl, [cLocalFile])

Lparameters m.tcUrl As String, m.tcLocalFile As String

Local ;
	lcRemoteFile As String, ;
	llRetVal As Boolean

m.llRetVal = This.FtpOpen(m.tcUrl)

If m.llRetVal = TRUE Then
	
	m.lcRemotefile = This.UrlPath + This.UrlExtraInfo

	m.llRetVal = This.FtpReadFile(m.lcRemotefile, m.tcLocalFile)

	This.FtpClose()

Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpremovedirectory
*!* FtpRemoveDirectory(cDirectory)

Lparameters m.tcDirectory As String

Local ;
	lcDirectory as String, ;
	lcFunction As String, ;
	lnApiRetVal as Integer, ;
	llRetVal As Boolean

If Vartype(m.tcDirectory) = T_CHARACTER Then
	m.lcDirectory = Alltrim(m.tcDirectory) + NULA
Else
	m.lcDirectory = "" + NULA
Endif

m.lnApiRetVal = apiFtpRemoveDirectory(This.hConnect, m.lcDirectory)

m.lcFunction = "FtpRemoveDirectory"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftprenamefile
*!* FtpRenameFile(cOldFileName, cNewFileName)

Lparameters m.tcOldFileName As String, m.tcNewFileName As String

Local ;
	lcOldFileName, ;
	lcNewFileName, ;
	lnApiRetVal As Integer, ;
	lcFunction As String, ;
	llRetVal As Boolean

If Vartype(m.tcOldFileName) <> T_CHARACTER ;
		OR Vartype(m.tcNewFileName) <> T_CHARACTER Then
	Return FALSE
Endif

m.lcOldFileName =  This._AddPath(m.tcOldFileName ) + NULA
m.lcNewFileName =  This._AddPath(m.tcNewFileName ) + NULA

m.lnApiRetVal = apiFtpRenameFile( ;
	This.hConnect, ;
	m.lcOldFileName, ;
	m.lcNewFileName)

m.lcFunction = "FtpRenameFile"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftpresponse
*!* This event gets fired every time there is a new FtpResponseCode
ENDPROC
PROCEDURE ftpsetcurrentdirectory
*!* FtpSetCurrentDirectory(cDirectory)

Lparameters m.tcDirectory As String

Local ;
	lcDirectory As String, ;
	lcFunction As String, ;
	lnApiRetVal As Integer, ;
	llRetVal As Boolean

If Vartype(m.tcDirectory) = T_CHARACTER Then
	m.lcDirectory = Alltrim(m.tcDirectory) + NULA
Else
	m.lcDirectory = "" + NULA
Endif

m.lnApiRetVal = apiFtpSetCurrentDirectory(This.hConnect, m.lcDirectory)

m.lcFunction = "FtpSetCurrentDirectory"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
	This._GetLastResponse(m.lcFunction, TRUE)
Endif

Return m.llRetVal

ENDPROC
PROCEDURE ftptransfer
*!* FtpTransfer()
*!* Use this event to update your update feedback


ENDPROC
PROCEDURE ftptransferend
*!* FtpTransferEnd()
*!* Use this event to finalize your update feedback

ENDPROC
PROCEDURE ftptransferstart
*!* FtpTransferStart()
*!* Use this event to setup your update feedback


ENDPROC
PROCEDURE ftpwritefile
*!* FtpWriteFile(cLocalFile, cRemoteFile, lResume)

#Define _MIN_WRITE_BUFFER_SIZE 1024
#Define _MAX_WRITE_BUFFER_SIZE 1024 * 1024

#Define _DOEVENTS_INTERVAL 200
#Define _UPDATE_UI_INTERVAL 1000

Lparameters m.tcRemoteFile As String, m.tcLocalFile As String, m.tlResume As Boolean

*!* Reset Cancel/Pause flags to false:
This.FtpTransferCancelled = FALSE
This.FtpTransferPaused    = FALSE

If Vartype(m.tcLocalFile) <> T_CHARACTER Then
    Return FALSE
Endif

If Vartype(m.tcRemoteFile) <> T_CHARACTER Then
    Return FALSE
Endif

Local ;
    lcLocalFile As String, ;
    lcRemoteFile As String, ;
    lnBytesTotal As Integer, ;
    lnBytesComplete As Integer, ;
    lnLocalFileHandle As Integer, ;
    lnRemoteFileHandle As Integer, ;
    llRetVal As boolean

Local ;
    lcWriteBuffer As String, ;
    lnWriteBufferSize As Integer, ;
    lnNumberOfBytesWriten As Integer, ;
    lnApiRetVal As Integer

Local ;
    lnBytesWriten As Integer, ;
    lnBytesLeft As Integer ,;
    lnBytesSpeed As Integer , ;
    lnWriteTimeStart As Integer, ;
    lnWriteTime As Integer, ;
    lnUpdateTime As Integer, ;
    lnTimeStart As Integer, ;
    lnTimeElapsed As Integer, ;
    lnTimeLeft As Integer

m.llRetVal = TRUE

m.lcRemoteFile = m.tcRemoteFile
m.lcRemoteFile = This._AddPath(m.lcRemoteFile)

m.lcLocalFile = Alltrim(m.tcLocalFile)

m.lnLocalFileHandle = 0
m.lnRemoteFileHandle = 0
m.lnBytesComplete = 0

*!* get size of local file:
m.lnBytesTotal = ctlFsize(m.lcLocalFile)

*!* if we have to append data to remote file
If m.tlResume = TRUE Then
    m.lnBytesComplete = This.FtpGetFileSize(m.lcRemoteFile)
    If m.lnBytesComplete = -1 Then
        m.lnBytesComplete = 0
    Endif

    *!* Send REST "Resume" command to ftp server, this has to
    *!* be done BEFORE we open the remote file
    If m.lnBytesComplete > 0 Then
        If This.FtpCommand("REST " + Transform(m.lnBytesComplete)) = TRUE Then

            If This.FtpResponseCode <> 350
                *!* Rest command NOT supported
                m.lnBytesComplete = 0
            Endif
        Else
            *!* FtpCommand failed:
            m.lnBytesComplete = 0
        Endif

    Endif
Endif

*!* Try to open remote file:
If This._FtpOpenFile(m.lcRemoteFile, GENERIC_WRITE) = FALSE
    Return FALSE
Endif

m.lnRemoteFileHandle = This.hFile

If m.lnRemoteFileHandle = 0 Then
    Return FALSE
Endif

*!* Open local file:
m.lnLocalFileHandle = ctlfOpen(m.lcLocalFile, 0)

*!* Move local file pointer:
ctlFseek(m.lnLocalFileHandle, m.lnBytesComplete, FILE_BEGIN)

*!* Init Counter vars:
m.lnWriteTimeStart = 0
m.lnWriteTime = 0
m.lnUpdateTime = _UPDATE_UI_INTERVAL

m.lnTimeStart = apiGetTickCount()
m.lnTimeElapsed = 0
m.lnTimeLeft = 0

*!* Prevent negative values:
m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)

m.lnBytesWriten = 0
m.lnBytesSpeed = 0

With This.FtpTransferInfo
    .FtpRemoteFile 		= m.lcRemoteFile
    .FtpBytesTotal 		= m.lnBytesTotal
    .FtpBytesComplete 	= m.lnBytesComplete
    .FtpBytesLeft 		= m.lnBytesLeft
    .FtpBytesSpeed 		= m.lnBytesSpeed
    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
    .FtpTimeElapsed 	= m.lnTimeElapsed
    .FtpTimeLeft 		= m.lnTimeLeft
    .FtpStatus			= FALSE
Endwith

Raiseevent(This, "FtpTransferStart")

m.lnWriteBufferSize = _MIN_WRITE_BUFFER_SIZE

*!* Enter loop where we download file chunks:
Do While TRUE

    *!* This we use to calculate time it takes to Write a file chunk
    m.lnWriteTimeStart = apiGetTickCount()

    *!* Read chunk from local file:
    m.lcWriteBuffer = ctlFread(m.lnLocalFileHandle, m.lnWriteBufferSize)
    m.lnWriteBufferSize = Len(m.lcWriteBuffer)
    m.lnNumberOfBytesWriten = 0

    If m.lnWriteBufferSize = 0 Then
        Exit
    Endif

    m.lnApiRetVal = apiInternetWriteFile( ;
        m.lnRemoteFileHandle, ;
        m.lcWriteBuffer, ;
        m.lnWriteBufferSize, ;
        @m.lnNumberOfBytesWriten)

    If m.lnApiRetVal = 0 Then
        This._GetLastError("InternetWriteFile")
        m.llRetVal = FALSE
    Else
        m.llRetVal = TRUE
    Endif

    *!* This so user can cancel download
    DoEvents

    If This.FtpTransferPaused = TRUE Then
        m.llRetVal = FALSE
    Endif

    If This.FtpTransferCancelled = TRUE Then
        m.llRetVal = FALSE
    Endif

    If m.lnApiRetVal <> 0 Then
        *!* Save data to temp file

        *!* Here we resize Write buffer so DoEvents is run every _DOEVENTS_INTERVAL milliseconds
        *!* This depends on download speed

        *!* Calculate time it takes to Write a file chunk:
        m.lnWriteTime = apiGetTickCount() - m.lnWriteTimeStart

        *!* Check for apiGetTickCount overflow after 49,7 days:
        If m.lnWriteTime < 0 Then
            m.lnWriteTime = 0xffffffff - m.lnWriteTimeStart + apiGetTickCount()
        Endif

        *!* We want a _DOEVENTS_INTERVAL milliseconds between each call:

        *!* Adjust Write buffer size downward
        If m.lnWriteTime > _DOEVENTS_INTERVAL * 2 Then
            m.lnWriteBufferSize = m.lnWriteBufferSize / 2
        Endif

        *!* Adjust Write buffer size upward
        If m.lnWriteTime < _DOEVENTS_INTERVAL Then
            m.lnWriteBufferSize = m.lnWriteBufferSize * 2
        Endif

        *!* Limit Write buffer size:
        m.lnWriteBufferSize = Max(m.lnWriteBufferSize, _MIN_WRITE_BUFFER_SIZE)
        m.lnWriteBufferSize = Min(m.lnWriteBufferSize, _MAX_WRITE_BUFFER_SIZE )

        *!* Application.StatusBar = m.lnWriteBufferSize
        *!* Update byte counters:
        m.lnBytesWriten = m.lnBytesWriten + m.lnNumberOfBytesWriten
        m.lnBytesComplete = m.lnBytesComplete + m.lnNumberOfBytesWriten

        *!* Prevent negative values
        m.lnBytesLeft = Max(0, m.lnBytesTotal - m.lnBytesComplete)

        *!* Update time counters:
        m.lnTimeElapsed = apiGetTickCount() - m.lnTimeStart

        *!* Check for apiGetTickCount overflow after 49,7 days:
        If m.lnTimeElapsed < 0 Then
            m.lnTimeElapsed = 0xffffffff - m.lnTimeStart + apiGetTickCount()
        Endif

        *!* Convert from milliseconds to seconds:
        m.lnTimeElapsed = m.lnTimeElapsed / 1000

        *!* Update average download speed:
        If m.lnTimeElapsed > 0 Then
            m.lnBytesSpeed = m.lnBytesWriten / m.lnTimeElapsed
        Endif

        *!* Update estimated time left counter:
        If m.lnBytesSpeed > 0 Then
            m.lnTimeLeft = m.lnBytesLeft / m.lnBytesSpeed
        Else
            m.lnTimeLeft = 0
        Endif

        If m.lnUpdateTime >= _UPDATE_UI_INTERVAL Then

            m.lnTimeElapsed = Round(m.lnTimeElapsed, 0)
            m.lnBytesSpeed = Round(m.lnBytesSpeed, 0)
            m.lnTimeLeft = Round(m.lnTimeLeft, 0)

            With This.FtpTransferInfo
                .FtpRemoteFile 		= m.lcRemoteFile
                .FtpBytesTotal 		= m.lnBytesTotal
                .FtpBytesComplete 	= m.lnBytesComplete
                .FtpBytesLeft 		= m.lnBytesLeft
                .FtpBytesSpeed 		= m.lnBytesSpeed
                .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
                .FtpTimeElapsed 	= m.lnTimeElapsed
                .FtpTimeLeft 		= m.lnTimeLeft
                .FtpStatus			= FALSE
            Endwith

            Raiseevent(This, "FtpTransfer")
            m.lnUpdateTime = 0
        Endif

        m.lnUpdateTime = m.lnUpdateTime + m.lnWriteTime

    Endif

    *!* If InternetWriteFile has no more data
    If m.lnNumberOfBytesWriten = 0 Then
        Exit
    Endif

    If m.llRetVal = FALSE Then
        Exit
    Endif

Enddo

*!* Last Update of counters:
With This.FtpTransferInfo
    .FtpRemoteFile 		= m.lcRemoteFile
    .FtpBytesTotal 		= m.lnBytesTotal
    .FtpBytesComplete 	= m.lnBytesComplete
    .FtpBytesLeft 		= m.lnBytesLeft
    .FtpBytesSpeed 		= m.lnBytesSpeed
    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
    .FtpTimeElapsed 	= m.lnTimeElapsed
    .FtpTimeLeft 		= m.lnTimeLeft
    .FtpStatus			= FALSE
Endwith

Raiseevent(This, "FtpTransfer")

*!* Close local file:

ctlFclose(m.lnLocalFileHandle)

*!* FTP PROTOCOL SPECIFIC
*!* Close file handle
This.hFile = This._InternetCloseHandle(This.hFile)

*!* Get the last response from server:
This._ClearLastError()
This._GetLastResponse("FtpWriteFile")

*!* If response is code 226 Transfer OK:
If This.FtpResponseCode = 226 Then
    m.llRetVal = TRUE
Else
    m.llRetVal = FALSE
Endif

*!* Delete remote file if transfer was cancelled:
If This.FtpTransferCancelled = TRUE Then
    This.FtpDeleteFile(m.lcRemoteFile)
Endif

With This.FtpTransferInfo
    .FtpRemoteFile 		= m.lcRemoteFile
    .FtpBytesTotal 		= m.lnBytesTotal
    .FtpBytesComplete 	= m.lnBytesComplete
    .FtpBytesLeft 		= m.lnBytesLeft
    .FtpBytesSpeed 		= m.lnBytesSpeed
    .FtpTimeTotal 		= m.lnTimeElapsed + m.lnTimeLeft
    .FtpTimeElapsed 	= m.lnTimeElapsed
    .FtpTimeLeft 		= m.lnTimeLeft
    .FtpStatus			= m.llRetVal
Endwith

Raiseevent(This, "FtpTransferEnd")

Return m.llRetVal



ENDPROC
PROCEDURE internetclose
*!* WininetClose()

*!* Closes an open hInternet handle, ends use of wininet

*!* Clear password cache:
This._InternetSetOption(This.hInternet, INTERNET_OPTION_END_BROWSER_SESSION, 0)

This.hInternet = This._InternetCloseHandle(This.hInternet)

ENDPROC
PROCEDURE internetopen
*!* InternetOpen()

*!* Initializes the use of wininet functions

*!* If we already have an Internet Handle, close it
This.InternetClose()

Local ;
	lcAgent As String, ;
	lnAccessType As Integer, ;
	lcProxyName As String, ;
	lcProxyBypass As String, ;
	lnFlags As Integer, ;
	lnApiRetVal As Integer, ;
	lcFunction as String, ;
	llRetVal As Boolean

m.lcAgent 		= Alltrim(This.InternetUserAgent)
m.lnAccessType 	= INTERNET_OPEN_TYPE_PRECONFIG
m.lcProxyName 	= ""
m.lcProxyBypass = ""

*!* Determine if direct connection or proxy:

*!*	#Define INTERNET_OPEN_TYPE_DIRECT						1
*!*	#Define INTERNET_OPEN_TYPE_PRECONFIG					0
*!*	#Define INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY	4
*!*	#Define INTERNET_OPEN_TYPE_PROXY						3

Do Case

Case This.InternetAccessType = INTERNET_OPEN_TYPE_PRECONFIG
	m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG

Case This.InternetAccessType = INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
	m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY

Case This.InternetAccessType = INTERNET_OPEN_TYPE_DIRECT
	m.lnAccessType = INTERNET_OPEN_TYPE_DIRECT

Case This.InternetAccessType = INTERNET_OPEN_TYPE_PROXY

	If Empty(This.InternetProxyName) Then
		m.lnAccessType = INTERNET_OPEN_TYPE_PRECONFIG
	Else
		m.lnAccessType = INTERNET_OPEN_TYPE_PROXY
		m.lcProxyName = Alltrim(This.InternetProxyName)
		m.lcProxyBypass = Alltrim(This.InternetProxyBypass)
	Endif

Endcase

m.lnFlags = This._GetFlagsInternet()

m.lcAgent = m.lcAgent + NULA
m.lcProxyName = m.lcProxyName + NULA
m.lcProxyBypass = m.lcProxyBypass + NULA

m.lnApiRetVal = apiInternetOpen( ;
	m.lcAgent, ;
	m.lnAccessType, ;
	m.lcProxyName, ;
	m.lcProxyBypass, ;
	m.lnFlags)

This.hInternet = m.lnApiRetVal

m.lcFunction = "InternetOpen"

If m.lnApiRetVal = 0 Then
	m.llRetVal = FALSE
	This._GetLastError(m.lcFunction)
Else
	m.llRetVal = TRUE
Endif

Return m.llRetVal


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_addpath 
*_addproperties 
*_addtoarray 
*_clearlasterror 
*_clearlastresponse 
*_fillftpfileinfo 
*_ftpfindfile 
*_ftpgetfilesize 
*_ftpopenfile 
*_ftpreadcommand 
*_getflags 
*_getflagsinternet 
*_getlasterror 
*_getlastresponse 
*_internetclosehandle 
*_internetcrackurl 
*_internetqueryoption 
*_internetsetoption 
*_setproperties 
*_updateurlproperties 
*formatbytes 
*formatseconds 
*ftpaddfs Adds a forward slash to an ftp path
*ftpcancel 
*ftpclose 
*ftpcommand Sends commands directly to an FTP server.
*ftpcreatedirectory 
*ftpdeletefile 
*ftpdirtoarray 
*ftpdirtocursor 
*ftpgetcurrentdirectory Retrieves the current directory for the active FTP session.
*ftpgetfile 
*ftpgetfiledate 
*ftpgetfileinfo 
*ftpgetfilesize 
*ftpopen 
*ftppause 
*ftpputfile 
*ftpreadfile 
*ftpreadurl 
*ftpremovedirectory Removes the specified directory on the FTP server.
*ftprenamefile 
*ftpresponse 
*ftpsetcurrentdirectory Changes to a different working directory on the FTP server.
*ftptransfer 
*ftptransferend 
*ftptransferstart 
*ftpwritefile 
*internetclose 
*internetopen 
^ftpfiles[1,0] 
_memberdata XML Metadata for customizable properties
ctlabout
ctlversion
flagcacheasync
flagcacheifnetfail
flaghyperlink
flagneedfile
flagnocachewrite
flagpassive
flagreload
flagresynchronize
flagtransferbinary
ftpcommanddata
ftperrorcode
ftperrorfunction
ftperrortext
ftpfiledata
ftpfileinfo
ftppassword ITC
ftpresponsecode ITC
ftpresponsefunction
ftpresponsetext ITC
ftptransfercancelled
ftptransferinfo
ftptransferpaused
ftpusername ITC
hconnect
hfile
hfind
hftpcommand
hinternet
internetaccesstype ITC
internetflagasync
internetflagfromcache
internetflagoffline
internetproxybypass
internetproxyname
internetuseragent
optiondebug
urlextrainfo
urlhostname ITC
urlpassword
urlpath
urlport ITC
urlschemecode
urlschemename
urltext
urlusername
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _24Z0TO7YS
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_ftp
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_ftp"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 3
Width = 45
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_ftp

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1WT0713KK
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_gripper
[START PROPERTIES]
BackColor = 140,200,200
Height = 21
Name = "ctl32_gripper"
Width = 96
_memberdata = 
ctlautosize = .T.
ctlscale = 1
ctlstyle = 1
ctlvisible = .T.
[END PROPERTIES]
[START PROTECTED]
_adddotsxp^
_addlines^
_addmousetrap^
_bindevents^
_create^
_getcolors^
_onformactivate^
_onformborderstyle^
_onformresize^
_onmousedown^
_setstyle^
_setvisible^
ctlstyle_assign^
ctlvisible_assign^
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*!* Init()

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

This._Create()
This._BindEvents()



ENDPROC
PROCEDURE _adddotsvista
*!* _AddDotsVista()

*!* This is for Vista, colors are hardcoded

*!* This method creates a container and adds the six square dots
*!* of the gripper, like this:
*!*     #
*!*   # #
*!* # # #

Local ;
	lnx As Integer, ;
	lny As Integer, ;
	lcName As String

*!* Add container that will hold the dots
This.AddObject("oDots6", "Container")

With This.oDots6
	.Anchor = 0
	.BackStyle = 0
	.BorderWidth = 0
	.Height = 17 * This.ctlScale
	.Width = 17 * This.ctlScale

	*!* This is here just in case someone wants to use the dots in 98 or 2000 to look cool,
	*!* we adjust the position slightly
	If ctlIsThemeActive() = TRUE Then
		.Left = This.Width - 17 * This.ctlScale
		.Top = This.Height - 17 * This.ctlScale
	Else
		.Left = This.Width - 16 * This.ctlScale
		.Top = This.Height - 16 * This.ctlScale
	Endif
	.ZOrder(1)
	.Anchor = 12
Endwith

For m.lnx = 7 * This.ctlScale To 13 * This.ctlScale Step 3 * This.ctlScale
	For m.lny = 7 * This.ctlScale To 13 * This.ctlScale Step 3 * This.ctlScale
		*!* Skip 3 unwanted shapes
		If (m.lnx * m.lny) < 88  * This.ctlScale * This.ctlScale
			Loop
		Endif

		*!* Add dot 1
		m.lcName = "o" + Sys(2015)
		This.oDots6.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots6." + m.lcName)
			.Width = 1 * This.ctlScale
			.Height = 1 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(255,255,255)
			.Visible = TRUE
			.Left = m.lnx
			.Top =  m.lny
		Endwith

		*!* Add dot 2
		m.lcName = "o" + Sys(2015)
		This.oDots6.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots6." + m.lcName)
			.Width = 1 * This.ctlScale
			.Height = 1 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(207,207,207)
			.Visible = TRUE
			.Left = m.lnx + 1 * This.ctlScale
			.Top  = m.lny  * This.ctlScale
		Endwith

		*!* Add dot 3
		m.lcName = "o" + Sys(2015)
		This.oDots6.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots6." + m.lcName)
			.Width = 1 * This.ctlScale
			.Height = 1 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(231,231,231)
			.Visible = TRUE
			.Left = m.lnx
			.Top =  m.lny + 1
		Endwith

		*!* Add dot 4
		m.lcName = "o" + Sys(2015)
		This.oDots6.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots6." + m.lcName)
			.Width = 1 * This.ctlScale
			.Height = 1 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(175,175,175)
			.Visible = TRUE
			.Left = m.lnx + 1
			.Top =  m.lny + 1
		Endwith

	Endfor
Endfor

ENDPROC
PROCEDURE _adddotsxp
*!* _AddDots()

*!* This is for XP, colors are hardcoded, are the same in all 3 stock XP themes

*!* This method creates a container and adds the six square dots with
*!* shadow of the gripper, like this:
*!*     #
*!*   # #
*!* # # #

Local ;
	lnx As Integer, ;
	lny As Integer, ;
	lcName As String

*!* Add container that will hold the dots
This.AddObject("oDots5", "Container")

With This.oDots5
	.Anchor = 0
	.BackStyle = 0
	.BorderWidth = 0
	.Height = 17 * This.ctlScale
	.Width = 17 * This.ctlScale

	*!* This is here just in case someone wants to use the dots in 98 or 2000 to look cool,
	*!* we adjust the position slightly
	If ctlIsThemeActive() = TRUE Then
		.Left = This.Width - 17 * This.ctlScale
		.Top = This.Height - 17 * This.ctlScale
	Else
		.Left = This.Width - 16 * This.ctlScale
		.Top = This.Height - 16 * This.ctlScale
	Endif
	.ZOrder(1)
	.Anchor = 12
Endwith

For m.lnx = 6 * This.ctlScale To 14 * This.ctlScale Step 4 * This.ctlScale
	For m.lny = 6 * This.ctlScale To 14 * This.ctlScale Step 4 * This.ctlScale
		*!* Skip 3 unwanted shapes
		If (m.lnx * m.lny) < 84 * This.ctlScale * This.ctlScale
			Loop
		Endif
		*!* Add light dot
		m.lcName = "o" + Sys(2015)
		This.oDots5.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots5." + m.lcName)
			.Width = 2 * This.ctlScale
			.Height = 2 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(255,255,255)
			.Visible = TRUE
			.Left = m.lnx
			.Top =  m.lny
		Endwith
		*!* Add dark dot
		m.lcName = "o" + Sys(2015)
		This.oDots5.AddObject(m.lcName, "Shape")
		With Evaluate("This.oDots5." + m.lcName)
			.Width = 2 * This.ctlScale
			.Height = 2 * This.ctlScale
			.BorderWidth = 0
			.BorderStyle = 0
			.BackColor = Rgb(184,180,163)
			.Visible = TRUE
			.Left = m.lnx - 1 * This.ctlScale
			.Top  = m.lny - 1 * This.ctlScale
		Endwith
	Endfor
Endfor

ENDPROC
PROCEDURE _addlines
*!* _AddLines()

*!* Add a container that will hold 2 labels with Marlett lines character
This.AddObject("oLines", "Container")

With This.oLines
	.Anchor = 0
	.BackStyle = 0
	.BorderWidth = 0
	.Height = 17 * This.ctlScale
	.Width = 17 * This.ctlScale

	*!* This is here just in case someone wants to use the lines in XP, to look "retro",
	*!* we adjust the position slightly
	If ctlIsThemeActive() = TRUE Then
		.Left = This.Width - 17 * This.ctlScale
		.Top  = This.Height - 17 * This.ctlScale
	Else
		.Left = This.Width - 16 * This.ctlScale
		.Top  = This.Height - 16 * This.ctlScale
	Endif
	.ZOrder(1)
	.Anchor = 12
Endwith

*!* Light diagonal lines.
*!* Marlett is a hidden Windows font used to render non themed controls
This.oLines.AddObject("oLines1", "Label")
With This.oLines.oLines1
	.Anchor = 0
	.BackStyle = 0
	.Caption = "o"
	.FontName = "Marlett"
	.FontSize = Int(12 * This.ctlScale)
	.ForeColor = Rgb(255,255,255)
	.Height = .Parent.Height
	.Width = .Parent.Width
	.Left =  0
	.Top =  0
	.Visible = TRUE
Endwith

*!* dark diagonal lines
This.oLines.AddObject("oLines2", "Label")
With This.oLines.oLines2
	.Anchor = 0
	.BackStyle = 0
	.Caption = "p"
	.FontName = "Marlett"
	.FontSize = 12 * This.ctlScale
	.ForeColor = Rgb(184,180,163)
	.Height = .Parent.Height
	.Width = .Parent.Width
	.Left = 0
	.Top = 0
	.Visible = TRUE
Endwith


ENDPROC
PROCEDURE _addmousetrap
*!* _AddMouseTrap()

This.AddObject("oMouseTrap", "Shape")

With This.oMouseTrap
	.Anchor = 0
	.BackStyle = 0
	.BorderStyle = 0
	.Height = This.Height
	.Width = This.Width
	.Left = 0
	.MousePointer = MOUSE_SIZE_NW_SE
	.Top = 0
	.Visible = TRUE
	.ZOrder(0)
	.Anchor = 15
Endwith
ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

Bindevent(Thisform, "Activate", This, "_OnFormActivate", 1)

*!* 20070723 WM_NCHITTEST not used any more, now we use oMouseTrap.MouseDown
*!* Anton

Bindevent(This.oMouseTrap, "MouseDown", This, "_OnMouseDown", 1)

Bindevent(Thisform, "BorderStyle", This, "_OnFormBorderStyle", 1)
Bindevent(Thisform, "Resize", This, "_OnFormResize", 1)

ENDPROC
PROCEDURE _create
*!* _Create()

*!* If XP and theme active, draw dots, else draw lines
*!* We dont care about _screen.themes or thisform.themes
*!* because is the non-client frame that determines the grip
*!* style (the form border themed or not)

With This
	.BackStyle = 0
	.BorderWidth = 0
	.Anchor = 0
	If .ctlAutoSize = TRUE Then
		.Height = Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT) * This.ctlScale
		.Width =  Sysmetric(SYSMETRIC_VSCROLLBARWIDTH) * This.ctlScale
	Endif
	.Left = Thisform.Width - This.Width
	.Top = Thisform.Height - This.Height
	.Anchor = 12
	.ZOrder(0)
Endwith

This._AddLines()
This._AddDotsXP()
This._AddDotsVista()
This._AddMouseTrap()

This._SetStyle()
This._SetVisible()

ENDPROC
PROCEDURE _getcolors
*!* _GetColors()

Local ;
	lnColor, ;
	lnTheme, ;
	lnApiRetVal

m.lnColor = 0
m.lnTheme = 0
m.lnApiRetVal = -1

This._Color1 = apiGetSysColor(COLOR_3DSHADOW) &&COLOR_BTNSHADOW)
This._Color2 = apiGetSysColor(COLOR_3DHIGHLIGHT) &&COLOR_BTNHIGHLIGHT)

*!*	If ctlIsThemeActive() Then
*!*		m.lnTheme = apiOpenThemeData(0, VSCLASS_STATUS)
*!*		If m.lnTheme <> 0 Then

*!*			If apiGetThemeColor(m.lnTheme, SP_GRIPPER, 0, TMT_FILLCOLORHINT, @m.lnColor) = ERROR_SUCCESS Then
*!*				This._Color1 = m.lnColor
*!*			Endif

*!*			If apiGetThemeColor(m.lnTheme, SP_GRIPPER, 0, TMT_EDGEHIGHLIGHTCOLOR, @m.lnColor) = ERROR_SUCCESS Then
*!*				This._Color2 = m.lnColor
*!*			Endif
*!*			apiCloseThemeData(m.lnTheme)
*!*		Endif
*!*	Endif


ENDPROC
PROCEDURE _onformactivate
*!* _OnFormActivate

*!* Just in case anyone did a zOrder() of a control that 
*!* is over this control, after the control Init:
This.ZOrder(0)


ENDPROC
PROCEDURE _onformborderstyle
*!* _OnFormBorderStyle

This._SetVisible()

ENDPROC
PROCEDURE _onformresize
*!* _OnFormResize

This._SetVisible()
ENDPROC
PROCEDURE _onmousedown
*!* _OnMouseDown(nButton, nShift, nXCoord, nYCoord)

Lparameters nButton, nShift, nXCoord, nYCoord

*!* Here we send a WM_LBUTTONDOWN message to the window, with the coordinates of the right
*!* bottom point of the form.

If m.nButton = BUTTON_LEFT Then

    Local lnLparam As Integer

    *!*	The low-order word specifies the x-coordinate of the cursor.
    *!*	The high-order word specifies the y-coordinate of the cursor.
    *!*	The coordinates are relative to the upper-left corner of the client area.
    *!* MAKELPARAM

    *!* 20070831 Added some pixels to Width and Height, so it works right in
    *!* Windows Vista.
    m.lnLparam = (Thisform.Width + SYSMETRIC(SYSMETRIC_SIZINGBORDERWIDTH) / 2) ;
    + (Thisform.Height + SYSMETRIC(SYSMETRIC_SIZINGBORDERHEIGHT) / 2) * 0x10000

    m.lnLparam = Thisform.Width + 2 ;
    + (Thisform.Height + 2) * 0x10000


    *Thisform.Show()
    apiSendMessage(Thisform.HWnd, WM_LBUTTONDOWN, MK_LBUTTON, m.lnLparam)  
    *!* Let Windows proccess the message while the user drags the gripper:
    DoEvents
Endif

ENDPROC
PROCEDURE _setstyle
*!* _SetStyle()

This.oLines.Visible = FALSE
This.oDots5.Visible = FALSE
This.oDots6.Visible = FALSE

Do Case
	Case This.ctlstyle = 2	&& Lines
		This.oLines.Visible = TRUE

	Case This.ctlstyle = 3	&& Dots
		This.oDots5.Visible = TRUE

	Otherwise
		&& we choose dots if XP and theme active
		If ctlIsThemeActive(Thisform) = TRUE Then
			If ctlGetOsVersion() < NTDDI_VISTA
				This.oDots5.Visible = TRUE
			Else
				This.oDots6.Visible = TRUE
			Endif
		Else
			This.oLines.Visible = TRUE
		Endif
Endcase

ENDPROC
PROCEDURE _setvisible
*!* _SetVisible()

Local llVisible As Boolean

m.llVisible = TRUE

If Thisform.BorderStyle # BORDER_SYSTEM
	m.llVisible = FALSE
Endif

If Thisform.WindowState = WINDOWSTATE_MAXIMIZED
	m.llVisible = FALSE
Endif

If This.ctlVisible = FALSE
	m.llVisible = FALSE
Endif

If This.Visible <> m.llVisible Then
	This.Visible = m.llVisible
Endif

ENDPROC
PROCEDURE ctlstyle_assign
*!* ctlStyle_Assign()

Lparameters vNewVal

This.ctlstyle = m.vNewVal

This._SetStyle()

ENDPROC
PROCEDURE ctlvisible_assign
*!* ctlVisible_Assign()

Lparameters vNewVal

This.ctlVisible = m.vNewVal

This._SetVisible()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_adddotsvista 
*_adddotsxp 
*_addlines 
*_addmousetrap 
*_bindevents 
*_create 
*_getcolors 
*_onformactivate 
*_onformborderstyle 
*_onformresize 
*_onmousedown 
*_setstyle 
*_setvisible 
*ctlstyle_assign 
*ctlvisible_assign 
_memberdata XML Metadata for customizable properties
ctlautosize
ctlscale
ctlstyle Specifies the style of sizing grip.
ctlvisible
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1WU0MMMVT
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_gripper
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_gripper"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 4
Width = 65
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_gripper

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CI0AZUG7
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_monthcalendar
[START PROPERTIES]

BorderWidth = 1
Height = 161
Name = "ctl32_monthcalendar"
Width = 247
_calendarheight = 0
_calendarwidth = 0
_columns = 1
_daystatesaddress = 0
_hasfocuscue = .F.
_memberdata =      733<VFPData><memberdata name="ctlsinglemonthwidth_access" type="method" display="ctlsinglemonthwidth_Access"/><memberdata name="ctlannuallyboldeddates" type="method" display="ctlannuallyboldeddates"/><memberdata name="ctlannuallyboldeddates" type="method" display="ctlannuallyboldeddates"/><memberdata name="ctlboldeddates" type="method" display="ctlboldeddates"/><memberdata name="ctlmonthlyboldeddates" type="method" display="ctlmonthlyboldeddates"/><memberdata name="ctlmonthlyboldeddates" type="method" display="ctlmonthlyboldeddates"/><memberdata name="ctlselectionend_access" type="method" display="ctlselectionend_Access"/><memberdata name="ctlselectionstart_access" type="method" display="ctlselectionstart_Access"/></VFPData>
_rows = 1
_showtodayheight = 0
_showweeknumberswidth = 0
_todaydateset = .F.
ctlTextBox.Name = "ctlTextBox"
ctlborderwidth = 0
ctlcalendardimensionsheight = 1
ctlcalendardimensionswidth = 1
ctlcanfocus = .T.
ctldefaultmonthbackcolor = 0
ctldefaulttitlebackcolor = 0
ctldefaulttitleforecolor = 0
ctldefaulttrailingforecolor = 0
ctlfirstdayofweek = 0
ctlmaxdate = {^9998/12/31}
ctlmaxselectioncount = 1
ctlmindate = {^1800/01/01}
ctlscrollchange = 0
ctlselectionend = {}
ctlselectionstart = {}
ctlshowtoday = .T.
ctlshowtodaycircle = .T.
ctlshowweeknumbers = .F.
ctlsinglemonthheight = 0
ctlsinglemonthwidth = 0
ctltitlebackcolor = -1
ctltitleforecolor = -1
ctltodaydate = {}
ctltodaydateset = .F.
ctltrailingforecolor = -1
ctlvalue = (date())
lblname.Caption = "ctl32_monthcalendar"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE Destroy
DoDefault()

If This._DayStatesAddress # 0 Then
	apiHeapFree(apiGetProcessHeap(), 0, This._DayStatesAddress)
Endif

ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

DoDefault()

Bindevent(This.ctlHostFormhWnd, WM_NOTIFY, This, "_OnWindowMessage", 4)

ENDPROC
PROCEDURE _daystatessetup
*!* _DayStatesSetup()

Local lnx As Integer

For m.lnx = 1 To 13
	If Vartype(This._DayStates(m.lnx)) # T_VARBINARY Then
		This._DayStates(m.lnx) = 0h00000000
	Endif
Endfor



ENDPROC
PROCEDURE _getdefaultsize
*!* _GetDefaultSize()

*!* This method finds and stores the default calendar height and width
*!* The width of the weeks column and the height of the showtoday line

*!* This method is not necessary in Vista, where we use MCM_SIZERECTTOMIN to
*!* get the size of the window needed to display the calendar(s)

*!* _CalendarHeight
*!* _CalendarWidth
*!* _ShowTodayHeight
*!* _ShowWeekNumbersWidth

Local ;
	lnStyle As Integer, ;
	lnOldStyle As Integer, ;
	loRect As ctlRect, ;
	lcRect As String

If This._DefaultHeight = 0 Then
	This._DefaultHeight = This.Height
	This._DefaultWidth = This.Width
Endif

*!* Get current styles:
m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)
m.lnOldStyle = m.lnStyle

*!* Remove week numbers
m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
m.lnStyle = Bitxor(m.lnStyle, MCS_WEEKNUMBERS)

*!* Do not show today date
m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)

*!* Set style:
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)

*!* Calc control size:
m.loRect = Createobject("CTLRECT")

m.lcRect = m.loRect.Value

apiSendMessage(This._ControlHwnd, MCM_GETMINREQRECT, 0, @m.lcRect)

m.loRect.Value = m.lcRect

This._CalendarHeight 	= m.loRect.Height
This._CalendarWidth 	= m.loRect.Width

*!* Add week numbers
m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)

*!* Add Today date
m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAY)

*!* Set style:
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)

*!* Calc control size:

apiSendMessage(This._ControlHwnd, MCM_GETMINREQRECT, 0, @m.lcRect)

m.loRect.Value = m.lcRect

*!* Calc height of show today and width of week numbers:
This._ShowTodayHeight 		= m.loRect.Height - This._CalendarHeight
This._ShowWeekNumbersWidth 	= m.loRect.Width - This._CalendarWidth

*!* Reset style:
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnOldStyle)

ENDPROC
PROCEDURE _getdwstyle
*!* _GetdwStyle()

Local dwStyle As Integer

m.dwStyle = Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, MCS_DAYSTATE) &&, WS_TABSTOP, WS_POPUP) WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS,

If This.ctlShowToday = FALSE Then
	m.dwStyle = Bitor(m.dwStyle, MCS_NOTODAY)
Endif

If This.ctlShowTodayCircle = FALSE Then
	m.dwStyle = Bitor(m.dwStyle, MCS_NOTODAYCIRCLE)
Endif

If This.ctlShowWeekNumbers = TRUE Then
	m.dwStyle = Bitor(m.dwStyle, MCS_WEEKNUMBERS)
Endif

Return m.dwStyle

ENDPROC
PROCEDURE _getlpclassname
*!* _GetlpClassName()

Return MONTHCAL_CLASSA

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

DoDefault()

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_NOTIFY

		*!* Get NMHDR structure from pointer
		Local m.loNMHdr As CTLNMHDR
		m.loNMHdr = Createobject("CTLNMHDR", Thisform._2ce01ty4y_lParam)

		*!* If the message is not for this control, just return
		If m.loNMHdr.hwndFrom # This._ControlHwnd Then
			m.loNMHdr = .Null.
			Return
		Endif

		Do Case

				*!* The selected date was changed
			Case m.loNMHdr.Code = MCN_SELCHANGE
				Local m.loSelChange As ctlNMSELCHANGE
				m.loSelChange = Createobject("ctlNMSELCHANGE", Thisform._2ce01ty4y_lParam)
				With m.loSelChange.stSelStart
					This.ctlValue = Date(.wYear, .wMonth, .wDay)
				Endwith
				m.loSelChange = .Null.

				*!* requestS information about how individual days should be displayed
			Case m.loNMHdr.Code = MCN_GETDAYSTATE
				Local m.loNmDayState As ctlNmDayState
				m.loNmDayState = Createobject("ctlNMDAYSTATE", Thisform._2ce01ty4y_lParam)
				With m.loNmDayState.stStart
					This._UpdateDayStates(Date(.wYear, .wMonth, .wDay), m.loNmDayState.cDayState)
				Endwith
				m.loNmDayState.prgDayState = This._DayStatesAddress
				m.loNmDayState = .Null.
		Endcase

		m.loNMHdr = .Null.

Endcase



ENDPROC
PROCEDURE _postcreate
*!* _PostCreate()

This._DayStatesSetup()

This._SetScrollChange()
This._SetRange()
This._SetAutoSize()
This._SetBackColor()
This._SetBorderColor()
This._SetFirstDayOfWeek()
This._SetForeColor()
This._SetTitleBackColor()
This._SetTitleForeColor()
This._SetTrailingForeColor()

This.ctlUpdateBoldedDates()

*This._GetDefaultColors()
*This._GetCalendarMetrics()


ENDPROC
PROCEDURE _setautosize
*!* _SetAutoSize()

Local ;
	lnWidth As Integer, ;
	lnHeight As Integer, ;
	lnWidthMargin As Integer, ;
	lnHeightMargin As Integer, ;
	loRect As ctlRect, ;
	lcRect As String

If This.ctlAutoSize = FALSE Then
	This.Height = This._DefaultHeight
	This.Width = This._DefaultWidth
	Return
Endif

*!* Determine Width padding:
m.lnWidthMargin = 6 * (This.ctlCalendarDimensionsWidth - 1)

If This.ctlShowWeekNumbers = TRUE Then
	m.lnWidthMargin = m.lnWidthMargin + This._ShowWeekNumbersWidth * This.ctlCalendarDimensionsWidth
Endif

*!* Determine Height padding:
m.lnHeightMargin = 6 * (This.ctlCalendarDimensionsHeight - 1)

*!* Always add _ShowTodayHeight
m.lnHeightMargin = m.lnHeightMargin + This._ShowTodayHeight

*!* Determine width and height:
m.lnWidth = This._CalendarWidth * This.ctlCalendarDimensionsWidth + m.lnWidthMargin
m.lnHeight = This._CalendarHeight * This.ctlCalendarDimensionsHeight + m.lnHeightMargin

*!* In Vista, we use MCM_SIZERECTTOMIN to get the exact window size:
If ctlGetOsVersion() = CON_OS_WINVISTA Then

	*!* Determine Top and Left of Calendar window:
	*!*		m.lnLeft = This.ctlLocationLeft
	*!*		m.lnTop  = This.ctlLocationTop

	*!* add half a calendar width and height just in case:
	m.lnWidth = m.lnWidth + Int(This._CalendarWidth / 2)
	m.lnHeight = m.lnHeight + Int(This._CalendarHeight / 2)

	m.loRect = Createobject("ctlRect")
	m.lcRect = m.loRect.Value

	m.loRect.Left   = 0
	m.loRect.Top    = 0
	m.loRect.Right  = m.lnWidth

	m.loRect.Bottom = m.lnHeight

	m.lcRect = m.loRect.Value

	apiSendMessage(This._ControlHwnd, MCM_SIZERECTTOMIN, 0, @m.lcRect)

	m.loRect.Value = m.lcRect

	*!* Here we have exact width and height of Calendar window:
	m.lnWidth = m.loRect.Width
	m.lnHeight = m.loRect.Height

Endif

*!* Up to here we have standard width and height needed to display
*!* number of calendars specified in ctlCalendarDimensionsHeight and ctlCalendarDimensionsWidth

*!* Add specified border:
m.lnHeight = m.lnHeight + This.ctlBorderWidth * 2
m.lnWidth = m.lnWidth + This.ctlBorderWidth * 2


*!* Now we will make minor adjustments:

*!*	Do Case

*!*			*!* If we are in a toolbar, we adjust the size of oBorder so the toolbar
*!*			*!* sizes just right to contain calendar window
*!*		Case This.Parent.BaseClass = "Toolbar"

*!*			Thisform.BackColor = This._DefaultMonthBackColor
*!*			m.lnLeft = m.lnLeft - 6
*!*			m.lnTop = m.lnTop - 2

*!*			This.Height = m.lnHeight - 6
*!*			This.Width = m.lnWidth - 6 - 6


*!*			*!*			With Evaluate(This._BorderName)
*!*			*!*				.Height = m.lnHeight - 5
*!*			*!*				.Width = m.lnWidth - 6 - 6
*!*			*!*			Endwith

*!*			*!* If we are in Vista with themes, do not use border, control has one:
*!*		Case ctlGetOsVersion() >= CON_OS_WINVISTA And ;
*!*				This.ctlIsThemeActive(This) = TRUE

*!*			*!*			With Evaluate(This._BorderName)
*!*			*!*				.Left = This.Left
*!*			*!*				.Top = This.Top
*!*			*!*				.Height = m.lnHeight
*!*			*!*				.Width = m.lnWidth
*!*			*!*			Endwith

*!*		Otherwise

*!*			This.Height = m.lnHeight
*!*			This.Width = m.lnWidth

*!*			*!*			With Evaluate(This._BorderName)
*!*			*!*				.Left = This.Left
*!*			*!*				.Top = This.Top
*!*			*!*				.Height = m.lnHeight + 2
*!*			*!*				.Width = m.lnWidth + 2
*!*			*!*			Endwith

*!*	Endcase

This.Height = m.lnHeight
This.Width = m.lnWidth

ENDPROC
PROCEDURE _setbackcolor
*!* _SetBackColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlBackColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_MONTHBK, This.ctlDefaultBackColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_MONTHBK, This.ctlBackColor)
Endif
ENDPROC
PROCEDURE _setbordercolor
*!* _SetBorderColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlBorderColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_BACKGROUND, This.ctlDefaultBorderColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_BACKGROUND, This.ctlBorderColor)
Endif
ENDPROC
PROCEDURE _setborderwidth
This._SetAutoSize()

ENDPROC
PROCEDURE _setcalendarcolumns
This._SetAutoSize()

ENDPROC
PROCEDURE _setcalendarrows
This._SetAutoSize()

ENDPROC
PROCEDURE _setfirstdayofweek
*!* _SetFirstDayOfWeek()


*!* API   FOX
*!*	MON 0 2 -2
*!*	TUE 1 3 -2
*!*	WED 2 4 -2
*!*	THU 3 5 -2
*!*	FRI 4 6 -2
*!*	SAT 5 7 -2
*!*	SUN 6 1
*!* def 7 0

If This._ControlHwnd = 0 Then
	Return
Endif

Local m.lnDayOfWeek As Integer

*!* Convert VFP DOW to API DOW
Do Case
	Case This.ctlFirstDayOfWeek = 0
		m.lnDayOfWeek = -1
	Case This.ctlFirstDayOfWeek = 1
		m.lnDayOfWeek = 6
	Otherwise
		m.lnDayOfWeek = This.ctlFirstDayOfWeek - 2
Endcase

apiSendMessage(This._ControlHwnd, MCM_SETFIRSTDAYOFWEEK, 0, m.lnDayOfWeek)

*!*	?ctlHiWord(apiSendMessage(This._ControlHwnd, MCM_GETFIRSTDAYOFWEEK, 0, 0))
*!*	??ctlLoWord(apiSendMessage(This._ControlHwnd, MCM_GETFIRSTDAYOFWEEK, 0, 0))


ENDPROC
PROCEDURE _setfont
*!* _SetFont()

If This._ControlHwnd = 0 Then
	Return
Endif

If This._EnableUpdates = FALSE Then
	Return
Endif

DoDefault()

This._GetDefaultSize()
This._SetAutoSize()

ENDPROC
PROCEDURE _setforecolor
*!* _SetForeColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlForeColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TEXT, This.ctlDefaultForeColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TEXT, This.ctlForeColor)
Endif
ENDPROC
PROCEDURE _setrange
*!* _SetRange()

If This._ControlHwnd = 0 Then
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

Local ;
	lpSysTime As ctlSystemTime, ;
	lcSysTime As String

m.lpSysTime = Createobject("ctlSystemTime")

With This
	m.lpSysTime.wYear = Year(.ctlMinDate)
	m.lpSysTime.wMonth = Month(.ctlMinDate)
	m.lpSysTime.wDayOfWeek = Dow(.ctlMinDate)
	m.lpSysTime.wDay = Day(.ctlMinDate)
	m.lcSysTime = m.lpSysTime.Value

	m.lpSysTime.wYear = Year(.ctlMaxDate)
	m.lpSysTime.wMonth = Month(.ctlMaxDate)
	m.lpSysTime.wDayOfWeek = Dow(.ctlMinDate)
	m.lpSysTime.wDay = Day(.ctlMaxDate)
	m.lcSysTime = m.lcSysTime + m.lpSysTime.Value
Endwith

m.lpSysTime = .Null.

apiSendMessage(This._ControlHwnd, MCM_SETRANGE, GDTR_MIN + GDTR_MAX, m.lcSysTime)


ENDPROC
PROCEDURE _setscrollchange
*!* _SetScrollChange()

If This._ControlHwnd = 0 Then
	Return
Endif

apiSendMessage(This._ControlHwnd, MCM_SETMONTHDELTA, This.ctlScrollChange, 0)
ENDPROC
PROCEDURE _setshowtoday
*!* _SetShowToday()

Local lnStyle As Integer

*!* Get current styles:
m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

*!* Remove week numbers
m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAY)

If This.ctlShowToday = FALSE Then
	*!* Add week numbers
	m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAY)
Endif

apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)

This._SetAutoSize()
ENDPROC
PROCEDURE _setshowtodaycircle
*!* _SetShowTodayCircle()

Local lnStyle As Integer

*!* Get current styles:
m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

*!* Remove week numbers
m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAYCIRCLE)
m.lnStyle = Bitxor(m.lnStyle, MCS_NOTODAYCIRCLE)

If This.ctlShowTodayCircle = FALSE Then
	*!* Add week numbers
	m.lnStyle = Bitor(m.lnStyle, MCS_NOTODAYCIRCLE)
Endif

apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)

This._SetAutoSize()
ENDPROC
PROCEDURE _setshowweeknumbers
*!* _SetShowWeekNumbers()

Local lnStyle As Integer

*!* Get current styles:
m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

*!* Remove week numbers
m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
m.lnStyle = Bitxor(m.lnStyle, MCS_WEEKNUMBERS)

If This.ctlShowWeekNumbers = TRUE Then
	*!* Add week numbers
	m.lnStyle = Bitor(m.lnStyle, MCS_WEEKNUMBERS)
Endif

apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnStyle)

This._SetAutoSize()
ENDPROC
PROCEDURE _setthemes
DoDefault()

This._SetAutoSize()

ENDPROC
PROCEDURE _settitlebackcolor
*!* _SetTitleBackColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlTitleBackColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLEBK, This.ctlDefaultTitleBackColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLEBK, This.ctlTitleBackColor)
Endif
ENDPROC
PROCEDURE _settitleforecolor
*!* _SetTitleForeColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlTitleForeColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLETEXT, This.ctlDefaultTitleForeColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TITLETEXT, This.ctlTitleForeColor)
Endif
ENDPROC
PROCEDURE _settodaydate
*!* _SetTodaydate()

?This.ctlTodayDate
If Empty(This.ctlTodayDate) Then
	This._TodayDateSet = FALSE
Else
	This._TodayDateSet = TRUE
Endif

If This._ControlHwnd = 0 Then
	Return
Endif

Local lcSysTime As String, lpSysTime As ctlSystemTime

If Empty(This.ctlTodayDate) Then
	apiSendMessage(This._ControlHwnd, MCM_SETTODAY , 0, 0)
Else
	m.lpSysTime = Createobject("ctlSystemTime")
	m.lpSysTime.wYear = Year(This.ctlTodayDate)
	m.lpSysTime.wMonth = Month(This.ctlTodayDate)
	m.lpSysTime.wDay = Day(This.ctlTodayDate)
	m.lcSysTime = m.lpSysTime.Value
	m.lpSysTime = .Null.
	apiSendMessage(This._ControlHwnd, MCM_SETTODAY , 0, lcSysTime)
Endif

ENDPROC
PROCEDURE _settrailingforecolor
*!* _SetTrailingForeColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlTrailingForeColor = -1 Then
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TRAILINGTEXT, This.ctlDefaultTrailingForeColor)
Else
	apiSendMessage(This._ControlHwnd, MCM_SETCOLOR, MCSC_TRAILINGTEXT, This.ctlTrailingForeColor)
Endif
ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

DoDefault()

If This._ControlHwnd = 0
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

Local lcSysTime As String, lpSysTime As ctlSystemTime

m.lpSysTime = Createobject("ctlSystemTime")

m.lpSysTime.wYear = Year(This.ctlValue)
m.lpSysTime.wMonth = Month(This.ctlValue)
m.lpSysTime.wDay = Day(This.ctlValue)

m.lcSysTime = m.lpSysTime.Value
m.lpSysTime = .Null.

apiSendMessage(This._ControlHwnd, MCM_SETCURSEL , 0, m.lcSysTime)


ENDPROC
PROCEDURE _updatecolors
*!* _UpdateColors()

This._SetBackColor()
This._SetBorderColor()
This._SetForeColor()
This._SetTitleBackColor()
This._SetTitleForeColor()
This._SetTrailingForeColor()

ENDPROC
PROCEDURE _updatedaystates
*!* _UpdateDayStates()

*!* 32 bits * 14 months = 448 bits
*!* 32 bits * 14 months / 8 bytes = 56 bytes

Lparameters pdStartDate As Date, pnMonths As Integer

Local ;
	ldStartDate As Date, ;
	ldDate As Date, ;
	lcMonthDayState As String, ;
	lcDayState As String, ;
	lnMonthIdx As Integer, ;
	lnBitIdx As Integer, ;
	lnIndex As Integer, ;
	lnMonth As Integer

*!* Allocate the buffer for the daystates array if not yet allocated:
If This._DayStatesAddress = 0 Then
	This._DayStatesAddress = apiHeapAlloc(apiGetProcessHeap(), HEAP_ZERO_MEMORY, 56)
Endif

*!* Array of days
m.lcMonthDayState = ""

*!* StartDate should be always the first day of a month
m.ldStartDate = Date(Year(m.pdStartDate), Month(m.pdStartDate), 1)

*!* Init date for first month
m.ldDate = m.ldStartDate

For m.lnMonthIdx = 1 To m.pnMonths

	*!* Array of days for one month
	*m.lcDayState = 0h00000000

	*!* Save current month # so we can check if we finished with month
	m.lnMonth = Month(m.ldDate)

	m.lcDayState = Bitor(This._DayStates(m.lnMonth), This._DayStates(13))

	For m.lnBitIdx  = 0 To 30

		*!* Do we have any dates in WeeklyBoldedDates?
		If Vartype(This.ctlWeeklyBoldedDates(1)) = T_DATE
			For m.lnIndex = 1 To Alen(This.ctlWeeklyBoldedDates, 1)
				If Dow(m.ldDate) = Dow(This.ctlWeeklyBoldedDates(m.lnIndex)) Then
					m.lcDayState = Bitset(m.lcDayState, m.lnBitIdx , 1)
				Endif
			Endfor
		Endif

		*!* Do we have any dates in BoldedDates?
		If Vartype(This.ctlBoldedDates(1)) = T_DATE
			For m.lnIndex= 1 To Alen(This.ctlBoldedDates, 1)
				If m.ldDate = This.ctlBoldedDates(m.lnIndex) Then
					m.lcDayState = Bitset(m.lcDayState, m.lnBitIdx , 1)
				Endif
			Endfor
		Endif

		*!* Do next day in month
		m.ldDate = m.ldDate + 1

		*!* Are we still in the same month?
		If Month(m.ldDate) # m.lnMonth
			Exit
		Endif
	Endfor

	*!* We finished one month, add array of days of month to array of days:
	m.lcMonthDayState = m.lcMonthDayState + m.lcDayState

	*!* go to first day of next month:
	m.ldDate = Gomonth(m.ldStartDate, m.lnMonthIdx)
Endfor

*!* pad 'array' to cover 14 months always 
*!* 14 months * 4 bytes each = 56 bytes
m.lcMonthDayState = Padr(m.lcMonthDayState, 56, 0h00)

*!* Write array back to memory pointer:
Sys(2600, This._DayStatesAddress, Len(m.lcMonthDayState), m.lcMonthDayState)

ENDPROC
PROCEDURE ctladdannuallyboldeddate
*!* ctlAddAnnuallyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
	lnRows As Integer

m.lnRows = Alen(This.ctlAnnuallyBoldedDates, 1)

If Vartype(This.ctlAnnuallyBoldedDates(m.lnRows)) # T_LOGICAL Then
	m.lnRows = m.lnRows + 1
Endif

Dimension This.ctlAnnuallyBoldedDates(m.lnRows)

This.ctlAnnuallyBoldedDates(m.lnRows) = m.tdDate

*!* Update DayState string for month:
This._DayStates(Month(m.tdDate)) = Bitset(This._DayStates(Month(m.tdDate)), Day(m.tdDate) - 1 , 1)


ENDPROC
PROCEDURE ctladdboldeddate
*!* ctlAddBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local lnRows As Integer

m.lnRows = Alen(This.ctlBoldedDates, 1)

If Vartype(This.ctlBoldedDates(m.lnRows)) # T_LOGICAL Then
	m.lnRows = m.lnRows + 1
Endif

Dimension This.ctlBoldedDates(m.lnRows)

This.ctlBoldedDates(m.lnRows) = m.tdDate


ENDPROC
PROCEDURE ctladdmonthlyboldeddate
*!* ctlAddMonthlyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
lnRows As Integer

m.lnRows = Alen(This.ctlMonthlyBoldedDates, 1)

If Vartype(This.ctlMonthlyBoldedDates(m.lnRows)) # T_LOGICAL Then
	m.lnRows = m.lnRows + 1
Endif

Dimension This.ctlMonthlyBoldedDates(m.lnRows)

This.ctlMonthlyBoldedDates(m.lnRows) = m.tdDate

*!* Update DayState string for monthly days:
This._DayStates(13) = Bitset(This._DayStates(13), Day(m.tdDate) - 1 , 1)

ENDPROC
PROCEDURE ctladdweeklyboldeddate
*!* ctlAddWeeklyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local lnRows As Integer

m.lnRows = Alen(This.ctlWeeklyBoldedDates, 1)

If Vartype(This.ctlWeeklyBoldedDates(m.lnRows)) # T_LOGICAL Then
	m.lnRows = m.lnRows + 1
Endif

Dimension This.ctlWeeklyBoldedDates(m.lnRows)

This.ctlWeeklyBoldedDates(m.lnRows) = m.tdDate

ENDPROC
PROCEDURE ctlborderwidth_assign
*!* ctlBorderWidth_Assign()

Lparameters m.tuNewValue

If This.ctlBorderWidth # m.tuNewValue Then
	This.ctlBorderWidth = m.tuNewValue
	This._SetBorderWidth()
Endif

ENDPROC
PROCEDURE ctlcalendardimensionsheight_assign
*!* ctlCalendarDimensionsHeight_Assign()

Lparameters m.tuNewValue

m.tuNewValue = Max(Min(12 / This.ctlCalendarDimensionsWidth, m.tuNewValue), 1)

If This.ctlCalendarDimensionsHeight # m.tuNewValue Then
	This.ctlCalendarDimensionsHeight = m.tuNewValue
	This._SetCalendarRows()
Endif

ENDPROC
PROCEDURE ctlcalendardimensionswidth_assign
*!* ctlCalendarDimensionsWidth_Assign()

Lparameters m.tuNewValue

m.tuNewValue = Max(Min(12 / This.ctlCalendarDimensionsHeight, m.tuNewValue), 1)

If This.ctlCalendarDimensionsWidth # m.tuNewValue Then
	This.ctlCalendarDimensionsWidth = m.tuNewValue
	This._SetCalendarColumns()
Endif

ENDPROC
PROCEDURE ctldefaultmonthbackcolor_access
Return This.ctlDefaultBackColor

ENDPROC
PROCEDURE ctldefaulttitlebackcolor_access
Local lnColor As Integer

m.lnColor = apiGetSysColor(COLOR_ACTIVECAPTION)	&& ActiveCaption

Return m.lnColor

ENDPROC
PROCEDURE ctldefaulttitleforecolor_access
Local lnColor As Integer

m.lnColor = apiGetSysColor(COLOR_CAPTIONTEXT)	&&  ActiveCaptionText

Return m.lnColor

ENDPROC
PROCEDURE ctldefaulttrailingforecolor_access
Local lnColor As Integer

m.lnColor = apiGetSysColor(COLOR_GRAYTEXT)	&& GrayText

Return m.lnColor
ENDPROC
PROCEDURE ctlfirstdayofweek_assign
*!* ctlFirstDayOfWeek_Assign()

Lparameters m.tuNewValue

m.tuNewValue = Max(Min(m.tuNewValue, 7), 0)

If This.ctlFirstDayOfWeek # m.tuNewValue Then
	This.ctlFirstDayOfWeek = m.tuNewValue
	This._SetFirstDayOfWeek()
Endif


ENDPROC
PROCEDURE ctlmaxdate_assign
*!* ctlMaxDate_Assign
Lparameters m.tuNewValue

m.tuNewValue = Min(m.tuNewValue, Date(9998,12,31))

If This.ctlMaxDate # m.tuNewValue Then
	This.ctlMaxDate = m.tuNewValue
	This._SetRange()
Endif

ENDPROC
PROCEDURE ctlmaxselectioncount_assign
lparameters tuNewValue
This.ctlmaxselectioncount = tuNewValue

ENDPROC
PROCEDURE ctlmindate_assign
*!* ctlMinDate_Assign
Lparameters m.tuNewValue

m.tuNewValue = Max(m.tuNewValue, Date(1753,01,01))

If This.ctlMinDate # m.tuNewValue Then
	This.ctlMinDate= m.tuNewValue
	This._SetRange()
Endif

ENDPROC
PROCEDURE ctlremoveallannuallyboldeddates
*!* ctlRemoveAllAnnuallyBoldedDates()

Local m.lnMonth As Integer

Dimension This.ctlAnnuallyBoldedDates(1)
This.ctlAnnuallyBoldedDates(1) = FALSE

For m.lnMonth = 1 To 12
	This._DayStates(m.lnMonth) = 0h00000000
Endfor


ENDPROC
PROCEDURE ctlremoveallboldeddates
*!* ctlRemoveAllBoldedDates()

Dimension This.ctlBoldedDates(1)
This.ctlBoldedDates(1) = FALSE


ENDPROC
PROCEDURE ctlremoveallmonthlyboldeddates
*!* ctlRemoveAllMonthlyBoldedDates()

Dimension This.ctlMonthlyBoldedDates(1)
This.ctlMonthlyBoldedDates(1) = FALSE

This._DayStates(13) = 0h00000000


ENDPROC
PROCEDURE ctlremoveallweeklyboldeddates
*!* ctlRemoveAllWeeklyBoldedDates()

Dimension This.ctlWeeklyBoldedDates(1)
This.ctlWeeklyBoldedDates(1) = FALSE


ENDPROC
PROCEDURE ctlremoveannuallyboldeddate
*!* ctlRemoveAnnuallyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
	m.lnRow As Integer, ;
	m.lnRows As Integer

m.lnRows = Alen(This.ctlAnnuallyBoldedDates, 1)

For m.lnRow = 1 To m.lnRows
	If Day(m.tdDate) = Day(This.ctlAnnuallyBoldedDates(m.lnRow)) ;
			And Month(m.tdDate) = Month(This.ctlAnnuallyBoldedDates(m.lnRow)) Then
		Adel(This.ctlAnnuallyBoldedDates, m.lnRow)
		Dimension This.ctlAnnuallyBoldedDates(m.lnRows - 1)
	Endif
Endfor

*!* Update DayState string for month:
This._DayStates(Month(m.tdDate)) = Bitclear(This._DayStates(Month(m.tdDate)), Day(m.tdDate) - 1 , 1)


ENDPROC
PROCEDURE ctlremoveboldeddate
*!* ctlRemoveBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
	m.lnRow As Integer, ;
	m.lnRows As Integer

m.lnRows = Alen(This.ctlBoldedDates, 1)

For m.lnRow = 1 To m.lnRows
	If m.tdDate = This.ctlBoldedDates(m.lnRow) Then
		Adel(This.ctlBoldedDates, m.lnRow)
		Dimension This.ctlBoldedDates(m.lnRows - 1)
	Endif
Endfor
ENDPROC
PROCEDURE ctlremovemonthlyboldeddate
*!* ctlRemoveMonthlyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
	m.lnRow As Integer, ;
	m.lnRows As Integer

m.lnRows = Alen(This.ctlMonthlyBoldedDates, 1)

For m.lnRow = 1 To m.lnRows
	If Day(m.tdDate) = Day(This.ctlMonthlyBoldedDates(m.lnRow)) Then
		Adel(This.ctlMonthlyBoldedDates, m.lnRow)
		Dimension This.ctlMonthlyBoldedDates(m.lnRows - 1)
	Endif
Endfor

*!* Update DayState string for monthly days:
This._DayStates(13) = Bitclear(This._DayStates(13), Day(m.tdDate) - 1 , 1)

ENDPROC
PROCEDURE ctlremoveweeklyboldeddate
*!* ctlRemoveWeeklyBoldedDate()

Lparameters tdDate As Date

If Vartype(m.tdDate) = T_DATETIME Then
	m.tdDate = Ttod(m.tdDate)
Endif

If Vartype(m.tdDate) # T_DATE Then
	Return
Endif

Local ;
	m.lnRow As Integer, ;
	m.lnRows As Integer

m.lnRows = Alen(This.ctlWeeklyBoldedDates, 1)

For m.lnRow = 1 To m.lnRows
	If Dow(m.tdDate) = Dow(This.ctlWeeklyBoldedDates(m.lnRow)) Then
		Adel(This.ctlWeeklyBoldedDates, m.lnRow)
		Dimension This.ctlWeeklyBoldedDates(m.lnRows - 1)
	Endif
Endfor

ENDPROC
PROCEDURE ctlscrollchange_assign
Lparameters tuNewValue

m.tuNewValue = Min(Max(m.tuNewValue, 0), 20000)

This.ctlScrollChange = m.tuNewValue

This._SetScrollChange()

ENDPROC
PROCEDURE ctlselectionend_access
Return This.ctlValue

ENDPROC
PROCEDURE ctlselectionstart_access
Return This.ctlValue

ENDPROC
PROCEDURE ctlshowtoday_assign
*!* ctlShowToday_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

If This.ctlShowToday # m.tuNewValue Then
	This.ctlShowToday = m.tuNewValue
	This._SetShowToday()
Endif



ENDPROC
PROCEDURE ctlshowtodaycircle_assign
*!* ctlShowTodayCircle_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlShowTodayCircle # m.tuNewValue Then
	This.ctlShowTodayCircle = m.tuNewValue
	This._SetShowTodayCircle()
Endif

ENDPROC
PROCEDURE ctlshowweeknumbers_assign
*!* ctlShowWeekNumbers_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlShowWeekNumbers # m.tuNewValue Then
	This.ctlShowWeekNumbers = m.tuNewValue
	This._SetShowWeekNumbers()
Endif


ENDPROC
PROCEDURE ctlsinglemonthheight_access
Return This._CalendarHeight + This._ShowTodayHeight


ENDPROC
PROCEDURE ctlsinglemonthwidth_access
If This.ctlShowWeekNumbers = TRUE Then
	Return This._CalendarWidth + This._ShowWeekNumbersWidth
Else
	Return This._CalendarWidth
Endif


ENDPROC
PROCEDURE ctltitlebackcolor_assign
*!* ctlTitleBackColor_Assign(tuNewValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlTitleBackColor # m.tuNewValue Then
	This.ctlTitleBackColor = m.tuNewValue
	This._SetTitleBackColor()
Endif
ENDPROC
PROCEDURE ctltitleforecolor_assign
*!* ctlTitleForeColor_Assign(tuNewValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlTitleForeColor # m.tuNewValue Then
	This.ctlTitleForeColor = m.tuNewValue
	This._SetTitleForeColor()
Endif
ENDPROC
PROCEDURE ctltodaydate_assign
Lparameters tuNewValue

If Not Empty(m.tuNewValue) Then
	m.tuNewValue = Min(This.ctlMaxDate, m.tuNewValue)
	m.tuNewValue = Max(This.ctlMinDate, m.tuNewValue)
Endif

This.ctlTodayDate = m.tuNewValue

This._SetTodayDate()

ENDPROC
PROCEDURE ctltodaydateset_access
Return This._TodayDateSet

ENDPROC
PROCEDURE ctltrailingforecolor_assign
*!* ctlTrailingForeColor_Assign(tuNewValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) <> "N"
	m.tuNewValue = -1
Endif

If m.tuNewValue > 16777215 Or m.tuNewValue < 0 Then
	m.tuNewValue = -1
Endif

If This.ctlTrailingForeColor # m.tuNewValue Then
	This.ctlTrailingForeColor = m.tuNewValue
	This._SetTrailingForeColor()
Endif
ENDPROC
PROCEDURE ctlupdateboldeddates
*!* ctlUpdateBoldedDates()

Local ;
	loStartDate As ctlSystemTime, ;
	lcStartDate As String, ;
	ldStartDate As Date, ;
	lcSysTimeArray As String, ;
	lnMonths As Integer

*!* Get number of visible months and start date:
m.loStartDate = Createobject("ctlSystemTime")
m.lcStartDate = m.loStartDate.Value
m.lcSysTimeArray = m.lcStartDate + m.lcStartDate

m.lnMonths = apiSendMessage(This._ControlHwnd, MCM_GETMONTHRANGE, GMR_DAYSTATE, @m.lcSysTimeArray)

*!* get only the starting date out of the 2 elements systemtime array:
m.loStartDate.Value = Left(m.lcSysTimeArray, m.loStartDate.SizeOf)

With m.loStartDate
	m.ldStartDate = Date(.wYear, .wMonth, .wDay)
Endwith

m.loStartDate = .Null.

*!* This updates the daystates array:
This._UpdateDayStates(m.ldStartDate, m.lnMonths)

apiSendMessage(This._ControlHwnd, MCM_SETDAYSTATE, m.lnMonths, This._DayStatesAddress)


ENDPROC
PROCEDURE ctlvalue_assign
*!* ctlValue_Assign(nValue)

Lparameters m.tuNewValue

m.tuNewValue = Min(This.ctlMaxDate, m.tuNewValue)
m.tuNewValue = Max(This.ctlMinDate, m.tuNewValue)

If This.ctlValue # m.tuNewValue Then
	This.ctlValue = m.tuNewValue
	This._SetValue()
Endif

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_daystatessetup Sets up _DayStates 
*_setborderwidth 
*_setcalendarcolumns 
*_setcalendarrows 
*_setfirstdayofweek 
*_setrange 
*_setscrollchange 
*_setshowtoday 
*_setshowtodaycircle 
*_setshowweeknumbers 
*_settitlebackcolor 
*_settitleforecolor 
*_settodaydate 
*_settrailingforecolor 
*_updatedaystates Updates the date states array stored in the _DayStatesAddress memory address.
*ctladdannuallyboldeddate Adds a day that is displayed in bold on an annual basis in the month calendar.
*ctladdboldeddate Adds a day to be displayed in bold in the month calendar.
*ctladdmonthlyboldeddate Adds a day that is displayed in bold on a monthly basis in the month calendar.
*ctladdweeklyboldeddate 
*ctlborderwidth_assign 
*ctlcalendardimensionsheight_assign 
*ctlcalendardimensionswidth_assign 
*ctldefaultmonthbackcolor_access 
*ctldefaulttitlebackcolor_access 
*ctldefaulttitleforecolor_access 
*ctldefaulttrailingforecolor_access 
*ctlfirstdayofweek_assign 
*ctlmaxdate_assign 
*ctlmaxselectioncount_assign 
*ctlmindate_assign 
*ctlremoveallannuallyboldeddates Removes all the annually bold dates.
*ctlremoveallboldeddates Removes all the nonrecurring bold dates.
*ctlremoveallmonthlyboldeddates Removes all the monthly bold dates.
*ctlremoveallweeklyboldeddates Removes all the weekly bold dates.
*ctlremoveannuallyboldeddate Removes the specified date from the list of annually bold dates.
*ctlremoveboldeddate Removes the specified date from the list of nonrecurring bold dates.
*ctlremovemonthlyboldeddate Removes the specified date from the list of monthly bolded dates.
*ctlremoveweeklyboldeddate Removes the specified date from the list of weekly bolded dates.
*ctlscrollchange_assign 
*ctlselectionend_access 
*ctlselectionstart_access 
*ctlshowtoday_assign 
*ctlshowtodaycircle_assign 
*ctlshowweeknumbers_assign 
*ctlsinglemonthheight_access 
*ctlsinglemonthwidth_access 
*ctltitlebackcolor_assign 
*ctltitleforecolor_assign 
*ctltodaydate_assign 
*ctltodaydateset_access 
*ctltrailingforecolor_assign 
*ctlupdateboldeddates Repaints the bold dates to reflect the dates set in the lists of bold dates.
^_daystates[13,0] 
^ctlannuallyboldeddates[1,0] Gets or sets the array of DateTime objects that determines which annual days are displayed in bold.
^ctlboldeddates[1,0] Gets or sets the array of DateTime objects that determines which nonrecurring dates are displayed in bold.
^ctlmonthlyboldeddates[1,0] Gets or sets the array of DateTime objects that determine which monthly days to bold.
^ctlweeklyboldeddates[1,0] 
_calendarheight
_calendarwidth
_columns
_daystatesaddress Pointer to a string buffer that holds a day states array.
_rows
_showtodayheight
_showweeknumberswidth
_todaydateset
ctlborderwidth
ctlcalendardimensionsheight Gets or sets the number of rows of months displayed.
ctlcalendardimensionswidth Gets or sets the number of columns of months displayed.
ctldefaultmonthbackcolor Gets a value indicating the default background color of the month area of the calendar.
ctldefaulttitlebackcolor Gets a value indicating the default background color of the title area of the calendar.
ctldefaulttitleforecolor Gets a value indicating the default foreground color of the title area of the calendar.
ctldefaulttrailingforecolor Gets a value indicating the default color of days in months that are not fully displayed in the control.
ctlfirstdayofweek Gets or sets the first day of the week as displayed in the month calendar.
ctlmaxdate Gets or sets the maximum allowable date.
ctlmaxselectioncount Gets or sets the maximum number of days that can be selected in a month calendar control.
ctlmindate Gets or sets the minimum allowable date.
ctlscrollchange Gets or sets the scroll rate for a month calendar control.
ctlselectionend Gets or sets the end date of the selected range of dates.
ctlselectionstart Gets or sets the start date of the selected range of dates.
ctlshowtoday Gets or sets a value indicating whether the date represented by the TodayDate property is displayed at the bottom of the control.
ctlshowtodaycircle Gets or sets a value indicating whether today's date is identified with a circle or a square.
ctlshowweeknumbers Gets or sets a value indicating whether the month calendar control displays week numbers (1-52) to the left of each row of days.
ctlsinglemonthheight Gets the minimum height to display one month of the calendar.
ctlsinglemonthwidth Gets the minimum width to display one month of the calendar.
ctltitlebackcolor Gets or sets a value indicating the background color of the title area of the calendar.
ctltitleforecolor Gets or sets a value indicating the foreground color of the title area of the calendar.
ctltodaydate Gets or sets the value that is used by MonthCalendar as today's date.
ctltodaydateset Gets a value indicating whether the TodayDate property has been explicitly set.
ctltrailingforecolor Gets or sets a value indicating the color of days in months that are not fully displayed in the control.
[END RESERVED3]
[START RESERVED4]
ctl32_monthcalendar.bmp[END RESERVED4]
[START RESERVED5]
ctl32_monthcalendar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_monthcalendar
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CG06YWH9
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_progressbar
[START PROPERTIES]
Height = 18
Name = "ctl32_progressbar"
Width = 301
_playtimerid = 0
ctlTextBox.Name = "ctlTextBox"
ctlbarcolor = -1
ctlcaption = .F.
ctlformat = .F.
ctlmarquee = .F.
ctlmarqueeanimationspeed = 100
ctlmarqueespeed = 100
ctlmaximum = 100
ctlmaximumbytes = 0
ctlminimum = 0
ctlminimumbytes = 0
ctlpercent = 0
ctlplay = .F.
ctlrepeat = .F.
ctlsizeadjust = .F.
ctlsmooth = .F.
ctlstate = 1
ctlstep = 1
ctlstyle = 1
ctlvaluebytes = .F.
ctlvaluepercent = .F.
ctlvertical = .F.
lblname.Caption = "ctl32_progressbar"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE _getdwstyle
*!* _GetdwStyle()

Local dwStyle As Integer

m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS)

*!* Setup Control specific Styles that have to be set at window creation:
*!* ctlMarquee
If This.ctlMarquee = TRUE Then
	m.dwStyle = Bitor(m.dwStyle, PBS_MARQUEE)
Endif

*!* ctlSmooth
If This.ctlSmooth = TRUE And This.ctlMarquee = FALSE Then
	m.dwStyle = Bitor(m.dwStyle, PBS_SMOOTH)
Endif

*!* Orientation
If This.ctlOrientation = 1 Or This.ctlVertical Then
	m.dwStyle = Bitor(m.dwStyle, PBS_VERTICAL)
Endif

Return m.dwStyle

ENDPROC
PROCEDURE _getlpclassname
*!* _GetlpClassName()

Return PROGRESS_CLASSA

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

DoDefault()

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_TIMER And Thisform._2ce01ty4y_wParam = This._PlayTimerId
		This._PlayTimerTick()

Endcase

ENDPROC
PROCEDURE _onresize
*!* _OnResize()

DoDefault()

*!* If ctlStyle # 1 then we have to update the window region:
If This.ctlStyle # 1 Then
	This._SetStyle()
Endif

ENDPROC
PROCEDURE _playtimertick
*!* _PlayTimerTick()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlMarquee = TRUE Then
	Return
Endif

*!* Send ctlStepIt message:
apiSendMessage(This._ControlHwnd, PBM_STEPIT, 0, 0)

*!* Prevent value updating recursion
This._EnableUpdates = FALSE
This.ctlValue = apiSendMessage(This._ControlHwnd, PBM_GETPOS, 0, 0)
This._EnableUpdates = TRUE

ENDPROC
PROCEDURE _postcreate
*!* Set ctlMinimum and ctlMaximum values:
This._SetRange()

*!* Set Control ctlStep Value
This._SetStep()

*!* Set ctlMarqueeSpeed Value
This._SetMarqueeSpeed()

*!* Set ctlPlay state
This._SetPlay()

*!* Set Colors
This._SetBackColor()
This._SetForeColor()
This._SetBorderColor()

This._SetState()

This._SetStyle()
ENDPROC
PROCEDURE _precreate
*!* _PreCreate()

If This.ctlAutoSize Or This.ctlSizeAdjust = TRUE Then
	This._SetAutoSize()
Endif

ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

Local lnAnchor As Integer

m.lnAnchor = This.Anchor

This.Anchor = 0

If This.ctlAutoSize = TRUE Then

	If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		This.Height = This.ctlDefaultHeight
	Else
		This.Width = This.ctlDefaultWidth
	Endif

Endif

This.Anchor = m.lnAnchor

ENDPROC
PROCEDURE _setbackcolor
*!* _SetBackColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlBackColor = -1 Then
	apiSendMessage(This._ControlHwnd, PBM_SETBKCOLOR, 0, CLR_DEFAULT)
Else
	apiSendMessage(This._ControlHwnd, PBM_SETBKCOLOR, 0, This.ctlBackColor)
Endif
ENDPROC
PROCEDURE _setbordercolor
*!* _SetBorderColor()

This.BorderColor = Iif(This.ctlBorderColor = -1, This.ctlDefaultBorderColor, This.ctlBorderColor)













ENDPROC
PROCEDURE _setforecolor
*!* _SetForeColor()

If This._ControlHwnd = 0 Then
	Return
Endif

If This.ctlForeColor = -1 Then
	apiSendMessage(This._ControlHwnd, PBM_SETBARCOLOR, 0, CLR_DEFAULT)
Else
	apiSendMessage(This._ControlHwnd, PBM_SETBARCOLOR, 0, This.ctlForeColor)
Endif

ENDPROC
PROCEDURE _setmarquee
*!* _SetMarquee()

*!* change needs to recreate Control
If This._ControlHwnd = 0 Then
	Return
Endif

This._Create()
ENDPROC
PROCEDURE _setmarqueespeed
*!* _SetMarqueeSpeed()

If This._ControlHwnd = 0 Then
	Return
Endif

apiSendMessage(This._ControlHwnd, PBM_SETMARQUEE, 1, This.ctlMarqueeSpeed)

ENDPROC
PROCEDURE _setorientation
*!* _SetOrientation()

Local ;
	lnAnchor As Integer, ;
	lnWidth As Integer, ;
	llVisible As Boolean

If This._ControlHwnd = 0 Then
	Return
Endif

m.lnAnchor = This.Anchor
m.lnWidth = This.Width
m.llVisible = This.ctlVisible

This.ctlVisible = FALSE
This.Anchor = 0

*!* ctlVertical change needs to recreate Control
This._Create()

This.Width = This.Height
This.Height = m.lnWidth

This.Anchor = m.lnAnchor
This.ctlVisible = m.llVisible

ENDPROC
PROCEDURE _setplay
*!* _SetPlay()

This._KillTimer(This._PlayTimerId)

If This.ctlPlay = TRUE Then
	This._PlayTimerId = This._SetTimer(200)
Endif

ENDPROC
PROCEDURE _setrange
*!* _SetRange()

If This._ControlHwnd = 0 Then
	Return
Endif

*!* Set ctlMinimum and ctlMaximum values:
apiSendMessage(This._ControlHwnd, PBM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)

ENDPROC
PROCEDURE _setsmooth
*!* _SetSmooth()

*!* ctlSmooth change needs to recreate Control
If This._ControlHwnd = 0 Then
	Return
Endif

This._Create()
ENDPROC
PROCEDURE _setstate
*!* _SetState()

If This._ControlHwnd = 0 Then
	Return
Endif

If ctlGetOsVersion() >= NTDDI_VISTA Then
	apiSendMessage(This._ControlHwnd, PBM_SETSTATE, This.ctlState, 0)
Endif


ENDPROC
PROCEDURE _setstep
*!* _SetStep()

If This._ControlHwnd = 0 Then
	Return
Endif

*!* Set ctlStep Value
apiSendMessage(This._ControlHwnd, PBM_SETSTEP, This.ctlStep, 0)

ENDPROC
PROCEDURE _setstyle
*!* _SetStyle()

If This._ControlHwnd = 0 Then
	Return
Endif

Local ;
	lnRegion As Integer, ;
	lnStyle As Integer

m.lnStyle = Min(Max(This.ctlStyle, 1), 3)

Do Case

	Case ctlIsThemeActive(This)
		apiSetWindowRgn(This._ControlHwnd, 0, 1)
		apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
		*!* Refresh control window so border gets redrawn
		apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))

	Case m.lnStyle = 1
		apiSetWindowRgn(This._ControlHwnd, 0, 1)
		apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, WS_EX_STATICEDGE)
		*!* Refresh control window so border gets redrawn
		apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))

	Case m.lnStyle = 2
		apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
		*!* Refresh control window so border gets redrawn
		apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
		m.lnRegion = apiCreateRectRgn(1, 1, This.Width - 1, This.Height - 1)
		apiSetWindowRgn(This._ControlHwnd, m.lnRegion, 1)
		apiDeleteObject(m.lnRegion)

	Case m.lnStyle = 3
		apiSetWindowLong(This._ControlHwnd, GWL_EXSTYLE, 0)
		*!* Refresh control window so border gets redrawn
		apiSetWindowPos(This._ControlHwnd, HWND_TOP, 0,0,0,0, Bitor(SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER, SWP_FRAMECHANGED))
		m.lnRegion = apiCreateRectRgn(1, 1, This.Width - 1, This.Height - 1)
		apiSetWindowRgn(This._ControlHwnd, m.lnRegion, 1)
		apiDeleteObject(m.lnRegion)

Endcase

This._SetVisible()


ENDPROC
PROCEDURE _setthemes
*!* _SetThemes()

DoDefault()

This._SetStyle()
ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

DoDefault()

If This._ControlHwnd = 0
	Return
Endif

*!* 20070812 Only send this message if Marquee style is off
If This.ctlMarquee = TRUE Then
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

apiSendMessage(This._ControlHwnd, PBM_SETPOS, This.ctlValue, 0)



ENDPROC
PROCEDURE _setvisible
DoDefault()

If This.ctlStyle # 3 Then
	This.Visible = FALSE
Endif

ENDPROC
PROCEDURE ctlbarcolor_access
*!* ctlBarColor_Access()

Return This.ctlForeColor

ENDPROC
PROCEDURE ctlbarcolor_assign
*!* ctlBarColor_Assign(vNewVal)

Lparameters m.tuNewValue

This.ctlForeColor = m.tuNewValue


ENDPROC
PROCEDURE ctlcaption_access
*!* ctlCaption_Access()

If Empty(This.ctlFormat) Then
    Return ""
Endif

Local ;
    lcValB, ;
    lcValN, ;
    lcValP, ;
    lcMaxB, ;
    lcMaxN, ;
    lcMaxP, ;
    lcMinB, ;
    lcMinN, ;
    lcMinP, ;
    lcOut

m.lcValN = Transform(This.ctlValue,   "999,999,999,999")
m.lcMaxN = Transform(This.ctlMaximum, "999,999,999,999")
m.lcMinN = Transform(This.ctlMinimum, "999,999,999,999")

m.lcValP = Transform(This.ctlPercent, "999%")
m.lcMaxP = "100%"
m.lcMinP = "0%"

m.lcValB = ctlStrFormatByteSize(This.ctlValue)
m.lcMaxB = ctlStrFormatByteSize(This.ctlMaximum)
m.lcMinB = ctlStrFormatByteSize(This.ctlMinimum)

m.lcOut = This.ctlFormat
m.lcOut = Strtran(m.lcOut , "ValBytes",   Alltrim(m.lcValB), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "ValNumber",  Alltrim(m.lcValN), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "ValPercent", Alltrim(m.lcValP), 1, 99, 1)

m.lcOut = Strtran(m.lcOut , "MaxBytes",   Alltrim(m.lcMaxB), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "MaxNumber",  Alltrim(m.lcMaxN), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "MaxPercent", Alltrim(m.lcMaxP), 1, 99, 1)

m.lcOut = Strtran(m.lcOut , "MinBytes",   Alltrim(m.lcMinB), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "MinNumber",  Alltrim(m.lcMinN), 1, 99, 1)
m.lcOut = Strtran(m.lcOut , "MinPercent", Alltrim(m.lcMinP), 1, 99, 1)

Return m.lcOut

ENDPROC
PROCEDURE ctldefaultheight_access
*!* ctlDefaultHeight_Access()

Return Round((This.Height - 8)/8,0) * 8 + 5

ENDPROC
PROCEDURE ctldefaultwidth_access
*!* ctlDefaultWidth_Access()

Return Round((This.Width - 5)/8,0) * 8 + 5

ENDPROC
PROCEDURE ctldispose
*!* ctlDispose()

DoDefault()

This._KillTimer(This._PlayTimerId)

ENDPROC
PROCEDURE ctlincrement
*!* ctlIncrement(nValue)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) # T_NUMERIC Then
	m.tuNewValue= This.ctlStep
Endif

If This._ControlHwnd = 0
	Return
Endif

*!* 20070812 Only send this message if Marquee style is off
If This.ctlMarquee = TRUE Then
	Return
Endif

apiSendMessage(This._ControlHwnd, PBM_DELTAPOS, m.tuNewValue, 0)

This._EnableUpdates = FALSE
This.ctlValue = apiSendMessage(This._ControlHwnd, PBM_GETPOS, 0, 0)
This._EnableUpdates = TRUE

ENDPROC
PROCEDURE ctlmarquee_assign
*!* ctlMarquee_Assign(vNewVal)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlMarquee # m.tuNewValue Then
	This.ctlMarquee = m.tuNewValue
	This._SetMarquee()
Endif


ENDPROC
PROCEDURE ctlmarqueeanimationspeed_access
*!* ctlMarqueeAnimationSpeed_Access()

Return This.ctlMarqueeSpeed

ENDPROC
PROCEDURE ctlmarqueeanimationspeed_assign
*!* ctlMarqueeAnimationSpeed_Assign(vNewVal)

Lparameters m.tuNewValue

This.ctlMarqueeSpeed = m.tuNewValue

ENDPROC
PROCEDURE ctlmarqueespeed_assign
*!* ctlMarqueeSpeed_Assign(vNewVal)

Lparameters m.tuNewValue

If This.ctlMarqueeSpeed # m.tuNewValue Then
	This.ctlMarqueeSpeed = m.tuNewValue
	This._SetMarqueeSpeed()
Endif

ENDPROC
PROCEDURE ctlmaximum_assign
*!* ctlSetMaximum_Assign(vNewVal)

Lparameters m.tuNewValue

If This.ctlMaximum # m.tuNewValue Then
	This.ctlMaximum = m.tuNewValue
	This._SetRange()
Endif


ENDPROC
PROCEDURE ctlmaximumbytes_access
Return ctlStrFormatByteSize(This.ctlMaximum)

ENDPROC
PROCEDURE ctlminimum_assign
*!* ctlSetMinimum_Assign(nValue)

Lparameters m.tuNewValue

If This.ctlMinimum # m.tuNewValue Then
	This.ctlMinimum = m.tuNewValue
	This._SetRange()
Endif

ENDPROC
PROCEDURE ctlminimumbytes_access
Return ctlStrFormatByteSize(This.ctlMinimum)

ENDPROC
PROCEDURE ctlpercent_access
Return Int(100 * (This.ctlValue - This.ctlMinimum) / (Abs(This.ctlMaximum - This.ctlMinimum)))


ENDPROC
PROCEDURE ctlperformstep
*!* ctlPerformStep()

This.ctlIncrement(This.ctlStep)
ENDPROC
PROCEDURE ctlplay_assign
*!* ctlPlay_Assign(vNewVal)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue = m.tuNewValue # 0
Endif

If This.ctlPlay # m.tuNewValue Then
	This.ctlPlay = m.tuNewValue
	This._SetPlay()
Endif



ENDPROC
PROCEDURE ctlreset
*!* ctlReset(ToMaximum)

Lparameters m.ToMaximum

If Pcount() = 0 Then
	This.ctlValue = This.ctlMinimum
Else
	This.ctlValue = This.ctlMaximum
Endif

ENDPROC
PROCEDURE ctlsizeadjust_access
*!* ctlSizeAdjust_Access()

Return This.ctlAutoSize

ENDPROC
PROCEDURE ctlsizeadjust_assign
*!* ctlSizeAdjust_Assign(vNewVal)

Lparameters m.tuNewValue

This.ctlAutoSize = m.tuNewValue

ENDPROC
PROCEDURE ctlsmooth_assign
*!* ctlSmooth_Assign(vNewVal)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

If This.ctlSmooth # m.tuNewValue Then
	This.ctlSmooth = m.tuNewValue
	This._SetSmooth()
Endif



ENDPROC
PROCEDURE ctlstate_assign
*!* ctlState_Assign(vNewVal)

Lparameters m.tuNewValue

If This.ctlState # m.tuNewValue Then
	This.ctlState = m.tuNewValue
	This._SetState()
Endif



ENDPROC
PROCEDURE ctlstep_assign
*!* ctlStep_Assign(vNewVal)

Lparameters m.tuNewValue

If This.ctlStep # m.tuNewValue Then
	This.ctlStep = m.tuNewValue
	This._SetStep()
Endif


ENDPROC
PROCEDURE ctlstepit
*!* ctlStepIt(nStep)

Lparameters m.tnStep As Integer

If This.ctlMarquee = TRUE Then
	Return
Endif

If This._ControlHwnd = 0 Then
	Return
Endif

*!* If numeric parameter, set step value
If Vartype(m.tnStep) = T_NUMERIC And m.tnStep <> This.ctlStep Then
	apiSendMessage(This._ControlHwnd, PBM_SETSTEP, m.tnStep, 0)
Endif

*!* Send ctlStepIt message:
apiSendMessage(This._ControlHwnd, PBM_STEPIT, 0, 0)

*!* If numeric parameter, reset step value
If Vartype(m.tnStep) = T_NUMERIC And m.tnStep <> This.ctlStep Then
	apiSendMessage(This._ControlHwnd, PBM_SETSTEP, This.ctlStep, 0)
Endif

*!* Prevent value updating recursion
This._EnableUpdates = FALSE
This.ctlValue = apiSendMessage(This._ControlHwnd, PBM_GETPOS, 0, 0)
This._EnableUpdates = TRUE


ENDPROC
PROCEDURE ctlstyle_assign
*!* ctlStyle_Assign(vNewVal)

Lparameters m.tuNewValue

If This.ctlStyle # m.tuNewValue Then
	This.ctlStyle = m.tuNewValue
	This._SetStyle()
Endif

*!* 1 normal 3d border (only when theme is off)
*!* 2 flat no border
*!* 3 flat with border (adds proxy window and uses container border)


ENDPROC
PROCEDURE ctlvaluebytes_access
Return ctlStrFormatByteSize(This.ctlValue)

ENDPROC
PROCEDURE ctlvaluepercent_access
Return Transform(Int(100 * (This.ctlValue - This.ctlMinimum) / (Abs(This.ctlMaximum - This.ctlMinimum)))) + " %"

ENDPROC
PROCEDURE ctlvertical_assign
*!* ctlVertical_Assign(vNewVal)

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

This.ctlVertical = m.tuNewValue

This.ctlOrientation = Iif(This.ctlVertical, 1, 0)


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_playtimertick 
*_setmarquee 
*_setmarqueespeed 
*_setplay 
*_setrange 
*_setsmooth 
*_setstate 
*_setstep 
*_setstyle 
*ctlbarcolor_access 
*ctlbarcolor_assign 
*ctlcaption_access 
*ctlincrement Advances the current position of the progress bar by the specified amount.
*ctlmarquee_assign 
*ctlmarqueeanimationspeed_access 
*ctlmarqueeanimationspeed_assign 
*ctlmarqueespeed_assign 
*ctlmaximum_assign 
*ctlmaximumbytes_access 
*ctlminimum_assign 
*ctlminimumbytes_access 
*ctlpercent_access 
*ctlperformstep Advances the current position of the progress bar by the amount of the ctlStep property.
*ctlplay_assign 
*ctlreset Resets the Value property to ctlMinimum or to ctlMaximum with an optional parameter.
*ctlsizeadjust_access 
*ctlsizeadjust_assign 
*ctlsmooth_assign 
*ctlstate_assign 
*ctlstep_assign 
*ctlstepit Increments the value of the control by the amount specified in ctlStep.
*ctlstyle_assign 
*ctlvaluebytes_access 
*ctlvaluepercent_access 
*ctlvertical_assign 
_playtimerid
ctlbarcolor DEPRECATED. Replaced by the .NET ctlForeColor property.
ctlcaption DEPRECATED.
ctlformat DEPRECATED.
ctlmarquee Indicates progress by continuously scrolling a block across a ProgressBar in a marquee fashion.
ctlmarqueeanimationspeed Gets or sets the time period, in milliseconds, that it takes the progress block to scroll across the progress bar.
ctlmarqueespeed DEPRECATED. Replaced by the .NET ctlMarqueeAnimationSpeed property.
ctlmaximum Gets or sets the maximum value of the range of the control.
ctlmaximumbytes Gets the Maximum value as a string formatted in Bytes/MB/GB/TB.
ctlminimum Gets or sets the minimum value of the range of the control.
ctlminimumbytes Gets the Minimum value as a string formatted in Bytes/MB/GB/TB.
ctlpercent Gets a value representing a percent of Value vs Maximum - Minimum
ctlplay Specifies if the progress bar should increment its value automatically.
ctlrepeat DEPRECATED.
ctlsizeadjust DEPRECATED. Replaced by the .NET ctlAutoSize property.
ctlsmooth Specifies if the bar will be shown as one continous block, or as a group of small individual blocks.
ctlstate VISTA. Sets the state of the progress bar: Normal, Error or Paused.
ctlstep Gets or sets the amount by which the PerformStep method increases the current position of the progress bar.
ctlstyle NOT LIKE THE .NET PROPERTY. Specifies the style of the progress bar border.
ctlvaluebytes Gets the current value as a string formatted in Bytes/MB/GB/TB.
ctlvaluepercent Returns a character string of the current ctlPercent value formatted with a % sign.
ctlvertical DEPRECATED. Replaced by the .NET ctlOrientation property.
[END RESERVED3]
[START RESERVED4]
ctl32_progressbar.bmp[END RESERVED4]
[START RESERVED5]
ctl32_progressbar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
progress bar class[END RESERVED7]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_progressbar
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2BZ0XA4XP
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_rawprint
[START PROPERTIES]
BackColor = 140,200,200
Height = 23
Name = "ctl32_rawprint"
Visible = .F.
Width = 96
_docstarted = .F.
_printerhandle = 0
ctlautocrlf = .F.
ctldocumentname = 
ctlfoxprinter = 
ctllasterrorcode = 
ctllasterrortext = 
ctloutputfile = 
ctlprintercount = 0
ctlrawprinter = 
ctlwindowsprinter = 
[END PROPERTIES]
[START PROTECTED]
_addobjects^
_addproperties^
_clearlasterror^
_docstarted^
_initproperties^
_printerhandle^
_startdocprinter^
ctlprintercount_access^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
This.ctlSaveRawPrinter()
This.ctlClosePrinter()

ENDPROC
PROCEDURE Init
*!* Init

*!* Based on the rawprint class downloaded from the Internet
*!* Unknown source, please report original author to acknowledge credit.

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

This._AddObjects()
This._AddProperties()
This._InitProperties()

*!* Restore RawPrinterName from the registry
This.ctlRestoreRawPrinter()




ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* Add registry object
This.AddObject("oRegistry", "ctl32_Registry")
This.oRegistry.RegistryKey = HKEY_CURRENT_USER

ENDPROC
PROCEDURE _clearlasterror
*!* _ClearLastError()

This.ctlLastErrorCode = 0
This.ctlLastErrorText = ""

ENDPROC
PROCEDURE _getlasterror
*!* _GetLastError()

Local ;
	lnLastErrorCode As Integer, ;
	lcLastErrorText As String, ;
	lnBuffer As Integer, ;
	lcBuffer As String, ;
	lnBufferLen As Integer, ;
	lnRetVal As Integer

*!* Init vars:
This.ctlLastErrorCode = 0
This.ctlLastErrorText = ""

m.lnLastErrorCode = This.ctlLastErrorCode
m.lcLastErrorText = This.ctlLastErrorText

*!* Get Last error code:
m.lnLastErrorCode = apiGetLastError()

*!* Get Kernel32.dll module handle:
If Type("This._hKernel32") <> "N" Then
	This.AddProperty("_hKernel32", apiGetModuleHandle("kernel32.dll"))
Endif

*!* Get last error text:

*!* Initialize buffer vars:
m.lnBuffer = 0
m.lnBufferLen = 1024
m.lcBuffer = Replicate(NULA, m.lnBufferLen)

m.lnRetVal = apiFormatMessage( ;
	FORMAT_MESSAGE_FROM_HMODULE, ;
	This._hKernel32, ;
	m.lnLastErrorCode, ;
	0, ;
	@m.lcBuffer, ;
	m.lnBufferLen, ;
	0)

*!* If something was found, get the text from the buffer:
If m.lnRetVal <> 0 Then
	m.lcLastErrorText = Left(m.lcBuffer, m.lnRetVal)

	*!* Remove last carriage return/line feed
	If Right(m.lcLastErrorText, 2) = CRLF Then
		m.lcLastErrorText = Left(m.lcBuffer, m.lnRetVal - 2)
	Endif
Endif

This.ctlLastErrorCode = m.lnLastErrorCode
This.ctlLastErrorText = m.lcLastErrorText

ENDPROC
PROCEDURE _initproperties
*!* _InitProperties()

This.ctlLastErrorCode = 0
This.ctlLastErrorText = ""

This.Visible = FALSE
ENDPROC
PROCEDURE _startdocprinter
*!* _StartDocPrinter()

********************************************************************************
*!*	typedef struct _DOC_INFO_1 {
*!*	  LPTSTR pDocName;
*!*	  LPTSTR pOutputFile;
*!*	  LPTSTR pDatatype;
*!*	} DOC_INFO_1;
********************************************************************************
If This._PrinterHandle = 0 Then
	Return FALSE
Endif

Local ;
	loDocInfo1 As ctldoc_info_1, ;
	lcDocInfo1 As String, ;
	lnApiRetVal As Integer

m.loDocInfo1 = Createobject("CTLDOC_INFO_1")

If Empty(This.ctlDocumentName) Then
	m.loDocInfo1.pDocName = Juststem(Application.ServerName) + NULA
Else
	m.loDocInfo1.pDocName = This.ctlDocumentName + NULA
Endif

If Vartype(This.ctlOutputFile) = "C" And Not Empty(This.ctlOutputFile) Then
	m.loDocInfo1.pOutputFile = This.ctlOutputFile + NULA
Endif

*!*	m.loDocInfo1.pDatatype = NULL

m.lcDocInfo1 = m.loDocInfo1.Value &&Left(m.loDocInfo1.Value, 4) + Replicate(NULA, 8)

m.lnApiRetVal = apiStartDocPrinter(This._PrinterHandle, 1, m.lcDocInfo1)

m.loDocInfo1 = .Null.
Release m.loDocInfo1

If m.lnApiRetVal = 0 Then
	This._GetLastError()
	This.ctlClosePrinter()
	Return FALSE
Else
	This._ClearLastError()
Endif

This._DocStarted = TRUE

Return

ENDPROC
PROCEDURE ctlcloseprinter
*!* ClosePrinter()

Local ;
	lnApiRetVal As Integer, ;
	llClosePrinter As Boolean

m.llClosePrinter = FALSE

If This._DocStarted Then
	apiEndDocPrinter(This._PrinterHandle)
	This._DocStarted = FALSE
Endif

m.lnApiRetVal = apiClosePrinter(This._PrinterHandle)

This._PrinterHandle = 0

If m.lnApiRetVal = 0 Then
	This._GetLastError()
	m.llClosePrinter = FALSE
Else
	This._ClearLastError()
	m.llClosePrinter = TRUE
Endif

Return m.llClosePrinter


ENDPROC
PROCEDURE ctlfoxprinter_access
Return Set("Printer", 3)

ENDPROC
PROCEDURE ctlgetrawprinter
*!* GetRawPrinter()

Local ;
	lcRawPrinter As String, ;
	lcFoxPrinter As String, ;
	llGetRawPrinter As Boolean

m.llGetRawPrinter = FALSE

*!* Save current default printer
m.lcFoxPrinter = This.ctlFoxPrinter

*!* Set current Fox printer to current Raw printer,
*!* so it shows selected in printer selection
*!* dialog box
If This.ctlPrinterExists(This.ctlRawPrinter) Then
	Set Printer To Name (This.ctlRawPrinter)
Endif

*!* Save current value of RawPrinter in case user cancels
m.lcRawPrinter =This.ctlRawPrinter

*!* Show Choose a printer dialog
This.ctlRawPrinter = Getprinter()

*!* Restore Fox default printer
Set Printer To Name (m.lcFoxPrinter)

*!* If nothing was selected, revert to old value
If Empty(This.ctlRawPrinter) Then
	This.ctlRawPrinter = m.lcRawPrinter
	m.llGetRawPrinter = FALSE
Else
	m.llGetRawPrinter = TRUE
Endif

*!* If printer was changed, close (if open) previous printer
If Not m.lcRawPrinter == This.ctlRawPrinter Then
	If This.ctlIsPrinterOpen() Then
		This.ctlClosePrinter()
	Endif
Endif

*!* Specifies if a RawPrinter was selected, or the dialog was cancelled
Return m.llGetRawPrinter

ENDPROC
PROCEDURE ctlisprinteropen
*!* IsPrinterOpen()

Return This._PrinterHandle <> 0

ENDPROC
PROCEDURE ctlopenprinter
*!* OpenPrinter(cRawPrinter)

Lparameters m.pcRawPrinter As String

Local ;
	lnPrinterHandle As Integer, ;
	lnDefault As Integer, ;
	lnApiRetVal As Integer

If Vartype(m.pcRawPrinter) <> "C" Then
	m.pcRawPrinter = This.ctlRawPrinter
Endif

*!* Close printer if it is already open
If This.ctlIsprinterOpen() = TRUE Then
	This.ctlClosePrinter()
Endif

m.lnPrinterHandle = 0
m.lnDefault  = 0

m.lnApiRetVal = apiOpenPrinter(m.pcRawPrinter, @m.lnPrinterHandle, m.lnDefault)

If m.lnApiRetVal = 0 Then
	This._GetLastError()
	Return FALSE
Else
	This._ClearLastError()
Endif

This._PrinterHandle = m.lnPrinterHandle

Return

ENDPROC
PROCEDURE ctlprint
*!* Print(cString)
Lparameters m.pcString As String

Local ;
	lnStringLen As Integer, ;
	lnPrintedBytes As Integer, ;
	lnApiRetVal As Integer

If Empty(m.pcString) Then
	Return 0
Endif

If This._PrinterHandle = 0 Then
	If This.ctlOpenPrinter() = FALSE
		Return 0
	Endif
Endif

If This.ctlAutoCrLf = TRUE And Right(m.pcString, 2) # CRLF Then
	m.pcString = m.pcString + CRLF
Endif

m.lnStringLen = Len(m.pcString)
m.lnPrintedBytes = 0

If This._DocStarted = FALSE Then
	If This._StartDocPrinter() = FALSE Then
		Return 0
	Endif
Endif

m.lnApiRetVal = apiWritePrinter(This._PrinterHandle, m.pcString, m.lnStringLen, @m.lnPrintedBytes)

If m.lnApiRetVal = 0 Then
	This._GetLastError()
	Return FALSE
Else
	This._ClearLastError()
Endif

Return m.lnPrintedBytes

ENDPROC
PROCEDURE ctlprintercount_access
*!* PrinterCount_Access()

Local Array laPrinters(1)

Return Aprinters(m.laPrinters)



ENDPROC
PROCEDURE ctlprinterexists
*!* PrinterExists(cPrinterName)

Lparameters m.pcPrinterName As String

Local Array laPrinters(1, 2)
Local lnPrinterCount

m.lnPrinterCount = Aprinters(m.laPrinters)

If m.lnPrinterCount = 0 Then
	Return FALSE
Endif

Return Ascan(m.laPrinters, m.pcPrinterName) <> 0




ENDPROC
PROCEDURE ctlprintfile
*!* PrintFile(cFileName)

Lparameters m.pcFileName As String

Local lcString As String

If Vartype(m.pcFileName) <> "C" Then
	Return 0
Endif

If Empty(m.pcFileName) Then
	Return 0
Endif

If Not File(m.pcFileName) Then
	Return 0
Endif

If This._PrinterHandle = 0 Then
	If This.ctlOpenPrinter() = FALSE
		Return 0
	Endif
Endif

m.lcString = Filetostr(m.pcFileName)

Return This.ctlPrint(m.lcString)

ENDPROC
PROCEDURE ctlrestorerawprinter
*!* RestoreRawPrinter()

If Vartype(This.ctlRawPrinter) <> "C" Then
	This.ctlRawPrinter = ""
Endif

If Empty(This.ctlRawPrinter) Then
	This.ctlRawPrinter = This.ctlFoxPrinter
Endif

*!* Get registry data, if any, use actual form data as default
This.ctlRawPrinter = This.oRegistry.GetValue("RawPrint\RawPrinterName", This.ctlRawPrinter)

ENDPROC
PROCEDURE ctlsaverawprinter
*!* SaveRawPrinter()

*!* Store data in Windows registry:
This.oRegistry.SetValue("RawPrint\RawPrinterName", This.ctlRawPrinter)

ENDPROC
PROCEDURE ctlwindowsprinter_access
Return Set("Printer", 2)
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_addproperties 
*_clearlasterror 
*_getlasterror 
*_initproperties 
*_startdocprinter 
*ctlcloseprinter 
*ctlfoxprinter_access 
*ctlgetrawprinter 
*ctlisprinteropen 
*ctlopenprinter 
*ctlprint Prints a character string on a Form object.
*ctlprintercount_access 
*ctlprinterexists 
*ctlprintfile 
*ctlrestorerawprinter 
*ctlsaverawprinter 
*ctlwindowsprinter_access 
_docstarted
_memberdata XML Metadata for customizable properties
_printerhandle
ctlautocrlf Specifies if ctlPrint appends a CRLF
ctldocumentname
ctlfoxprinter
ctllasterrorcode
ctllasterrortext
ctloutputfile
ctlprintercount
ctlrawprinter
ctlwindowsprinter
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2BZ12QKCM
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_rawprint
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_rawprint"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 3
Width = 71
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_rawprint

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2210ZTSXF
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_registry
[START PROPERTIES]
BackColor = 140,200,200
Height = 23
Name = "ctl32_registry"
Visible = .F.
Width = 96
_defaultkey = 
_defaulttype = 
_key = 0
_keyhandle = 0
_subkey = 
lasterrorcode = 0
registrydefaultkey = HKEY_CURRENT_USER
registrydefaultsubkey = 
registrydefaulttype = REG_SZ
registrykey = 
registrysubkey = 
[END PROPERTIES]
[START PROTECTED]
_addproperties^
_defaultkey^
_defaulttype^
_extractnamefromname^
_extractsubkeyfromname^
_key^
_subkey^
_validatedefaultkey^
_validatedefaulttype^
_validatekey^
_validatesubkey^
registrydefaultkey_assign^
registrydefaulttype_assign^
registrykey_assign^
registrysubkey_assign^
[END PROTECTED]
[START METHODS]
PROCEDURE Init
*!* Init

*!* Use these values to set RegistryDefaultKey:
*!*	#Define HKEY_CLASSES_ROOT 		2147483648
*!*	#Define HKEY_CURRENT_CONFIG 	2147483653
*!*	#Define HKEY_CURRENT_USER 		2147483649
*!*	#Define HKEY_DYN_DATA 			2147483654
*!*	#Define HKEY_LOCAL_MACHINE 		2147483650
*!*	#Define HKEY_PERFORMANCE_DATA 	2147483652
*!*	#Define HKEY_USERS 				2147483651

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

This._DefaultKey	= This._ValidateDefaultKey(This.RegistryDefaultKey)
This._Key  		 	= This._ValidateKey(This.RegistryKey)
This._Subkey 	 	= This._ValidateSubKey(This.RegistrySubkey)
This._DefaultType 	= This._ValidateDefaultType(This.RegistryDefaultType)

*!* Windows Registry Structure and class properties
*!*	RegistryKey
*!*      |
**      - RegistrySubKey
**                |
**                - cValueName1 = vValue1 (*See Note)
**                - cValueName2 = vValue2
*!*                ...
*!*                - cValueNamen = vValuen
*!* *Note: tcValueName and tvValue are parameters passed to
*!* GetValue and SetValue

*!* HKEY_CLASSES_ROOT						0x80000000
*!* HKEY_CURRENT_CONFIG						0x80000005
*!* HKEY_CURRENT_USER						0x80000001
*!* HKEY_LOCAL_MACHINE						0x80000002
*!* HKEY_USERS								0x80000003



ENDPROC
PROCEDURE _addproperties
*!* _AddProperties()

ENDPROC
PROCEDURE _extractnamefromname
*!* _ExtractSubKeyFromName(cValueName)
Lparameters m.tcValueName

Local ;
	lcValueName As String, ;
	lcName As String

m.lcValueName = Alltrim(Transform(m.tcValueName))

*!* Strip starting BackSlash
If Left(m.lcValueName, 1) = "\" Then
	m.lcValueName = Right(m.lcValueName, Len(m.lcValueName) - 1)
Endif

*!* Strip ending BackSlash
If Right(m.lcValueName, 1) = "\" Then
	m.lcValueName = Left(m.lcValueName, Len(m.lcValueName) - 1)
Endif

m.lcName = Justfname(m.lcValueName)

Return m.lcName

ENDPROC
PROCEDURE _extractsubkeyfromname
*!* _ExtractSubKeyFromName(cValueName)
Lparameters m.tcValueName

Local ;
	lcValueName As String, ;
	lcSubKey As String

m.lcValueName = Alltrim(Transform(m.tcValueName))

*!* Strip starting BackSlash
If Left(m.lcValueName, 1) = "\" Then
	m.lcValueName = Right(m.lcValueName, Len(m.lcValueName) - 1)
Endif

*!* Strip ending BackSlash
If Right(m.lcValueName, 1) = "\" Then
	m.lcValueName = Left(m.lcValueName, Len(m.lcValueName) - 1)
Endif

m.lcSubKey = Justpath(m.lcValueName)

If Not Empty(m.lcSubKey) Then
	m.lcSubKey = "\" + m.lcSubKey
Endif

Return m.lcSubKey

ENDPROC
PROCEDURE _getvalueini
*!* _GetValueIni(cValueName, eDefaultValue)

Lparameter m.tcValueName, m.tuDefaultValue

If Pcount() < 2 Then
	Return .Null.
Endif

Local ;
	m.lcAppName As String, ;
	m.lcKeyName As String, ;
	m.lcDefault As String, ;
	m.lcReturnedString As String, ;
	m.lnSize As Integer, ;
	m.lcFileName As String, ;
	m.lnRetVal As Integer, ;
	m.lvValue As Variant

If Type("Application.ActiveProject") = "O" Then
	m.lcFileName = Forceext(Application.ActiveProject.Name, "ini")
Else
	m.lcFileName = Forceext(Application.ServerName, "ini")
Endif

m.lcAppName = This._ExtractSubKeyFromName(m.tcValueName)
m.lcAppName = Right(m.lcAppName, Len(m.lcAppName) - 1)

m.lcKeyName = This._ExtractNameFromName(m.tcValueName)

m.lcDefault = "BCCE8FDBBE1440EDAFD4F83C1D1F9B52C11CB5233C154DFCA08166F5A297A398"

m.lnSize = 0xfff
m.lcReturnedString = Replicate(NULCHAR, m.lnSize)

m.lnRetVal = apiGetPrivateProfileString( ;
	m.lcAppName, ;
	m.lcKeyName, ;
	m.lcDefault, ;
	@m.lcReturnedString, ;
	m.lnSize, ;
	m.lcFileName)

m.lcReturnedString = Left(m.lcReturnedString, m.lnRetVal)

If m.lcReturnedString == m.lcDefault Then
	m.lvValue = m.tuDefaultValue
Else
	m.lvValue = m.lcReturnedString
Endif

Release m.lcReturnedString

Return m.lvValue

ENDPROC
PROCEDURE _getvalueregistry
*!* GetValueRegistry(cValueName, eDefaultValue)

Lparameter m.tcValueName, m.tuDefaultValue

If Pcount() < 2 Then
	Return .Null.
Endif

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcValueName As String, ;
	lcData As String, ;
	lnKind As Integer, ;
	lvValue As Variant, ;
	lnDataLen As Integer, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer

m.lnKey 		= This._Key
m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)

Debugout m.lnKey, m.lcSubKey, m.lcValueName, "GetValue"

*!* Do API stuff

m.lnApiRetVal = 0
m.lnKeyHandle = 0

**********************************************************

*!* Try to open registry key
m.lnApiRetVal = apiRegOpenKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	KEY_READ, ;
	@m.lnKeyHandle)

If m.lnApiRetVal = ERROR_SUCCESS Then
	This._KeyHandle = m.lnKeyHandle
Else
	*!* Could not open registry key
	This.LastErrorCode = m.lnApiRetVal
	Return m.tuDefaultValue
Endif

m.lnKind	= 0
m.lcData 	= Space(0xff)
m.lnDataLen = Len(m.lcData)

*!* Find out required length of data, call with a x len buffer,
*!* m.lnDataLen will have the needed buffer len if error is ERROR_MORE_DATA
*!* also m.lnKind will have the data Kind
m.lnApiRetVal = apiRegQueryValueEx( ;
	m.lnKeyHandle, ;
	m.lcValueName, ;
	0, ;
	@m.lnKind, ;
	@m.lcData , ;
	@m.lnDataLen)

Do Case

	Case m.lnApiRetVal = ERROR_SUCCESS
		m.lcData = Left(m.lcData, m.lnDataLen)

	Case m.lnApiRetVal = ERROR_MORE_DATA
		*!* Create a buffer big enough:
		m.lcData = Space(m.lnDataLen)

		*!* Now Get the data again:
		m.lnApiRetVal = apiRegQueryValueEx( ;
			m.lnKeyHandle, ;
			m.lcValueName, ;
			0, ;
			@m.lnKind, ;
			@m.lcData , ;
			@m.lnDataLen )

		If m.lnApiRetVal <> ERROR_SUCCESS Then
			*!* We failed reading the data
			This.LastErrorCode = m.lnApiRetVal
			Return m.tuDefaultValue
		Endif
	Otherwise
		*!* We failed reading the data
		This.LastErrorCode = m.lnApiRetVal
		Return m.tuDefaultValue
Endcase

*!* 20080404 there is no need to close predefined registry keys
*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
*!* If the key is not one of the predefined registry keys, call
*!* the RegCloseKey function after you have finished using the handle.
*!* Close registry key
*!* apiRegCloseKey(m.lnKeyHandle)

Do Case
	Case m.lnKind = REG_SZ
		*!* Remove ending NUL
		m.lvValue = Left(m.lcData, m.lnDataLen - 1)
		*!* Cut to data len
	Case m.lnKind = REG_BINARY
		m.lvValue = Left(m.lcData, m.lnDataLen)
	Case m.lnKind = REG_DWORD
		*!* Convert to numeric
		m.lvValue = CToBin(Left(m.lcData, m.lnDataLen), "4RS")
	Case m.lnKind = REG_MULTI_SZ
		*!* Remove double ending NUL
		m.lvValue = Left(m.lcData, m.lnDataLen - 2)
	Otherwise
		m.lvValue = ""
Endcase

*!* Convert return value based on tuDefaultValue
Do Case

	Case Vartype(m.tuDefaultValue) = T_CHARACTER
		*!* Value is already of type character

	Case Vartype(m.tuDefaultValue) = T_CURRENCY
		m.lvValue= Cast(m.lvValue As Currency)

	Case Vartype(m.tuDefaultValue) = T_DATE
		m.lvValue = Date(Val(Left(m.lvValue,4)), Val(Substr(m.lvValue,5,2)), Val(Right(m.lvValue,2)))

	Case Vartype(m.tuDefaultValue) = T_DATETIME
		m.lvValue = Ctot(m.lvValue)

	Case Vartype(m.tuDefaultValue) = T_LOGICAL
		m.lvValue = Iif(m.lvValue = 1, TRUE, FALSE)

	Case Vartype(m.tuDefaultValue) = T_NUMERIC And m.lnKind = REG_DWORD
		*!* Value has already been converted from DWORD to numeric

	Case Vartype(m.tuDefaultValue) = T_NUMERIC
		*!* REG_SZ, REG_BINARY
		m.lvValue = Evaluate(m.lvValue)

	Case Vartype(m.tuDefaultValue) = T_VARBINARY
		m.lvValue = Cast(m.lvValue As Varbinary (Len(m.lvValue)))

	Otherwise
		*!* No formating of value
Endcase

Return m.lvValue

ENDPROC
PROCEDURE _setvalueini
*!* SetValueIni(cValueName, eValue)

Lparameter m.tcValueName, m.tuValue

Local ;
	m.lcAppName As String, ;
	m.lcKeyName As String, ;
	m.lcString As String, ;
	m.lcType As String, ;
	m.lnRetVal As Integer

If Type("Application.ActiveProject") = "O" Then
	m.lcFileName = Forceext(Application.ActiveProject.Name, "ini")
Else
	m.lcFileName = Forceext(Application.ServerName, "ini")
Endif

m.lcAppName = This._ExtractSubKeyFromName(m.tcValueName)
m.lcAppName = Right(m.lcAppName, Len(m.lcAppName) - 1)

m.lcKeyName = This._ExtractNameFromName(m.tcValueName)

m.lcString = ""
m.lcType = Vartype(m.tuValue)

*!* Determine ValueKind to use and convert Value:
Do Case

	Case Vartype(m.tuValue) = T_CHARACTER
		*!* If there are any nul characters, save as binary
		If NULA $ m.tuValue Then
			m.lcString = Strconv(m.tuValue, 15)
		Else
			m.lcString = m.tuValue
		Endif

	Case Vartype(m.tuValue) = T_CURRENCY
		m.lcString = Strtran(Transform(m.tuValue), Set("Point"), '.')

	Case Vartype(m.tuValue) = T_DATE
		m.lcString = Dtos(m.tuValue)

	Case Vartype(m.tuValue) = T_DATETIME
		m.lcString = Ttoc(m.tuValue, 3)

	Case Vartype(m.tuValue) = T_LOGICAL
		m.lcString = Iif(m.tuValue, "1", "0")

	Case Vartype(m.tuValue) = T_NUMERIC
		m.lcString = Strtran(Transform(m.tuValue), Set("Point"), '.')

	Case Vartype(m.tuValue) = T_VARBINARY
		m.lcString = STRCONV(m.tuValue, 15)

	Otherwise
		*!* If there are any nul characters, save as binary
		If NULA $ m.tuValue Then
			m.lcString = Strconv(m.tuValue, 15)
		Else
			m.lcString = m.tuValue
		Endif

Endcase

m.lnRetVal = apiWritePrivateProfileString( ;
	m.lcAppName, ;
	m.lcKeyName, ;
	m.lcString, ;
	m.lcFileName)

apiWritePrivateProfileString( ;
	m.lcAppName + ".VarType", ;
	m.lcKeyName, ;
	m.lcType, ;
	m.lcFileName)

Return m.lnRetVal # 0



ENDPROC
PROCEDURE _validatedefaultkey
*!* ValidateDefaultKey(eKey)

*!* Key must be a numeric value, but user can set it to a String value
*!* to make programming easier. Here we translate string value to numeric
*!* value

*!* Change RegistryDefaultKey property to change default key

Lparameters m.tuKey

Local ;
	lnKey As Integer, ;
	lnLastResortDefaultKey As Integer

m.lnLastResortDefaultKey = HKEY_CURRENT_USER

If Vartype(m.tuKey) = T_NUMERIC
	If Not Inlist(m.tuKey, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG)
		*!* If no match for integer values, default:
		m.lnKey = m.lnLastResortDefaultKey
	Endif
Endif

If Vartype(m.tuKey) = T_CHARACTER

	m.tuKey = Upper(m.tuKey)

	Do Case
		Case m.tuKey == "HKEY_CLASSES_ROOT" ;
				Or m.tuKey == "HKCR" ;
				OR m.tuKey == "CLASSESROOT"
			m.lnKey = HKEY_CLASSES_ROOT

		Case m.tuKey == "HKEY_CURRENT_USER" ;
				Or m.tuKey == "HKCU" ;
				OR m.tuKey == "CURRENTUSER"
			m.lnKey = HKEY_CURRENT_USER

		Case m.tuKey == "HKEY_LOCAL_MACHINE" ;
				Or m.tuKey == "HKLM" ;
				OR m.tuKey == "LOCALMACHINE"
			m.lnKey = HKEY_LOCAL_MACHINE

		Case m.tuKey == "HKEY_USERS" ;
				Or m.tuKey == "HKU" ;
				OR m.tuKey == "USERS"
			m.lnKey = HKEY_USERS

		Case m.tuKey == "HKEY_CURRENT_CONFIG" ;
				Or m.tuKey == "HKCC" ;
				OR m.tuKey == "CURRENTCONFIG"
			m.lnKey = HKEY_CURRENT_CONFIG

		Otherwise
			*!* If no match for common text values, default:
			m.lnKey = m.lnLastResortDefaultKey

	Endcase

Endif

*!* If key is anything but numeric, default
If Vartype(m.lnKey) <> T_NUMERIC Then
	m.lnKey = m.lnLastResortDefaultKey
Endif

Return m.lnKey

ENDPROC
PROCEDURE _validatedefaulttype
*!* _ValidateDefaultType(eType)

Lparameters m.tuType

Local lnType As Integer

m.lnType = REG_SZ

Do Case

	Case Vartype(m.tuType) = T_NUMERIC
		If Not Inlist(m.tuType, REG_SZ, REG_MULTI_SZ, REG_BINARY, REG_DWORD) Then
			m.lnType = REG_SZ
		Endif

	Case Vartype(m.tuType) = T_CHARACTER

		Do Case
			Case Upper(m.tuType) == "REG_SZ"
				m.lnType = REG_SZ
			Case Upper(m.tuType) == "REG_BINARY"
				m.lnType = REG_BINARY
		Endcase

Endcase

Return m.lnType

ENDPROC
PROCEDURE _validatekey
*!* _ValidateKey(eKey)

*!* Key must be a numeric value, but user can set it to a String value
*!* to make programming easier. Here we translate string value to numeric
*!* value

*!* Change RegistryDefaultKey property to change default key

Lparameters m.tuKey

Local ;
	lnKey As Integer, ;
	lnLastResortDefaultKey As Integer

m.lnLastResortDefaultKey = HKEY_CURRENT_USER

If Vartype(m.tuKey) = T_NUMERIC
	If Not Inlist(m.tuKey, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG)
		*!* If no match for integer values, default:
		m.lnKey = This._DefaultKey
	Endif
Endif

If Vartype(m.tuKey) = T_CHARACTER

	m.tuKey = Upper(m.tuKey)

	Do Case
		Case m.tuKey == "HKEY_CLASSES_ROOT" ;
				Or m.tuKey == "HKCR" ;
				OR m.tuKey == "CLASSESROOT"
			m.lnKey = HKEY_CLASSES_ROOT

		Case m.tuKey == "HKEY_CURRENT_USER" ;
				Or m.tuKey == "HKCU" ;
				OR m.tuKey == "CURRENTUSER"
			m.lnKey = HKEY_CURRENT_USER

		Case m.tuKey == "HKEY_LOCAL_MACHINE" ;
				Or m.tuKey == "HKLM" ;
				OR m.tuKey == "LOCALMACHINE"
			m.lnKey = HKEY_LOCAL_MACHINE

		Case m.tuKey == "HKEY_USERS" ;
				Or m.tuKey == "HKU" ;
				OR m.tuKey == "USERS"
			m.lnKey = HKEY_USERS

		Case m.tuKey == "HKEY_CURRENT_CONFIG" ;
				Or m.tuKey == "HKCC" ;
				OR m.tuKey == "CURRENTCONFIG"
			m.lnKey = HKEY_CURRENT_CONFIG

		Otherwise
			*!* If no match for common text values, default:
			m.lnKey = This._DefaultKey

	Endcase

Endif

*!* If key is anything but numeric, default
If Vartype(m.lnKey) <> T_NUMERIC Then
	m.lnKey = This._DefaultKey
Endif

Return m.lnKey

ENDPROC
PROCEDURE _validatesubkey
*!* _ValidateSubKey()

Lparameters m.tcSubKey
*!* SubKey is a string value

Local lcSubKey As String

*!* If empty subkey, set default value:

If Empty(m.tcSubKey) OR VARTYPE(m.tcSubKey) <> T_CHARACTER Then

	If Empty(This.RegistryDefaultSubKey) Then
		*!* Here we get full path and name of exe, or we create it from project name:
		If Type("Application.ActiveProject") = "O" Then
			m.lcSubKey = "Software\VFP9\" + Proper(Juststem(Application.ActiveProject.Name))
		Else
			m.lcSubKey = "Software\" + Proper(Juststem(Application.ServerName))
		Endif
	Else
		m.lcSubKey = This.RegistryDefaultSubKey
	Endif

Else
	m.lcSubKey = m.tcSubKey
Endif

*!* Strip starting BackSlash
If Left(m.lcSubKey, 1) = "\" Then
	m.lcSubKey = Right(m.lcSubKey, Len(m.lcSubKey) - 1)
Endif

*!* Strip ending BackSlash
If Right(m.lcSubKey, 1) = "\" Then
	m.lcSubKey = Left(m.lcSubKey, Len(m.lcSubKey) - 1)
Endif

Return m.lcSubKey

ENDPROC
PROCEDURE decrypt
Lparameters pcString

Local m.lnx, m.lcDecrypted, m.lcUnsalted

*!* Decrypt
m.lcDecrypted = Strconv(Strconv(m.pcString, 16), 14)

*!* Remove Salt
m.lcUnsalted = ""
For m.lnx = 1 To Len(m.lcDecrypted) Step 2
	m.lcUnsalted = m.lcUnsalted + Substr(m.lcDecrypted, m.lnx, 1)
Endfor

Return m.lcUnsalted
ENDPROC
PROCEDURE deletesubkey
*!* Delete SubKey(cSubKey)

*!* If cSubKey is empty, delete the current subkey
*!* This will not delete subkeys that contain subkeys!

Lparameters m.tcSubKey As String

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcSubKeyName As String, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer

m.lnKey = This._Key

If Pcount() = 0 Then
	m.lcSubKey = Justpath(This._SubKey)
	m.lcSubKeyName = Justfname(This._SubKey)
Else
	If Vartype(m.tcSubKey) = T_CHARACTER Then
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcSubKey)
		m.lcSubKeyName 	= This._ExtractNameFromName(m.tcSubKey)
	Else
		Return FALSE
	Endif
Endif

Debugout m.lcSubKey, m.lcSubKeyName

m.lnApiRetVal = 0
m.lnKeyHandle = 0

*!*	If This._KeyHandle <> 0 Then
*!*		apiRegCloseKey(This._KeyHandle)
*!*	Endif

*!* Open registry key
m.lnApiRetVal = apiRegOpenKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	KEY_WRITE, ;
	@m.lnKeyHandle)

Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"

If m.lnApiRetVal = ERROR_SUCCESS Then
	m.lnApiRetVal = apiRegDeleteKey(m.lnKeyHandle, m.lcSubKeyName)
	Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegDeleteKeyEx"
Endif

This.LastErrorCode = m.lnApiRetVal

Return m.lnApiRetVal = ERROR_SUCCESS


ENDPROC
PROCEDURE deletesubkeytree
*!* DeleteSubKeyTree(cSubKey)

*!* How To Implement a Recursive RegDeleteKey for Windows NT
*!* /http://support.microsoft.com/?scid=kb%3Ben-us%3B142491&x=16&y=11

Lparameters m.tcSubKey As String

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcSubKeyName As String, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer

m.lnKey = This._Key

If Pcount() = 0 Then
	m.lcSubKey = Justpath(This._SubKey)
	m.lcSubKeyName = Justfname(This._SubKey)
Else
	If Vartype(m.tcSubKey) = T_CHARACTER Then
		m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcSubKey)
		m.lcSubKeyName 	= This._ExtractNameFromName(m.tcSubKey)
	Else
		Return FALSE
	Endif
Endif

Debugout m.lcSubKey, m.lcSubKeyName

m.lnApiRetVal = 0
m.lnKeyHandle = 0

*!*	If This._KeyHandle <> 0 Then
*!*		apiRegCloseKey(This._KeyHandle)
*!*	Endif

*!* Open registry key
m.lnApiRetVal = apiRegOpenKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	KEY_WRITE, ;
	@m.lnKeyHandle)

Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"

If m.lnApiRetVal = ERROR_SUCCESS Then
	m.lnApiRetVal = apiSHDeleteKey(m.lnKeyHandle, m.lcSubKeyName)
	Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegDeleteKeyEx"
Endif

This.LastErrorCode = m.lnApiRetVal

Return m.lnApiRetVal = ERROR_SUCCESS


ENDPROC
PROCEDURE deletevalue
*!* DeleteValue(cValueName)

Lparameters m.tcValueName As Character

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcValueName As String, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer

m.lnKey 		= This._Key 
m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)

Debugout m.lnKey, m.lcSubKey, m.lcValueName, "DeleteValue"

m.lnApiRetVal = 0
m.lnKeyHandle = 0

*!* Open registry key
m.lnApiRetVal = apiRegOpenKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	KEY_WRITE, ;
	@m.lnKeyHandle)

Assert m.lnApiRetVal = ERROR_SUCCESS Message "apiRegOpenKeyEx"

If m.lnApiRetVal = ERROR_SUCCESS Then
	
	This._KeyHandle = m.lnKeyHandle
	m.lnApiRetVal = apiRegDeleteValue(m.lnKeyHandle, m.lcValueName)

	Assert m.lnApiRetVal = ERROR_SUCCESS Message "ApiRegDeleteValue"

	*!* 20080404 there is no need to close predefined registry keys
	*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
	*!* If the key is not one of the predefined registry keys, call 
	*!* the RegCloseKey function after you have finished using the handle.
	*!* Close registry key
	*!* apiRegCloseKey(m.lnKeyHandle)

Endif

This.LastErrorCode = m.lnApiRetVal

Return m.lnApiRetVal = ERROR_SUCCESS

ENDPROC
PROCEDURE encrypt
Lparameters pcString

Local m.lnx As Integer, m.lcSalt As String, m.lcString As String

*!* Add Salt
m.lcSalt = ""
For m.lnx = 1 To Len(m.pcString)
	m.lcSalt = m.lcSalt + Chr(Int((255) * Rand( ) + 1))
Endfor

m.lcString = ""
For m.lnx = 1 To Len(m.pcString)
	m.lcString = m.lcString + Substr(m.pcString, m.lnx, 1) + Substr(m.lcSalt, m.lnx, 1)
Endfor

*!* Encrypt
m.lcString = Strconv(m.lcString,13)
m.lcString = Strconv(m.lcString,15)

Return m.lcString
ENDPROC
PROCEDURE getvalue
*!* GetValue(cValueName, eDefaultValue)

Lparameter m.tcValueName, m.tuDefaultValue

Return This._GetValueRegistry(m.tcValueName, m.tuDefaultValue)

ENDPROC
PROCEDURE getvaluekind
*!* GetValueKind(cValueName)

*!*	#Define REG_SZ                                                       1 
*!*	#Define REG_EXPAND_SZ                                                2 
*!*	#Define REG_BINARY                                                   3 
*!*	#Define REG_DWORD                                                    4 
*!*	#Define REG_DWORD_BIG_ENDIAN                                         5 
*!*	#Define REG_MULTI_SZ                                                 7 

Lparameter m.tcValueName As Character

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcValueName As String, ;
	lcData As String, ;
	lnType As Integer, ;
	lnRetVal As Integer, ;
	lnDataLen As Integer, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer

m.lnKey 		= This._Key
m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)

m.lnRetVal      = 0

m.lnApiRetVal = 0
m.lnKeyHandle = 0

**********************************************************

*!* Open registry key
m.lnApiRetVal = apiRegOpenKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	KEY_READ, ;
	@m.lnKeyHandle)

If m.lnApiRetVal = ERROR_SUCCESS Then
	This._KeyHandle = m.lnKeyHandle
	*!* Find out Value Kind and length of data:
	m.lnType 		= 0
	m.lcData 		= ""
	m.lnDataLen 	= 0

	m.lnApiRetVal = apiRegQueryValueEx( ;
		m.lnKeyHandle, ;
		m.lcValueName, ;
		0, ;
		@m.lnType, ;
		@m.lcData , ;
		@m.lnDataLen )

	If Inlist(m.lnApiRetVal, ERROR_SUCCESS, ERROR_MORE_DATA) Then
		m.lnApiRetVal = ERROR_SUCCESS
		m.lnRetVal = m.lnType
	Endif

	*!* 20080404 there is no need to close predefined registry keys
	*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
	*!* If the key is not one of the predefined registry keys, call
	*!* the RegCloseKey function after you have finished using the handle.
	*!* Close registry key
	*!* apiRegCloseKey(m.lnKeyHandle)

Endif

This.LastErrorCode = m.lnApiRetVal

Return m.lnRetVal

ENDPROC
PROCEDURE getvalues
*!* GetValues
Lparameters pcSubKey As String

Local m.loControl As Control

m.pcSubKey = Addbs(m.pcSubKey)
For Each m.loControl In Thisform.Controls
	Do Case
		Case Pemstatus(m.loControl, "ctlValue", CTLPEMSTATUS_DEFINED)
			m.loControl.ctlValue = This.GetValue(m.pcSubKey + m.loControl.Name, m.loControl.ctlValue)
		Case Pemstatus(m.loControl, "Value", CTLPEMSTATUS_DEFINED)
			m.loControl.Value = This.GetValue(m.pcSubKey + m.loControl.Name, m.loControl.Value)
	Endcase
Endfor

m.loControl = .Null.

ENDPROC
PROCEDURE registrydefaultkey_assign
*!* RegistryDefaultKey_Assign(eNewValue)

Lparameters tuNewValue
This._DefaultKey  = This._ValidateDefaultKey(m.tuNewValue)



ENDPROC
PROCEDURE registrydefaulttype_assign
*!* RegistryDefaultlType_Assign(eNewValue)

lparameters tuNewValue
This._DefaultType = This._ValidateDefaultType(m.tuNewValue)

ENDPROC
PROCEDURE registrykey_assign
*!* RegistryKey_Assign(eNewValue)

Lparameters tuNewValue
This._Key  = This._ValidateKey(m.tuNewValue)

ENDPROC
PROCEDURE registrysubkey_assign
*!* RegistrySubKey_Assign(eNewValue)

Lparameters tuNewValue
This._SubKey = This._ValidateSubKey(m.tuNewValue)

ENDPROC
PROCEDURE seekvalue
*!* SeekValue(cValueName)

Lparameters m.cValueName As String

Return This.GetValueKind(m.cValueName) <> 0

ENDPROC
PROCEDURE setvalue
*!* SetValue(cValueName, eValue)

Lparameter m.tcValueName, m.tuValue

Local ;
	lnKey As Integer,;
	lcSubKey As String, ;
	lcValueName As String, ;
	lcValue As String, ;
	lnValueKind As Integer, ;
	lnApiRetVal As Integer, ;
	lnKeyHandle As Integer, ;
	lpdwDisposition As Integer, ;
	lnValueLen As Integer

m.lnKey 		= This._Key
m.lcSubKey 		= This._SubKey + This._ExtractSubKeyFromName(m.tcValueName)
m.lcValueName 	= This._ExtractNameFromName(m.tcValueName)

*!* Determine ValueKind to use and convert Value:
Do Case

	Case Vartype(m.tuValue) = T_CHARACTER
		*!* If there are any nul characters, save as binary
		If NULA $ m.tuValue Then
			m.lnValueKind = REG_BINARY
		Else
			m.lnValueKind = This._DefaultType
		Endif
		m.lcValue = m.tuValue

	Case Vartype(m.tuValue) = T_DATE
		m.lnValueKind = This._DefaultType
		m.lcValue = Dtos(m.tuValue)

	Case Vartype(m.tuValue) = T_LOGICAL
		m.lnValueKind = REG_DWORD
		*!* Store 1 for TRUE, 0 for FALSE, convert to DWORD
		m.lcValue = Iif(m.tuValue, 0h01000000, 0h00000000)

	Case Vartype(m.tuValue) = T_NUMERIC
		*!* Check if we can store the number in a DWORD
		If m.tuValue - Int(m.tuValue) = 0 And Abs(m.tuValue) <= 2147483647 Then
			m.lnValueKind = REG_DWORD
			m.lcValue = BinToC(m.tuValue,"4RS")
		Else
			m.lnValueKind = This._DefaultType
			m.lcValue = Strtran(Transform(m.tuValue), Set("Point"), '.')
		Endif

	Case Vartype(m.tuValue) = T_VARBINARY
		m.lnValueKind = REG_BINARY
		m.lcValue = m.tuValue

	Case Vartype(m.tuValue) = T_DATETIME
		m.lnValueKind = This._DefaultType
		m.lcValue = Ttoc(m.tuValue, 3)

	Case Vartype(m.tuValue) = T_CURRENCY
		m.lnValueKind = This._DefaultType
		m.lcValue = Strtran(Transform(m.tuValue), Set("Point"), '.')

	Otherwise
		m.lcValue = Transform(m.tuValue)
		If NULA $ m.tuValue Then
			m.lnValueKind = REG_BINARY
		Else
			m.lnValueKind = This._DefaultType
		Endif

Endcase

*!* Do API stuff

m.lnApiRetVal = 0
m.lnKeyHandle = 0
m.lpdwDisposition = 0

*!* Open/Create registry key
m.lnApiRetVal = apiRegCreateKeyEx( ;
	m.lnKey, ;
	m.lcSubKey, ;
	0, ;
	0, ;
	REG_OPTION_NON_VOLATILE, ;
	KEY_ALL_ACCESS, ;
	0, ;
	@m.lnKeyHandle, ;
	@m.lpdwDisposition)

If m.lnApiRetVal = ERROR_SUCCESS

	m.lnValueLen = Len(m.lcValue)

	*!* Save data
	m.lnApiRetVal = apiRegSetValueEx( ;
		m.lnKeyHandle, ;
		m.lcValueName, ;
		0,;
		m.lnValueKind, ;
		m.lcValue, ;
		m.lnValueLen)

	*!* 20080404 there is no need to close predefined registry keys
	*!* *http://msdn2.microsoft.com/en-us/library/ms724844.aspx
	*!* If the key is not one of the predefined registry keys, call
	*!* the RegCloseKey function after you have finished using the handle.
	*!* Close registry key
	*!* apiRegCloseKey(m.lnKeyHandle)
Endif

This.LastErrorCode = m.lnApiRetVal

Assert m.lnApiRetVal = ERROR_SUCCESS Message Sys(16)

Return m.lnApiRetVal = ERROR_SUCCESS

ENDPROC
PROCEDURE setvalues
*!* SetValues
Lparameters pcSubKey As String

Local m.loControl As Control

m.pcSubKey = Addbs(m.pcSubKey)
For Each m.loControl In Thisform.Controls
	Do Case
		Case Pemstatus(m.loControl, "ctlValue", CTLPEMSTATUS_DEFINED)
			This.SetValue(m.pcSubKey + m.loControl.Name, m.loControl.ctlValue)
		Case Pemstatus(m.loControl, "Value", CTLPEMSTATUS_DEFINED)
			This.SetValue(m.pcSubKey + m.loControl.Name, m.loControl.Value)
	Endcase
Endfor

m.loControl = .Null.

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_addproperties 
*_extractnamefromname 
*_extractsubkeyfromname Extracts a subkey preffix appended to a value name.
*_getvalueini 
*_getvalueregistry 
*_setvalueini 
*_validatedefaultkey 
*_validatedefaulttype 
*_validatekey 
*_validatesubkey 
*decrypt 
*deletesubkey Deletes the values and current subkey if it has no child subkeys.
*deletesubkeytree Deleting a particular key will remove all entries below the key in the tree. No warning will be provided. If you want to delete a subkey only when it has no child subkeys, use the DeleteSubKey method.
*deletevalue Deletes the specified value from the current registry key.
*encrypt 
*getvalue Retrieves the value associated with the specified name, in the current registry key. If the name is not found in the specified key, returns a default value that you provide, or null, if the specified key does not exist.
*getvaluekind Retrieves the registry data type of the value associated with the specified name.
*getvalues 
*registrydefaultkey_assign 
*registrydefaulttype_assign 
*registrykey_assign 
*registrysubkey_assign 
*seekvalue Specifies if a value name exists in the registry.
*setvalue Sets the value of a name/value pair in the current registry key. The registry data type is determined from the type of data being stored.
*setvalues 
_defaultkey
_defaulttype
_key
_keyhandle
_memberdata XML Metadata for customizable properties
_subkey
lasterrorcode Specifies the last error code returned by the API functions.
registrydefaultkey Specifies the default registry key to use. If empty, it defaults to HKEY_CURRENT_USER.
registrydefaultsubkey Specifies the default registry subkey to use. If empty, it defaults to "Software\ExeName" at runtime, "Software\Vfp9\ProjectName" at design time.
registrydefaulttype Specifies the default value type to use for storing values in the registry. Valid values are REG_BINARY or REG_SZ. Integers will be saved as DWORDs.
registrykey Specifies the value of the registry key to use. If empty, RegistryDefaultKey is used.
registrysubkey Specifies the value of the registry subkey to use. If empty, RegistryDefaultSubKey is used.
[END RESERVED3]
[START RESERVED4]
ctl32_registry.bmp[END RESERVED4]
[START RESERVED5]
ctl32_registry.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1WY0DQXN1
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_registry
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_registry"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 6
Name = "lblname"
Top = 4
Width = 68
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_registry

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1T1102C68
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_scontainer
[START PROPERTIES]
BackColor = 140,200,200
BorderWidth = 0
Height = 120
Name = "ctl32_scontainer"
Width = 240
_memberdata = 
_windowprocedure = 0
ctlabout = ctl32_scontainer - Carlos Alloatti & Malcolm Greene.
ctlactivescrollbars = 0
ctlallowdrag = .T.
ctlallowzoom = .T.
ctlautocenter = .T.
ctlautoscroll = .T.
ctlbackcolor = -1
ctlbackstyle = 1
ctlbordercolor = -1
ctlborderstyle = 1
ctlforcescrollbars = 0
ctlhenabled = .F.
ctlhhwnd = 0
ctlhlargechange = -1
ctlhmargin = 5
ctlhmax = 0
ctlhsmallchange = 20
ctlhvalue = 0
ctlhvisible = .F.
ctlhwheelchange = 40
ctlscrollbars = 3
ctlthemes = .T.
ctlvenabled = .F.
ctlversion = 20061010
ctlvhwnd = 0
ctlvlargechange = -1
ctlvmargin = 5
ctlvmax = 0
ctlvsmallchange = 20
ctlvvalue = 0
ctlvvisible = .F.
ctlvwheelchange = 40
ctlzoom = 1
[END PROPERTIES]
[START PROTECTED]
_activateform^
_addproperties^
_bindevents^
_bindmousewheel^
_create^
_eventformactivate^
_eventformscontainerwm^
_eventformthemes^
_eventformvisible^
_eventmoved^
_eventnewobject^
_eventpageactivate^
_eventpagedeactivate^
_eventpageframeactivepage^
_eventresize^
_eventscreenthemes^
_objtoclient^
_resize^
_scroll^
_scrolltocontrol^
_settheme^
_wm_event^
ctlautocenter_assign^
ctlbackcolor_assign^
ctlbackstyle_assign^
ctlbordercolor_assign^
ctlborderstyle_assign^
ctlforcescrollbars_assign^
ctlhhwnd_access^
ctlhhwnd_assign^
ctlhmax_access^
ctlhmax_assign^
ctlhvalue_access^
ctlhvalue_assign^
ctlscrollbars_assign^
ctlvhwnd_access^
ctlvhwnd_assign^
ctlvmax_access^
ctlvmax_assign^
ctlvvalue_access^
ctlvvalue_assign^
[END PROTECTED]
[START METHODS]
PROCEDURE AddObject
Lparameters cName, cClass

If This.ControlCount > 0 Then
    This.RemoveObject(This.Controls(1).Name)
Endif





ENDPROC
PROCEDURE DblClick
*!* 20071108 Added This.ctlAllowZoom check ** Cesar Chalom

If This.ctlAllowZoom = TRUE Then
	This.ctlRestoreSize()
Endif

ENDPROC
PROCEDURE Init
*!* Init

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

*!* Add properties used internally
This._AddObjects()
This._AddProperties()

*!* Fill 
This._SetZoomRatios()

*!* Create scrollbars
This._Create()

This._BindEvents()



ENDPROC
PROCEDURE MouseDown
Lparameters nButton, nShift, nXCoord, nYCoord

*!* 20071108 Added This.ctlAllowDrag check ** Cesar Chalom

If This.ctlAllowDrag = TRUE And m.nButton = BUTTON_LEFT And This.ControlCount > 0  Then
	This.Controls(1).MousePointer = MOUSE_HAND
	This.nXCoord = m.nXCoord
	This.nYCoord = m.nYCoord
	This.lMouseDown = TRUE
Endif


ENDPROC
PROCEDURE MouseMove
Lparameters nButton, nShift, nXCoord, nYCoord

*!* lMouseDown will only be true if AllowDrag = .T.

If This.lMouseDown = TRUE Then
	If This.ControlCount > 0 And Not (This.Width > This.Controls(1).Width) Then
		This.ctlHValue = This.ctlHValue - m.nXCoord + This.nXCoord
	Endif

	If This.ControlCount > 0 And Not (This.Height > This.Controls(1).Height) Then
		This.ctlVVAlue = This.ctlVVAlue - m.nYCoord + This.nYCoord
	Endif

	This.nXCoord = m.nXCoord
	This.nYCoord = m.nYCoord
Endif

ENDPROC
PROCEDURE MouseUp
Lparameters nButton, nShift, nXCoord, nYCoord

If This.ControlCount > 0 And m.nButton = BUTTON_LEFT Then
	This.Controls(1).MousePointer = MOUSE_DEFAULT
Endif

This.lMouseDown = FALSE

ENDPROC
PROCEDURE MouseWheel
Lparameters nDirection, nShift, nXCoord, nYCoord

Local ;
	lcExcluded As Character, ;
	loControl As Control

Local ;
	lnWheelTicks As Number, ;
	lnWheelChange As Number, ;
	lnLargeChange As Number, ;
	lnViewPortSize As Number

Local  lnAnchor

m.lcExcluded = "COMBOBOX, LISTBOX, EDITBOX, GRID, SPINNER"
m.loControl = Sys(1270)

If This.ControlCount > 0 And Type("This.Controls(1).ActiveControl") == T_OBJECT And Type("m.loControl") == T_OBJECT
	If Upper(This.Controls(1).ActiveControl.BaseClass) $ m.lcExcluded And ;
			Sys(1272, m.loControl) == Sys(1272, This.Controls(1).ActiveControl)	Then
		Return
	Endif
Endif

m.lnWheelTicks = m.nDirection / 120

*!* If Shift pressed
If m.nShift = 1 Then
	m.lnWheelChange  = This.ctlHWheelChange  * m.lnWheelTicks
	m.lnLargeChange  = This.ctlHLargeChange
	m.lnViewPortSize = This.Width
Else
	m.lnWheelChange  = This.ctlVWheelChange  * m.lnWheelTicks
	m.lnLargeChange  = This.ctlVLargeChange
	m.lnViewPortSize = This.Height
Endif

If m.lnLargeChange < 0 Then
	m.lnLargeChange = m.lnViewPortSize
Else
	*!* LargeChange is a % of viewport
	If m.lnLargeChange < 1
		m.lnLargeChange = Int(m.lnViewPortSize * m.lnLargeChange)
	Endif
Endif

m.lnLargeChange = m.lnLargeChange * m.lnWheelTicks

Do Case
	Case m.nShift = 0 And This.ctlVEnabled And Inlist(This.ctlScrollBars, 2, 3)
		This.ctlVVAlue = This.ctlVVAlue - m.lnWheelChange

	Case m.nShift = 1 And This.ctlHEnabled And Inlist(This.ctlScrollBars, 1, 3) && Shift
		This.ctlHValue = This.ctlHValue - m.lnWheelChange

		*!* 20071108 Added This.ctlAllowZoom check ** Cesar Chalom
		*!* 20071108 Added check for stretch property

	Case m.nShift = 2 And This.ctlAllowZoom = TRUE && Ctrl then Resize if image
		If This.ControlCount > 0 And This.Controls(1).BaseClass = "Image" And This.Controls(1).Stretch > 0 Then

			This.nZoomIndex = Iif(m.lnWheelTicks > 0, This.nZoomIndex + 1, This.nZoomIndex - 1)
			If This.nZoomIndex <= 0 Then
				This.nZoomIndex = 1
			Endif
			If This.nZoomIndex > This.nMaxZoomIndex Then
				This.nZoomIndex = This.nMaxZoomIndex
			Endif

			This.ctlZoom = Round(This.aZoomLevel(This.nZoomIndex) * 100, 0)

			With This.Controls(1)
				m.lnAnchor = .Anchor
				.Anchor = 0
				.Height = This.nOriginalHeight * This.aZoomLevel(This.nZoomIndex)
				.Width = This.nOriginalWidth * This.aZoomLevel(This.nZoomIndex)
				.Anchor = m.lnAnchor
				This._Resize()
				*!* This part looks really complex, we need to scroll so what was in the middle
				*!* of the viewport stays in the middle. UNSOLVED YET!
				If This.ctlVEnabled Then
					This.ctlVVAlue = This.ctlVVAlue * .Height / This.nOriginalHeight
				Endif
				If This.ctlHEnabled Then
					This.ctlHValue = This.ctlHValue * .Width / This.nOriginalWidth
				Endif
			Endwith

		Endif
Endcase



ENDPROC
PROCEDURE NewObject
*!* NewObject

Lparameters cName, cClass, cModule, cInApplication

If This.ControlCount > 0 Then
    This.RemoveObject(This.Controls(1).Name)
Endif


ENDPROC
PROCEDURE _activateform
*!* //Dorin Vasilescu// TaskBar Class
*!* Set the form active if not active when clicking on scrollbar

If Type("_Screen.ActiveForm") == T_OBJECT
	*If the form is the topmost form just exit
	If Thisform = _Screen.ActiveForm
		Return
	Endif
Endif

Local ;
	loForm As Form, ;
	llModalWindow As Logical

For Each m.loForm In _Screen.Forms
	If Vartype(m.loForm.WindowType) == T_NUMERIC
		If m.loForm.WindowType = 1
			m.llModalWindow = TRUE
			Exit
		Endif
	Endif
Endfor

If m.llModalWindow = FALSE Then
	For Each m.loForm In _Screen.Forms
		If m.loForm.HWnd = Thisform.HWnd
			If Type("m.loForm.ActiveControl") == T_OBJECT
				If Pemstatus(m.loForm.ActiveControl, "SetFocus", CON_PEMSTAT_DEFINED)
					m.loForm.ActiveControl.SetFocus()
				Endif
			Else
				m.loForm.Show()
			Endif
			Exit
		Endif
	Endfor
Endif

ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* Define ScrollInfo Object to be used by various methods
This.AddProperty("oScrollInfo", Createobject("ctlScrollInfo"))


ENDPROC
PROCEDURE _addproperties

*!* Stores border Container 
This.AddProperty("cCntBorderName", Sys(2015))

*!* Stores an object reference to the cntBorder container control
This.AddProperty("oCntBorder", null)

*!* Stores full name of previous active control
This.AddProperty("cPrevControlFullName", "")

*!* Stores starting width and height of the client control
This.AddProperty("nOriginalHeight", 0)
This.AddProperty("nOriginalWidth", 0)

*!* Stores Max Zoom Index
This.AddProperty("nMaxZoomIndex", 35)

*!* Stores default zoom index
This.AddProperty("nDefaultZoomIndex", 19)

*!* Stores actual zoom index
This.AddProperty("nZoomIndex", This.nDefaultZoomIndex)

*!* Array to hold zoom level values, as a percent of actual size
This.AddProperty("aZoomLevel(This.nMaxZoomIndex)", 0)

*!* Stores width of border to use (1 with themes on, 2 with themes 2)
This.AddProperty("nBorderWidth", 0)

*!* Stores back color
This.AddProperty("nDefaultBackColor", 0)

*!* Stores border color
This.AddProperty("nDefaultBorderColor", 0)

*!* Stores the hWnd of the host window
This.AddProperty("nHosthWnd", ctlGetHostHWnd(This))

*!* Stores HWND of horizontal scrollbar control
This.AddProperty("nHCtlHwnd", 0)

*!* Stores value of previous BorderStyle setting
This.AddProperty("nOldBorderStyle", 0)

*!* Stores height of standard horizontal scrollbar
This.AddProperty("nScrollHeight", Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT))

*!* Stores width of standard vertical scrollbar
This.AddProperty("nScrollWidth", Sysmetric(SYSMETRIC_VSCROLLBARWIDTH))

*!* Stores HWND of vertical scrollbar control
This.AddProperty("nVCtlHwnd", 0)

*!* Stores old mouse coordinates
This.AddProperty("nXCoord", 0)
This.AddProperty("nYCoord", 0)

*!* Reports that horizontal scrollbar is enabled and visible
This.AddProperty("lHScrollBar", FALSE)

*!* Stores if control is inside a pageframe
This.AddProperty("lInPage", FALSE)

*!* Stores state of mousebutton
This.AddProperty("lMouseDown", FALSE)

*!* Indicates if the page that contains the control is the active page
*!* (if control is inside a pageframe)
This.AddProperty("lPageActive", FALSE)

*!* Indicates if resizing is already taking place
This.AddProperty("lResizing", FALSE)

*!* Reports that vertical scrollbar is enabled and visible
This.AddProperty("lVScrollBar", FALSE)

********************************************************************************
*!* Form properties
********************************************************************************

*!* This properties are used to proxy window messages
Thisform.AddProperty("_scontainerHwnd", 0)
Thisform.AddProperty("_scontainerWM", 0)
Thisform.AddProperty("_scontainerWparam", 0)
Thisform.AddProperty("_scontainerLparam", 0)


ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

*!* Since we can only have one Hwnd/message pair with Bindevent, we add properties
*!* to the form in Init and Bind to ThisForm._scroll_Msg. This way we can have more than one
*!* scrollable container in a form

Local loControl As Control

This._WindowProcedure = ctlGetWindowProcedure(Thisform.HWnd)

*Bindevent(This, "AddObject", This, "_EventNewObject",	1)
Bindevent(This, "NewObject", This, "_EventNewObject", 1)

Bindevent(This, "Resize", This, "_EventResize", 1)
Bindevent(This, "Moved",  This, "_EventMoved", 1)

*!* Bind window messages to window message proxy handler
Bindevent(This.nHosthWnd, WM_HSCROLL, This,	"_wm_event", 5)
Bindevent(This.nHosthWnd, WM_VSCROLL, This,	"_wm_event", 5)

Bindevent(Thisform, "Visible", This, "_EventFormVisible", 1)

*!* We will scan the object hierarchy to see if we have a page from a pageframe somewhere
*!* and we will bind to the page activate and deactivate events
m.loControl = This.Parent
Do While Not Upper(loControl.BaseClass) == "FORM"
	If Upper(m.loControl.BaseClass) == "PAGE" Then
		This.lInPage = TRUE
		Bindevent(m.loControl, "Activate", This, "_EventPageActivate", 1)
		Bindevent(m.loControl, "Deactivate", This, "_EventPageDeactivate", 1)
	Endif
	m.loControl = m.loControl.Parent
Enddo

*!* Bind window messages to window message proxy handler
*!* This are used by the AutoScrolling method
Bindevent(Thisform.HWnd, WM_KEYUP, This, "_wm_event", 5)
Bindevent(Thisform.HWnd, WM_CAPTURECHANGED, This, "_wm_event", 5)
Bindevent(Thisform.HWnd, WM_LBUTTONUP, This, "_wm_event", 5)

*!* If we are in a top level form, lets make shure this works
Bindevent(This.nHosthWnd, WM_KEYUP, This, "_wm_event", 5)
Bindevent(This.nHosthWnd, WM_CAPTURECHANGED, This, "_wm_event", 5)
Bindevent(This.nHosthWnd, WM_LBUTTONUP, This, "_wm_event", 5)

*!* MouseWheel management
If This.ControlCount > 0 Then
	This._BindMouseWheel(This.Controls(1))
Endif

*!* Click-Drag-Move Management
If This.ControlCount > 0 Then
	Bindevent(This.Controls(1), "DblClick", This, "DblClick", 1)
	Bindevent(This.Controls(1), "MouseDown", This, "MouseDown", 1)
	Bindevent(This.Controls(1), "MouseUp", This, "MouseUp",	1)
	Bindevent(This.Controls(1), "MouseMove", This, "MouseMove",	1)
Endif

*!* Theme management
Bindevent(_Screen, 	"Themes", This, "_EventScreenThemes", 1)
Bindevent(Thisform, "Themes", This, "_EventFormThemes", 1)

*!* Here we bind to thisform._scontainerWM, value that is set by _wm_event
Bindevent(Thisform, "_scontainerWM", This, "_EventFormscontainerWM", 1)

Bindevent(Thisform, "Activate", This, "_EventFormActivate", 1)

ENDPROC
PROCEDURE _bindmousewheel
*!* _BindMouseWheel()
*!* This method binds the MouseWheel event of all contained controls
*!* to the MouseWheel event of the scrollable container.
*!* It goes thru the whole control hierarchy.

Lparameters toObject

Local loChildObject As Control
Local lcThisMethod

*!* Get the name of this method, so we dont have to know it:
m.lcThisMethod = "This." + Getwordnum(Program(), Getwordcount(Program(), "."), ".")

If Pemstatus(m.toObject, "MouseWheel", CON_PEMSTAT_DEFINED)
	Bindevent(m.toObject, "MouseWheel", This, "MouseWheel", 1)
Endif

If Pemstatus(m.toObject, "Objects", CON_PEMSTAT_DEFINED)
	For Each m.loChildObject In m.toObject.Objects
		Evaluate(m.lcThisMethod + "(m.loChildObject)")
	Endfor
Endif

ENDPROC
PROCEDURE _create
Local ;
	m.lnAnchor, ;
	m.llLock

*!* Save client control dimensions:
If This.ControlCount > 0 Then
	This.nOriginalHeight = This.Controls(1).Height
	This.nOriginalWidth  = This.Controls(1).Width
Endif

*!* Resize control to make room for a border if a border is set
*!* border gets done in _AddBorder()

m.llLock = Thisform.LockScreen
Thisform.LockScreen = TRUE

This.BorderWidth = 0

*!* Add border Container
This.Parent.AddObject(This.cCntBorderName, "Container")
This.oCntBorder = Evaluate("This.Parent." + This.cCntBorderName)

This.oCntBorder.BackStyle = This.BackStyle
This.oCntBorder.BorderWidth = 0
This.oCntBorder.Top =    This.Top
This.oCntBorder.Left =   This.Left
This.oCntBorder.Width =  This.Width  + Iif(This.ctlVvisible, This.nScrollWidth,  0)
This.oCntBorder.Height = This.Height + Iif(This.ctlHvisible, This.nScrollHeight, 0)
This.oCntBorder.ZOrder(1)
This.oCntBorder.Anchor = This.Anchor
This.oCntBorder.Visible = TRUE

*!* This creates the scrollbars, it does not position or make them visible.
*!* _Resize positions, shows/hides scrollbars as needed

Local ;
	dwExStyle As Integer, ;
	lpClassName As Character, ;
	lpWindowName As Character, ;
	dwStyle As Integer, ;
	hWndParent As Integer, ;
	hMenu As Integer, ;
	hInstance As Integer, ;
	lpParam As Integer, ;
	lnTop As Integer, ;
	lnLeft As Integer, ;
	lnWidth As Integer, ;
	lnHeight As Integer

*!* Create Horizontal ScrollBar
m.dwExStyle    =  0
m.lpClassName  = WC_SCROLLBARA
m.lpWindowName = Sys(2015)
m.dwStyle      = Bitor(WS_CHILD, SBS_HORZ)
m.hWndParent   = This.nHosthWnd
m.hMenu        = 0

*!* What is the HINSTANCE passed to CreateWindow and RegisterClass used for?
*!* http://blogs.msdn.com/oldnewthing/archive/2005/04/18/409205.aspx

m.hInstance    = 0
m.lpParam      = 0
m.lnTop        = This._ObjToClient(This, "B")
m.lnLeft       = This._ObjToClient(This, "L")
m.lnWidth      = This.Width
m.lnHeight     = This.nScrollHeight

This.nHCtlHwnd = apiCreateWindowEx( ;
	m.dwExStyle, ;
	m.lpClassName, ;
	m.lpWindowName, ;
	m.dwStyle, ;
	m.lnLeft, ;
	m.lnTop, ;
	m.lnWidth, ;
	m.lnHeight, ;
	m.hWndParent, ;
	m.hMenu, ;
	m.hInstance, ;
	m.lpParam)

*!* Create Vertical Scrollbar
m.dwExStyle    =  0
m.lpClassName  = WC_SCROLLBARA
m.lpWindowName = Sys(2015)
m.dwStyle      = Bitor(WS_CHILD, SBS_VERT)
m.hWndParent   = This.nHosthWnd
m.hMenu        = 0
m.hInstance    = 0
m.lpParam      = 0
m.lnTop        = This._ObjToClient(This, "T")
m.lnLeft       = This._ObjToClient(This, "R")
m.lnWidth      = This.nScrollWidth
m.lnHeight     = This.Width

This.nVCtlHwnd = apiCreateWindowEx( ;
	m.dwExStyle, ;
	m.lpClassName, ;
	m.lpWindowName, ;
	m.dwStyle, ;
	m.lnLeft, ;
	m.lnTop, ;
	m.lnWidth, ;
	m.lnHeight, ;
	m.hWndParent, ;
	m.hMenu, ;
	m.hInstance, ;
	m.lpParam)

This._SetTheme()
This.ctlBackColor 		= This.ctlBackColor
This.ctlBackStyle 		= This.ctlBackStyle
This.ctlBorderStyle 	= This.ctlBorderStyle
*!* ctlBorderColor is set in evthanlder_form_activate,
*!* we need form visible, this way we do not disrupt chain of events

Thisform.LockScreen = m.llLock



ENDPROC
PROCEDURE _eventformactivate
*!* _EventFormActivate

Unbindevents( Thisform, "Activate", This, "_EventFormActivate")

This.ctlBorderColor = This.ctlBorderColor

ENDPROC
PROCEDURE _eventformscontainerwm
*!* _EventFormscontainerWM

Do Case
	Case Thisform._scontainerWM = WM_HSCROLL And Thisform._scontainerLparam = This.nHCtlHwnd
			This._Scroll(Thisform._scontainerHwnd, Thisform._scontainerWM, Thisform._scontainerWparam, Thisform._scontainerLparam)

	Case Thisform._scontainerWM = WM_VSCROLL And Thisform._scontainerLparam = This.nVCtlHwnd
			This._Scroll(Thisform._scontainerHwnd, Thisform._scontainerWM, Thisform._scontainerWparam, Thisform._scontainerLparam)

	Case Thisform._scontainerWM = WM_CAPTURECHANGED
		This._ScrollToControl()

	Case Thisform._scontainerWM = WM_KEYUP
		This._ScrollToControl()

	Case Thisform._scontainerWM = WM_LBUTTONUP
		This._ScrollToControl()

Endcase

ENDPROC
PROCEDURE _eventformthemes
This._SetTheme()
ENDPROC
PROCEDURE _eventformvisible
This._Resize()
ENDPROC
PROCEDURE _eventmoved
Local ;
    lnTop As Number, ;
    lnLeft As Number, ;
    lnWidth As Number, ;
    lnHeight As Number

m.lnTop    = This._ObjToClient(This, "B")
m.lnLeft   = This._ObjToClient(This, "L")
m.lnWidth  = This.Width
m.lnHeight = This.nScrollHeight

apiSetWindowPos(This.nHCtlHwnd, ;
    0, ;
    m.lnLeft, ;
    m.lnTop, ;
    m.lnWidth, ;
    m.lnHeight, ;
    SWP_NOZORDER)

m.lnTop    = This._ObjToClient(This, "T")
m.lnLeft   = This._ObjToClient(This, "R")
m.lnWidth  = This.nScrollWidth
m.lnHeight = This.Height

apiSetWindowPos(This.nVCtlHwnd, ;
    0, ;
    m.lnLeft, ;
    m.lnTop, ;
    m.lnWidth, ;
    m.lnHeight, ;
    SWP_NOZORDER)


ENDPROC
PROCEDURE _eventnewobject
Lparameters cName, cClass, cModule, cInApplication

Local loControl

m.loControl = Evaluate("This." + m.cName)
m.loControl.Visible = TRUE

*!* Save client control dimensions:
If This.ControlCount > 0 Then
    This.nOriginalHeight = This.Controls(1).Height
    This.nOriginalWidth  = This.Controls(1).Width
Endif

*!* MouseWheel management
If This.ControlCount > 0 Then
    This._BindMouseWheel(This.Controls(1))
Endif

*!* Click-Drag-Move Management
If This.ControlCount > 0 Then
    Bindevent(This.Controls(1), "DblClick", This, "DblClick", 1)
    Bindevent(This.Controls(1), "MouseDown", This, "MouseDown", 1)
    Bindevent(This.Controls(1), "MouseUp", This, "MouseUp",	1)
    Bindevent(This.Controls(1), "MouseMove", This, "MouseMove",	1)
Endif

*!* Here we hide both scrollbars, so the thumb size updates in the
*!* _Resize that follows.

apiShowScrollBar(This.nHCtlHwnd, SB_CTL, 0)
apiShowScrollBar(This.nVCtlHwnd, SB_CTL, 0)

This._Resize()

ENDPROC
PROCEDURE _eventpageactivate
*!* This manages scrollbars show/hide when changing active page in pageframes
This.lPageActive = TRUE
This._Resize()

ENDPROC
PROCEDURE _eventpagedeactivate
*!* This manages scrollbars show/hide when changing active page in pageframes
This.lPageActive = FALSE
This._Resize()

ENDPROC
PROCEDURE _eventpageframeactivepage
WAIT "activepage" window
ENDPROC
PROCEDURE _eventresize
This._Resize()

ENDPROC
PROCEDURE _eventscreenthemes
This._SetTheme()
ENDPROC
PROCEDURE _objtoclient
*!* This replaces OBJTOCLIENT that has bugs with pageframes
Parameters toControl, tcPosition

Local lnPosition As Integer

m.tcPosition = Upper(m.tcPosition)
m.lnPosition = 0

Do Case

	Case m.tcPosition $ "TB"
		Do While Not Upper(m.toControl.BaseClass) == "FORM"
			If Pemstatus(m.toControl, "Top", CON_PEMSTAT_DEFINED) Then
				m.lnPosition = m.lnPosition + m.toControl.Top
			Endif
			If Upper(m.toControl.BaseClass) == "PAGE" Then
				If m.toControl.Parent.TabOrientation = CON_TABOR_TOP Then	&& Top
					m.lnPosition = m.lnPosition + ;
						m.toControl.Parent.Height - ;
						m.toControl.Parent.PageHeight - ;
						m.toControl.Parent.BorderWidth * 2
				Else
					m.lnPosition = m.lnPosition + 1
				Endif
			Endif
			m.toControl = m.toControl.Parent
		Enddo

		If m.tcPosition == "B" Then
			m.lnPosition = m.lnPosition + This.Height
		Endif

	Case m.tcPosition $ "LR"
		Do While Not Upper(m.toControl.BaseClass) == "FORM"
			If Pemstatus(m.toControl, "Left", CON_PEMSTAT_DEFINED) Then
				m.lnPosition = m.lnPosition + m.toControl.Left
			Endif
			If Upper(m.toControl.BaseClass) == "PAGE"
				If m.toControl.Parent.TabOrientation = CON_TABOR_LEFT Then	&& Left
					m.lnPosition = m.lnPosition + ;
						m.toControl.Parent.Width - ;
						m.toControl.Parent.PageWidth - ;
						m.toControl.Parent.BorderWidth * 2
				Else
					m.lnPosition = m.lnPosition + 1
				Endif
			Endif
			m.toControl = m.toControl.Parent
		Enddo

		If m.tcPosition == "R" Then
			m.lnPosition = m.lnPosition + This.Width
		Endif

Endcase

Return m.lnPosition

ENDPROC
PROCEDURE _resize
If This.lResizing = TRUE Then
    Return
Endif

This.lResizing = TRUE

Local llOldLockScreen As Logical

Local ;
    lnClientWidth As Number, ;
    lnClientHeight As Number, ;
    lnOldAnchor As Number, ;
    lnViewPortWidth As Number, ;
    lnViewPortHeight As Number, ;
    lnTop As Number, ;
    lnLeft As Number, ;
    lnHeight As Number, ;
    lnWidth As Number, ;
    lcScrollInfo As Character, ;
    lnPosition As Number, ;
    lnShow As Integer

m.llOldLockScreen = Thisform.LockScreen

Thisform.LockScreen = TRUE

*!* If client container should autosize with SC
If This.ControlCount > 0
    If This.Controls(1).Anchor = 10 Then
        m.lnOldAnchor = This.Controls(1).Anchor
        This.Controls(1).Anchor = 0
        This.Controls(1).Left = 0
        This.Controls(1).Width = This.Width - This.nScrollWidth
        This.Controls(1).Anchor = m.lnOldAnchor
    Endif
    If This.Controls(1).Anchor = 5 Then
        m.lnOldAnchor = This.Controls(1).Anchor
        This.Controls(1).Anchor = 0
        This.Controls(1).Top = 0
        This.Controls(1).Height = This.Height - This.nScrollHeight
        This.Controls(1).Anchor = m.lnOldAnchor
    Endif
Endif

*!* Store Width and Height of the Client Area:
If This.ControlCount > 0 Then
    m.lnClientWidth = This.Controls(1).Width
    m.lnClientHeight = This.Controls(1).Height
Else
    m.lnClientWidth = This.Width / 2
    m.lnClientHeight = This.Height / 2
Endif

*!* Restore Width and Height of Scrollable Container
*!* Only change Anchor if Width > 0 to prevent Anchor bug.
If Not (This.Width = 0 Or This.Height = 0) Then
    m.lnOldAnchor = This.Anchor
    This.Anchor = 0
    If This.lHScrollBar = TRUE  Then
        This.Height = This.Height + This.nScrollHeight
    Endif
    If This.lVScrollBar = TRUE Then
        This.Width = This.Width + This.nScrollWidth
    Endif
    This.Anchor = m.lnOldAnchor
Endif

*!* Set ViewPort
m.lnViewPortWidth = This.Width
m.lnViewPortHeight = This.Height


*!* If ScrollBar wanted
If Inlist(This.ctlScrollBars, 1, 3) Then
    *!* If needed or forced
    If This.Width < m.lnClientWidth Or Inlist(This.ctlForceScrollBars, 1, 3) Then
        m.lnViewPortHeight = m.lnViewPortHeight - This.nScrollHeight
        This.lHScrollBar = TRUE
    Else
        This.lHScrollBar = FALSE
    Endif
Else
    This.lHScrollBar = FALSE
Endif

*!* If ScrollBar wanted
If Inlist(This.ctlScrollBars, 2, 3) Then
    *!* If Needed or forced
    If This.Height < m.lnClientHeight Or Inlist(This.ctlForceScrollBars, 2, 3) Then
        m.lnViewPortWidth = m.lnViewPortWidth - This.nScrollWidth
        This.lVScrollBar = TRUE
    Else
        This.lVScrollBar = FALSE
    Endif
Else
    This.lVScrollBar = FALSE
Endif

*!* Now check again since added ScrollBars make ViewPort even smaller
*!* No need to check for ctlForceScrollBars now
If Inlist(This.ctlScrollBars, 1, 3) Then
    If (This.lHScrollBar = FALSE And This.lVScrollBar = TRUE) Then
        If m.lnViewPortWidth < m.lnClientWidth Then
            m.lnViewPortHeight = m.lnViewPortHeight - This.nScrollHeight
            This.lHScrollBar = TRUE
        Endif
    Endif
Endif

If Inlist(This.ctlScrollBars, 2, 3) Then
    If (This.lVScrollBar = FALSE And This.lHScrollBar = TRUE) Then
        If m.lnViewPortHeight < m.lnClientHeight Then
            m.lnViewPortWidth = m.lnViewPortWidth - This.nScrollWidth
            This.lVScrollBar = TRUE
        Endif
    Endif
Endif

*!* Resize scrollable container to acomodate scrollbars
If This.lHScrollBar = TRUE Or This.lVScrollBar = TRUE
    If Not (This.Width = 0 Or This.Height = 0) Then
        m.lnOldAnchor = This.Anchor
        This.Anchor = 0
        This.Height = m.lnViewPortHeight
        This.Width = m.lnViewPortWidth
        This.Anchor = m.lnOldAnchor
    Endif
Endif

*!*	 Horizontal ScrollBar: update data, move, show if needed
This.oScrollInfo.fMask     = Bitor(SIF_PAGE, SIF_RANGE)
This.oScrollInfo.nMin      = 0
This.oScrollInfo.nMax      = m.lnClientWidth - 1
This.oScrollInfo.nPage     = m.lnViewPortWidth
This.oScrollInfo.nPos      = 0
This.oScrollInfo.nTrackPos = 0

m.lcScrollInfo = This.oScrollInfo.Value

apiSetScrollInfo(This.nHCtlHwnd, SB_CTL, @m.lcScrollInfo, 0)

*!* Get ScrollBar Position and move child control
m.lnPosition = apiGetScrollPos(This.nHCtlHwnd, SB_CTL)
If This.ControlCount > 0 Then
    m.lnOldAnchor = This.Controls(1).Anchor
    This.Controls(1).Anchor = 0
    This.Controls(1).Left = - m.lnPosition
    This.Controls(1).Anchor = m.lnOldAnchor
Endif

m.lnTop    = This._ObjToClient(This, "B")
m.lnLeft   = This._ObjToClient(This, "L")
m.lnWidth  = This.Width
m.lnHeight = This.nScrollHeight

apiSetWindowPos(This.nHCtlHwnd, ;
    0, ;
    m.lnLeft, ;
    m.lnTop, ;
    m.lnWidth, ;
    m.lnHeight, ;
    SWP_NOZORDER)

m.lnShow = 0

If This.lHScrollBar = TRUE And This.Height > 0 Then
    This.ctlHVisible = TRUE
    m.lnShow = 1
Else
    This.ctlHVisible = FALSE
    m.lnShow = 0
Endif

If This.lInPage = TRUE And This.lPageActive = FALSE Then
    m.lnShow = 0
Endif

apiShowScrollBar(This.nHCtlHwnd, SB_CTL, m.lnShow)

If m.lnViewPortWidth > m.lnClientWidth Then
    apiEnableWindow(This.nHCtlHwnd, 0)
    This.ctlHEnabled = FALSE
Else
    apiEnableWindow(This.nHCtlHwnd, 1)
    This.ctlHEnabled = TRUE
Endif

*!* Vertical ScrollBar: update data, move, show if needed
This.oScrollInfo.fMask     = Bitor(SIF_PAGE, SIF_RANGE)
This.oScrollInfo.nMin      = 0
This.oScrollInfo.nMax      = m.lnClientHeight - 1
This.oScrollInfo.nPage     = m.lnViewPortHeight
This.oScrollInfo.nPos      = 0
This.oScrollInfo.nTrackPos = 0

m.lcScrollInfo = This.oScrollInfo.Value

apiSetScrollInfo(This.nVCtlHwnd, SB_CTL, @m.lcScrollInfo, 0)

*!* Get ScrollBar Position and move Child control
m.lnPosition = apiGetScrollPos(This.nVCtlHwnd, SB_CTL)

If This.ControlCount > 0 Then
    m.lnOldAnchor = This.Controls(1).Anchor
    This.Controls(1).Anchor = 0
    This.Controls(1).Top = - m.lnPosition
    This.Controls(1).Anchor = m.lnOldAnchor
Endif

m.lnTop    = This._ObjToClient(This, "T")
m.lnLeft   = This._ObjToClient(This, "R")
m.lnWidth  = This.nScrollWidth
m.lnHeight = This.Height

apiSetWindowPos(This.nVCtlHwnd, ;
    0, ;
    m.lnLeft, ;
    m.lnTop, ;
    m.lnWidth, ;
    m.lnHeight, ;
    SWP_NOZORDER)

m.lnShow = 0

If This.lVScrollBar = TRUE And This.Width > 0 Then
    This.ctlVVisible = TRUE
    m.lnShow = 1
Else
    This.ctlVVisible = FALSE
    m.lnShow = 0
Endif

If This.lInPage = TRUE And This.lPageActive = FALSE Then
    m.lnShow = 0
Endif

apiShowScrollBar(This.nVCtlHwnd, SB_CTL, m.lnShow)

If m.lnViewPortHeight > m.lnClientHeight Then
    apiEnableWindow(This.nVCtlHwnd, 0)
    This.ctlVEnabled = FALSE
Else
    apiEnableWindow(This.nVCtlHwnd, 1)
    This.ctlVEnabled = TRUE
Endif

If This.ctlAutoCenter = TRUE And This.ControlCount > 0 Then
    m.lnOldAnchor = This.Controls(1).Anchor
    This.Controls(1).Anchor = 0
    If This.Width > m.lnClientWidth
        This.Controls(1).Left = (This.Width - This.Controls(1).Width) / 2
    Endif

    If This.Height > m.lnClientHeight Then
        This.Controls(1).Top = (This.Height - This.Controls(1).Height) / 2
    Endif
    This.Controls(1).Anchor = m.lnOldAnchor
Endif

*!* Set value of ctlActiveScrollBars Property
Do Case
    Case This.lHScrollBar = TRUE And This.lVScrollBar = TRUE
        This.ctlActiveScrollBars = 3
    Case This.lHScrollBar = FALSE And This.lVScrollBar = TRUE
        This.ctlActiveScrollBars = 2
    Case This.lHScrollBar = TRUE And This.lVScrollBar = FALSE
        This.ctlActiveScrollBars = 1
    Otherwise
        This.ctlActiveScrollBars = 0
Endcase

*!* If client container should autosize with SC
If This.ControlCount > 0
    If This.Controls(1).Anchor = 10 Then
        m.lnOldAnchor = This.Controls(1).Anchor
        This.Controls(1).Anchor = 0
        This.Controls(1).Left = 0
        This.Controls(1).Width = This.Width
        This.Controls(1).Anchor = m.lnOldAnchor
    Endif
    If This.Controls(1).Anchor = 5 Then
        m.lnOldAnchor = This.Controls(1).Anchor
        This.Controls(1).Anchor = 0
        This.Controls(1).Top = 0
        This.Controls(1).Height = This.Height
        This.Controls(1).Anchor = m.lnOldAnchor
    Endif
Endif

Thisform.LockScreen = m.llOldLockScreen
This.lResizing = FALSE

ENDPROC
PROCEDURE _scroll
*!* http://windowssdk.msdn.microsoft.com/en-us/library/ms651283.aspx
*!* The low-order word specifies a scroll bar value that indicates the user's scrolling request.
*!* The high-order word specifies the current position of the scroll box if the low-order word
*!* is SB_THUMBPOSITION or SB_THUMBTRACK; otherwise, this word is not used.

Lparameters nHWND As Integer, nMSG As Integer, nWPARAM As Integer, nLPARAM As Integer

This._ActivateForm()

Local ;
    lnMsg As Number, ;
    lnRequest As Number, ;
    lnPosition As Number, ;
    lnHwnd As Number, ;
    lnSmallChange As Number, ;
    lnLargeChange As Number, ;
    lnViewPortSize As Number, ;
    lnOldAnchor As Number, ;
    lcScrollInfo As Character

m.lnMsg      = m.nMSG
m.lnRequest  = ctlLoWord(m.nWPARAM)
m.lnHwnd     = m.nLPARAM
m.lnPosition = apiGetScrollPos(m.lnHwnd, SB_CTL)

If m.lnMsg = WM_HSCROLL Then
    m.lnSmallChange  = This.ctlHSmallChange
    m.lnLargeChange  = This.ctlHLargeChange
    m.lnViewPortSize = This.Width
Else
    m.lnSmallChange  = This.ctlVSmallChange
    m.lnLargeChange  = This.ctlVLargeChange
    m.lnViewPortSize = This.Height
Endif

If m.lnLargeChange < 0 Then
    m.lnLargeChange = m.lnViewPortSize
Else
    *!* LargeChange is a % of viewport
    If m.lnLargeChange < 1
        m.lnLargeChange = Int(m.lnViewPortSize * m.lnLargeChange)
    Endif
Endif

Do Case

    Case m.lnRequest = SB_ENDSCROLL		&& 8
        Return && We dont need to do anything else

    Case m.lnRequest = SB_THUMBPOSITION	&& 4
        m.lnPosition = ctlHiWord(m.nWPARAM)

    Case m.lnRequest = SB_THUMBTRACK	&& 5
        m.lnPosition = ctlHiWord(m.nWPARAM)

    Case m.lnRequest = SB_LINELEFT		&& 0 SB_LINEUP
        m.lnPosition = m.lnPosition - m.lnSmallChange

    Case m.lnRequest = SB_LINERIGHT		&& 1 SB_LINEDOWN
        m.lnPosition = m.lnPosition + m.lnSmallChange

    Case m.lnRequest = SB_PAGELEFT		&& 2 SB_PAGEUP
        m.lnPosition = m.lnPosition - m.lnLargeChange

    Case m.lnRequest = SB_PAGERIGHT		&& 3 SB_PAGEDOWN
        m.lnPosition = m.lnPosition + m.lnLargeChange

    Case m.lnRequest = SB_LEFT			&& 6 SB_TOP
        m.lnPosition = 0

    Case m.lnRequest = SB_RIGHT			&& 7 SB_BOTTOM
        m.lnPosition = 65535
Endcase

This.oScrollInfo.fMask     = SIF_POS
This.oScrollInfo.nMin      = 0
This.oScrollInfo.nMax      = 0
This.oScrollInfo.nPage     = 0
This.oScrollInfo.nPos      = m.lnPosition
This.oScrollInfo.nTrackPos = 0

m.lcScrollInfo = This.oScrollInfo.Value

apiSetScrollInfo(m.lnHwnd, SB_CTL, @m.lcScrollInfo, 1)

m.lnPosition = apiGetScrollPos(m.lnHwnd, SB_CTL)

If This.ControlCount > 0 Then
    m.lnOldAnchor = This.Controls(1).Anchor
    This.Controls(1).Anchor = 0
    If m.lnMsg = WM_HSCROLL Then
        This.Controls(1).Left = - m.lnPosition
    Else
        This.Controls(1).Top = - m.lnPosition
    Endif
    This.Controls(1).Anchor = m.lnOldAnchor
Endif

Raiseevent(This, "ctlScrolled", m.lnRequest + Iif(m.lnMsg = WM_HSCROLL, 10, 0))



ENDPROC
PROCEDURE _scrolltocontrol
If This.ctlAutoScroll = FALSE Then
    Return
Endif

Local ;
    loControl As Control, ;
    lnMargin As Number, ;
    loActiveControl As Control, ;
    loOriginalActiveControl As Control, ;
    lnHSValue As Number, ;
    lnVSValue As Number, ;
    llMoveX As Number, ;
    llMoveY As Number

*!* These two will tell us later if we need to scroll:
m.llMoveX = FALSE
m.llMoveY = FALSE

If This.ControlCount > 0 And Type("This.Controls(1).ActiveControl") == T_OBJECT Then

    m.loActiveControl = This.Controls(1).ActiveControl
    m.loControl = This.Controls(1)

    *!* Dont do anything if we are still in the same control we last autoscrolled to.
    If This.cPrevControlFullName == Sys(1272, m.loActiveControl) Then
        Return
    Endif

    m.lnHSValue = This.ctlHValue
    m.lnVSValue = This.ctlVVAlue

    This.cPrevControlFullName = Sys(1272, m.loActiveControl)
    m.loOriginalActiveControl = m.loActiveControl
    *!* This will navigate upwards the containership levels until we find
    *!* the topmost control that is a child of the main client container control
    Do While (Sys(1272, m.loActiveControl.Parent) == Sys(1272, This.Controls(1))) = FALSE
        m.loActiveControl = m.loActiveControl.Parent
    Enddo

    m.lnMargin = This.ctlHMargin

    *!* Is control left border beyond left border
    If m.loControl.Left + m.loActiveControl.Left < 0 Then
        m.lnHSValue  = 0
        m.llMoveX = TRUE
    Endif

    *!* Is control left border beyond right border
    If m.loControl.Left + m.loActiveControl.Left > This.Width Then
        m.lnHSValue  = m.loActiveControl.Left + m.loActiveControl.Width - This.Width + m.lnMargin
        m.llMoveX = TRUE
    Endif

    *!* Is control right border beyond right border
    If m.loControl.Left + m.loActiveControl.Left + m.loActiveControl.Width > This.Width Then
        m.lnHSValue  = m.loActiveControl.Left + m.loActiveControl.Width - This.Width + m.lnMargin
        m.llMoveX = TRUE
    Endif

    *!* Is control left border beyond left border
    If m.loControl.Left + m.loActiveControl.Left < 0 Then
        m.lnHSValue  = m.loActiveControl.Left - m.lnMargin
        m.llMoveX = TRUE
    Endif

    m.lnMargin = This.ctlVMargin

    *!* Is control top border beyond top border
    If  m.loControl.Top + m.loActiveControl.Top > This.Height Then
        m.lnVSValue  = m.loActiveControl.Top + m.loActiveControl.Height - This.Height + m.lnMargin
        m.llMoveY = TRUE
    Endif

    *!* Is control bottom border beyond bottom border
    If  m.loControl.Top + m.loActiveControl.Top + m.loActiveControl.Height > This.Height Then
        m.lnVSValue  = m.loActiveControl.Top + m.loActiveControl.Height - This.Height + m.lnMargin
        m.llMoveY = TRUE
    Endif

    *!* Is control top border beyond top border
    If  m.loControl.Top + m.loActiveControl.Top < 0 Then
        m.lnVSValue  = m.loActiveControl.Top - m.lnMargin
        m.llMoveY = TRUE
    Endif

    If This.ctlAutoCenter = FALSE Then
        If m.loActiveControl.TabIndex = 1 And This.Controls(1).Name == m.loActiveControl.Parent.Name Then
            m.lnHSValue  = 0
            m.lnVSValue  = 0
        Endif
    Endif

    *!* Only scroll horizontally if needed
    If m.llMoveX = TRUE
        This.ctlHValue = m.lnHSValue
    Endif

    *!* Only scroll vertically if needed
    If m.llMoveY = TRUE Then
        This.ctlVVAlue = m.lnVSValue
    Endif

    If m.llMoveX = TRUE Or m.llMoveY = TRUE Then

        *!* From now on, experimental mode on
        If Pemstatus(m.loOriginalActiveControl , "SelectOnEntry", CON_PEMSTAT_DEFINED) Then
            If m.loOriginalActiveControl .SelectOnEntry = TRUE Then
                m.loOriginalActiveControl.SelStart = 0
                m.loOriginalActiveControl.SelLength = Len(Rtrim(Transform(m.loOriginalActiveControl.Value)))
                *!* This refresh is here to refresh container when the scrolltocontrol was
                *!* triggered by a mouse click, not by a TAB
                m.loControl.Refresh()
            Endif
        Endif
    Endif
Endif



ENDPROC
PROCEDURE _settheme
*!* Changed in version 3.1
*!* Sunken border was not showing in WIN2K, WIN98.

Local lnBorderStyle

*!* Update Width and Height of standard ScrollBars
This.nScrollHeight = Sysmetric(SYSMETRIC_HSCROLLBARHEIGHT)
This.nScrollWidth = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH)

*!* Set Theme of scrollbars controls:
If ctlIsThemeActive(This) Then
	apiSetWindowTheme(This.nHCtlHwnd, Null, Null)
	apiSetWindowTheme(This.nVCtlHwnd, Null, Null)
Else
	apiSetWindowTheme(This.nHCtlHwnd, Null, "")
	apiSetWindowTheme(This.nVCtlHwnd, Null, "")
Endif

*!* Send a color change message just in case:
apiSendMessage(This.nHCtlHwnd, WM_SYSCOLORCHANGE , 0, 0)
apiSendMessage(This.nVCtlHwnd, WM_SYSCOLORCHANGE , 0, 0)

*!* Save current borderstyle
m.lnBorderStyle = This.ctlBorderStyle

*!* We first set BorderStyle to 0 so control resizes to its full size
This.ctlBorderStyle = 0

*!* Now we set the container that acts as border to flat or sunken, depending on themes:
If ctlIsThemeActive(This) Then
	This.oCntBorder.SpecialEffect = CON_EFFECT_FLAT
	This.nBorderWidth = 1
Else
	This.oCntBorder.SpecialEffect = CON_EFFECT_SUNKEN
	This.nBorderWidth = 2
Endif

*!* Now we set it to it previous BorderStyle, so the control shrinks if needed to
*!* leave space for border
This.ctlBorderStyle = m.lnBorderStyle



ENDPROC
PROCEDURE _setzoomratios
This.aZoomLevel(1)  =  0.01
This.aZoomLevel(2)  =  0.02
This.aZoomLevel(3)  =  0.03
This.aZoomLevel(4)  =  0.04
This.aZoomLevel(5)  =  0.05
This.aZoomLevel(6)  =  0.06
This.aZoomLevel(7)  =  0.08
This.aZoomLevel(8)  =  0.10
This.aZoomLevel(9)  =  0.12
This.aZoomLevel(10) =  0.15
This.aZoomLevel(11) =  0.20
This.aZoomLevel(12) =  0.25
This.aZoomLevel(13) =  0.30
This.aZoomLevel(14) =  0.40
This.aZoomLevel(15) =  0.50
This.aZoomLevel(16) =  0.60
This.aZoomLevel(17) =  0.70
This.aZoomLevel(18) =  0.80
This.aZoomLevel(19) =  1.00
This.aZoomLevel(20) =  1.20
This.aZoomLevel(21) =  1.50
This.aZoomLevel(22) =  2.00
This.aZoomLevel(23) =  2.50
This.aZoomLevel(24) =  3.00
This.aZoomLevel(25) =  4.00
This.aZoomLevel(26) =  5.00
This.aZoomLevel(27) =  6.00
This.aZoomLevel(28) =  8.00
This.aZoomLevel(29) = 10.00
This.aZoomLevel(30) = 12.00
This.aZoomLevel(31) = 15.00
This.aZoomLevel(32) = 20.00
This.aZoomLevel(33) = 25.00
This.aZoomLevel(34) = 30.00
This.aZoomLevel(35) = 31.99999999999

ENDPROC
PROCEDURE _wm_event
*!* _wm_event

Lparameters nHWND As Integer, nMSG As Integer, nWPARAM As Integer, nLPARAM As Integer

Local lnResult As Number

Thisform._scontainerHwnd = m.nHWND
Thisform._scontainerWparam = m.nWPARAM
Thisform._scontainerLparam = m.nLPARAM
*!* Trigger method binded to this property:
Thisform._scontainerWM  = m.nMSG

m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.nHWND, m.nMSG, m.nWPARAM, m.nLPARAM)

Return m.lnResult

ENDPROC
PROCEDURE ctlautocenter_assign
Lparameters vNewVal

This.ctlAutoCenter = m.vNewVal

This._Resize()

ENDPROC
PROCEDURE ctlbackcolor_assign
Lparameters vNewVal

This.ctlBackColor = m.vNewVal

If This.ctlBackColor = -1 Then
    Thisform.AddObject("G8FAA4444E2DF43BEA972D4CF94950A8F", "Textbox")

    *!* Store standard textbox backcolor
    This.nDefaultBackColor = Thisform.G8FAA4444E2DF43BEA972D4CF94950A8F.BackColor

    Thisform.RemoveObject("G8FAA4444E2DF43BEA972D4CF94950A8F")
Endif

This.BackColor = Iif(This.ctlBackColor = -1, This.nDefaultBackColor, This.ctlBackColor)

*!* Set backcolor of border container
This.oCntBorder.BackColor = This.BackColor



ENDPROC
PROCEDURE ctlbackstyle_assign
Lparameters vNewVal

This.ctlBackStyle = m.vNewVal

This.BackStyle = m.vNewVal

*!* Set backstyle of border container
This.oCntBorder.BackStyle = This.ctlBackStyle



ENDPROC
PROCEDURE ctlbordercolor_assign
Lparameters vNewVal

*!* 20071107 changed hack to using uxtheme api

This.ctlBorderColor = m.vNewVal

*!* #define VSCLASS_EDIT Strconv("EDIT" + 0h00, 5)
*!*	enum EDITPARTS {
*!*		EP_EDITTEXT = 1,
*!*		EP_CARET = 2,
*!*		EP_BACKGROUND = 3,
*!*		EP_PASSWORD = 4,
*!*		EP_BACKGROUNDWITHBORDER = 5,
*!*		EP_EDITBORDER_NOSCROLL = 6,
*!*		EP_EDITBORDER_HSCROLL = 7,
*!*		EP_EDITBORDER_VSCROLL = 8,
*!*		EP_EDITBORDER_HVSCROLL = 9,
*!*	};
*!*	enum BACKGROUNDWITHBORDERSTATES {
*!*		EBWBS_NORMAL = 1,
*!*		EBWBS_HOT = 2,
*!*		EBWBS_DISABLED = 3,
*!*		EBWBS_FOCUSED = 4,
*!*	};
*!*

Local ;
	m.lnTheme, ;
	m.lnColor

m.lnColor = 0
If ctlIsThemeActive() Then
	m.lnTheme = apiOpenThemeData(0, VSCLASS_EDIT)
	If m.lnTheme <> 0 Then
		apiGetThemeColor(m.lnTheme, EP_BACKGROUNDWITHBORDER, EBWBS_NORMAL, TMT_BORDERCOLOR, @m.lnColor)
		apiCloseThemeData(m.lnTheme)
	Endif
Endif

This.nDefaultBorderColor = m.lnColor

This.oCntBorder.BorderColor = Iif(This.ctlBorderColor = -1, This.nDefaultBorderColor, This.ctlBorderColor)


ENDPROC
PROCEDURE ctlborderstyle_assign
Lparameters vNewVal

Local lnAnchor as Integer

This.ctlBorderStyle = m.vNewVal

*!* Resize control, add old border width, substract new border width
m.lnAnchor = This.Anchor
This.Anchor = 0

If This.nOldBorderStyle = 1 Then
	This.Top = This.Top       - This.nBorderWidth
	This.Left = This.Left     - This.nBorderWidth
	This.Width = This.Width   + This.nBorderWidth * 2
	This.Height = This.Height + This.nBorderWidth * 2
Endif

If This.ctlBorderStyle = 1 Then
	This.Top = This.Top       + This.nBorderWidth
	This.Left = This.Left     + This.nBorderWidth
	This.Width = This.Width   - This.nBorderWidth * 2
	This.Height = This.Height - This.nBorderWidth * 2
Endif

This.Anchor = m.lnAnchor

If This.ctlBorderStyle = 1 Then
	This.oCntBorder.BorderWidth = This.nBorderWidth
Else
	This.oCntBorder.BorderWidth = 0
Endif

This.nOldBorderStyle = This.ctlBorderStyle

ENDPROC
PROCEDURE ctldoscroll
*!*	0 Scroll Line up     SmallChange
*!*	1 Scroll Line down   SmallChange
*!*	2 Scroll Page up     LargeChange
*!*	3 Scroll Page down   LargeChange
*!*	6 Scroll Top
*!*	7 Scroll Bottom

*!*	10 Scroll Line left  SmallChange
*!*	11 Scroll Line right SmallChange
*!*	12 Scroll Page left  LargeChange
*!*	13 Scroll Page right LargeChange
*!*	16 Scroll Left
*!*	17 Scroll Right

Lparameters nDirection

Local ;
	m.lnHWND, ;
	m.lnMSG, ;
	m.lnWPARAM, ;
	m.lnLPARAM

Do Case
	Case m.nDirection = 0
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_LINELEFT
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 1
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_LINERIGHT
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 2
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_PAGELEFT
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 3
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_PAGERIGHT
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 6
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_TOP
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 7
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_BOTTOM
		m.lnMSG    = WM_VSCROLL

	Case m.nDirection = 10
		m.lnLPARAM = This.nHCtlHwnd
		m.lnWPARAM = SB_LINELEFT
		m.lnMSG    = WM_HSCROLL

	Case m.nDirection = 11
		m.lnLPARAM = This.nHCtlHwnd
		m.lnWPARAM = SB_LINERIGHT
		m.lnMSG    = WM_HSCROLL

	Case m.nDirection = 12
		m.lnLPARAM = This.nHCtlHwnd
		m.lnWPARAM = SB_PAGELEFT
		m.lnMSG    = WM_HSCROLL

	Case m.nDirection = 13
		m.lnLPARAM = This.nHCtlHwnd
		m.lnWPARAM = SB_PAGERIGHT
		m.lnMSG    = WM_HSCROLL

	Case m.nDirection = 16
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_LEFT
		m.lnMSG    = WM_HSCROLL

	Case m.nDirection = 17
		m.lnLPARAM = This.nVCtlHwnd
		m.lnWPARAM = SB_RIGHT
		m.lnMSG    = WM_HSCROLL
Endcase

This._Scroll(0, m.lnMSG, m.lnWPARAM, m.lnLPARAM)

ENDPROC
PROCEDURE ctlforcescrollbars_assign
Lparameters vNewVal

This.ctlForceScrollBars = m.vNewVal

This._Resize()

ENDPROC
PROCEDURE ctlhhwnd_access
RETURN This.nHCtlHwnd

ENDPROC
PROCEDURE ctlhhwnd_assign
LPARAMETERS vNewVal
Return
ENDPROC
PROCEDURE ctlhmax_access
Local ;
	lnMin As Number, ;
	lnMax As Number

m.lnMin = 0
m.lnMax = 0

apiGetScrollRange(This.nHCtlHwnd, SB_CTL, @ m.lnMin, @ m.lnMax)

Return m.lnMax - (This.Width - 1)

ENDPROC
PROCEDURE ctlhmax_assign
LPARAMETERS vNewVal

ENDPROC
PROCEDURE ctlhvalue_access
Return apiGetScrollPos(This.nHCtlHwnd, SB_CTL)

ENDPROC
PROCEDURE ctlhvalue_assign
Lparameters vNewVal

Local lnHWND, lnMSG, lnWPARAM, lnLPARAM

m.lnHWND   = 0
m.lnMSG    = WM_HSCROLL
m.lnWPARAM = ctlMakewParam(SB_THUMBPOSITION, Max(m.vNewVal, 0))
m.lnLPARAM = This.nHCtlHwnd

This._Scroll(m.lnHWND, m.lnMSG, m.lnWPARAM, m.lnLPARAM)

ENDPROC
PROCEDURE ctlrestoresize
*!* ctlRestoreSize()

Local lnAnchor As Integer

If This.ControlCount > 0 And This.Controls(1).BaseClass = "Image" And This.Controls(1).Stretch > 0 Then
	With This.Controls(1)
		m.lnAnchor = .Anchor
		.Anchor = 0
		.Width = This.nOriginalWidth
		.Height = This.nOriginalHeight
		.Anchor = m.lnAnchor
		This.nZoomIndex = This.nDefaultZoomIndex
		This._Resize()
		*!* This part looks really complex, we need to scroll so what was in the middle
		*!* of the viewport stays in the middle. UNSOLVED YET!
		If This.ctlVEnabled Then
			This.ctlVVAlue = 0
		Endif
		If This.ctlHEnabled Then
			This.ctlHValue = 0
		Endif
	Endwith
	This.ctlZoom = 100
Endif

ENDPROC
PROCEDURE ctlscrollbars_assign
LPARAMETERS vNewVal

THIS.ctlScrollBars = m.vNewVal

This._Resize()


ENDPROC
PROCEDURE ctlscrolled
Lparameters nDirection

ENDPROC
PROCEDURE ctlvhwnd_access
RETURN This.nVCtlHwnd

ENDPROC
PROCEDURE ctlvmax_access
Local ;
	lnMin As Number, ;
	lnMax As Number

m.lnMin = 0
m.lnMax = 0

apiGetScrollRange(This.nVCtlHwnd, SB_CTL, @ m.lnMin, @ m.lnMax)

Return m.lnMax - (This.Height - 1)

ENDPROC
PROCEDURE ctlvmax_assign
LPARAMETERS vNewVal

ENDPROC
PROCEDURE ctlvvalue_access
Return apiGetScrollPos(This.nVCtlHwnd, SB_CTL)

ENDPROC
PROCEDURE ctlvvalue_assign
Lparameters vNewVal

Local lnHWND, lnMSG, lnWPARAM, lnLPARAM

m.lnHWND   = 0
m.lnMSG    = WM_VSCROLL
m.lnWPARAM = ctlMakewParam(SB_THUMBPOSITION, Max(m.vNewVal, 0))
m.lnLPARAM = This.nVCtlHwnd

This._Scroll(m.lnHWND, m.lnMSG, m.lnWPARAM, m.lnLPARAM)

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
*_activateform 
*_addobjects 
*_addproperties 
*_bindevents 
*_bindmousewheel 
*_create 
*_eventformactivate 
*_eventformscontainerwm 
*_eventformthemes 
*_eventformvisible 
*_eventmoved 
*_eventnewobject 
*_eventpageactivate 
*_eventpagedeactivate 
*_eventpageframeactivepage 
*_eventresize 
*_eventscreenthemes 
*_objtoclient 
*_resize 
*_scroll 
*_scrolltocontrol 
*_settheme 
*_setzoomratios 
*_wm_event 
*ctlautocenter_assign 
*ctlbackcolor_assign 
*ctlbackstyle_assign 
*ctlbordercolor_assign 
*ctlborderstyle_assign 
*ctldoscroll Scrolls the control to simulate a user clicking the scroll bars.
*ctlforcescrollbars_assign 
*ctlhhwnd_access 
*ctlhhwnd_assign 
*ctlhmax_access 
*ctlhmax_assign 
*ctlhvalue_access 
*ctlhvalue_assign 
*ctlrestoresize 
*ctlscrollbars_assign 
*ctlscrolled Occurs when the horizontal or vertical scroll bars are clicked or dragged
*ctlvhwnd_access 
*ctlvhwnd_assign 
*ctlvmax_access 
*ctlvmax_assign 
*ctlvvalue_access 
*ctlvvalue_assign 
_memberdata XML Metadata for customizable properties
_windowprocedure
ctlabout Returns information about the class.
ctlactivescrollbars Specifies whether scrollbars are needed. It does not indicate if the scrollbars are visible. Can be used to control an optional scroll control. 0: none, 1: horizontal, 2: vertical, 3: both.
ctlallowdrag
ctlallowzoom
ctlautocenter Specifies whether the child control should be centered in the scrollable container when the scrollable container is bigger that the child control.
ctlautoscroll
ctlbackcolor
ctlbackstyle
ctlbordercolor
ctlborderstyle
ctlforcescrollbars Specifies whether scrollbars should be always visible. Visible scrollbars will be disabled when not needed.
ctlhenabled Specifies if the horizontal scrollbar is enabled or required.
ctlhhwnd Returns a handle to the horizontal scrollbar control window. 
ctlhlargechange Specifies the increment an horizontal scrollbar scrolls when you click on the scrollbar track.
ctlhmargin Specifies the horizontal margin to use when autoscrolling to the active control.
ctlhmax
ctlhsmallchange Specifies the horizontal scrolling increment for a form's horizontal scroll bar.
ctlhvalue Sets or returns the actual horizontalscroll value of the client control.
ctlhvisible Specifies if the horizontal scrollbar is visible.
ctlhwheelchange Specifies the increment an horizontal scrollbar scrolls when you use the mouse wheel.
ctlscrollbars Specifies the type of scroll bars a control has.
ctlthemes
ctlvenabled Specifies if the vertical scrollbar is enabled or required.
ctlversion
ctlvhwnd Returns a handle to the horizontal scrollbar control window. 
ctlvlargechange Specifies the increment a vertical scrollbar scrolls when you click on the scrollbar track.
ctlvmargin Specifies the vertical margin to use when autoscrolling to the active control.
ctlvmax
ctlvsmallchange Specifies the increment a vertical scrollbar scrolls when you click on a scroll arrow.
ctlvvalue Sets or returns the actual vertical scroll value of the client control.
ctlvvisible Specifies if the vertical scrollbar is visible.
ctlvwheelchange Specifies the increment a vertical scrollbar scrolls when you use the mouse wheel.
ctlzoom
[END RESERVED3]
[START RESERVED4]
ctl32_scontainer.bmp[END RESERVED4]
[START RESERVED5]
ctl32_scontainer.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1X30OTPZ5
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_scontainer
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_scontainer"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Height = 15
Left = 3
Name = "lblname"
Top = 3
Width = 81
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_scontainer

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2DD18X1VR
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_scrollbar
[START PROPERTIES]

Height = 18
Name = "ctl32_scrollbar"
Width = 240
_memberdata =      191<VFPData><memberdata name="ctlfontname_access" type="method" display="ctlfontname_Access"/><memberdata name="ctllargechange_assign" type="method" display="ctllargechange_Assign"/></VFPData>
ctlTextBox.Name = "ctlTextBox"
ctllargechange = 10
ctlmaximum = 100
ctlminimum = 0
ctlsmallchange = 1
lblname.Caption = "ctl32_scrollbar"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE _bindevents
*!* _BindEvents()

DoDefault()

Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, This, "_OnWindowMessage", 4)
Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, This, "_OnWindowMessage", 4)

ENDPROC
PROCEDURE _getdwstyle
*!* _GetdwStyle()

Local dwStyle As Integer

m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS)

*!* Orientation
If This.ctlOrientation = 0  Then
	m.dwStyle = Bitor(m.dwStyle, SBS_HORZ)
Else
	m.dwStyle = Bitor(m.dwStyle, SBS_VERT)
Endif

Return m.dwStyle

ENDPROC
PROCEDURE _getlpclassname
*!* _GetlpClassName()

Return WC_SCROLLBARA

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

DoDefault()

Local ;
	m.lnValue As Integer, ;
	m.lnRequest As Integer

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_HSCROLL Or Thisform._2ce01ty4y_Msg = WM_VSCROLL

		If Thisform._2ce01ty4y_lParam = This._ControlHwnd Then

			m.lnValue = apiGetScrollPos(This._ControlHwnd, SB_CTL)
			m.lnRequest  = ctlLoWord(Thisform._2ce01ty4y_wParam)

			Do Case

				Case m.lnRequest = SB_ENDSCROLL		&& 8
					Return && We dont need to do anything else

				Case m.lnRequest = SB_THUMBPOSITION	&& 4
					m.lnValue = ctlHiWord(Thisform._2ce01ty4y_wParam)

				Case m.lnRequest = SB_THUMBTRACK	&& 5
					m.lnValue = ctlHiWord(Thisform._2ce01ty4y_wParam)

				Case m.lnRequest = SB_LINELEFT		&& 0 SB_LINEUP
					m.lnValue = m.lnValue - This.ctlSmallChange

				Case m.lnRequest = SB_LINERIGHT		&& 1 SB_LINEDOWN
					m.lnValue = m.lnValue + This.ctlSmallChange

				Case m.lnRequest = SB_PAGELEFT		&& 2 SB_PAGEUP
					m.lnValue = m.lnValue - This.ctlLargeChange

				Case m.lnRequest = SB_PAGERIGHT		&& 3 SB_PAGEDOWN
					m.lnValue = m.lnValue + This.ctlLargeChange

				Case m.lnRequest = SB_LEFT			&& 6 SB_TOP
					m.lnValue = This.ctlMinimum

				Case m.lnRequest = SB_RIGHT			&& 7 SB_BOTTOM
					m.lnValue = This.ctlMaximum
			Endcase

			This.ctlValue = m.lnValue
		Endif

Endcase

ENDPROC
PROCEDURE _postcreate
This._SetMaximum()
This._SetLargeChange()
This._SetAutoSize()
This._OnResize()

ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

Local lnAnchor As Integer

m.lnAnchor = This.Anchor

This.Anchor = 0

If This.ctlAutoSize = TRUE Then

	*!* Save previous dimensions
	This._DefaultHeight = This.Height
	This._DefaultWidth = This.Width

	If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		This.Width = This.ctlDefaultWidth
	Else
		This.Height = This.ctlDefaultHeight
	Endif

Else

	If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		This.Width = This._DefaultWidth
	Else
		This.Height = This._DefaultHeight
	Endif

Endif

This.Anchor = m.lnAnchor

ENDPROC
PROCEDURE _setbackcolor
*!* _SetBackColor()

This._CreateBackGroundBrush()
This.ctlRefresh()

ENDPROC
PROCEDURE _setlargechange
*!* _SetLargeChange()

If This._ControlHwnd = 0
	Return
Endif

Local ;
	loScrollInfo As ctlScrollInfo, ;
	lcScrollInfo As String

m.loScrollInfo = Createobject("ctlScrollInfo")

m.loScrollInfo.fMask     = Bitor(SIF_PAGE, 0)
m.loScrollInfo.nMin      = 0
m.loScrollInfo.nMax      = 0
m.loScrollInfo.nPage     = This.ctlLargeChange
m.loScrollInfo.nPos      = 0
m.loScrollInfo.nTrackPos = 0
m.lcScrollInfo = m.loScrollInfo.Value
m.loScrollInfo = .Null.

apiSetScrollInfo(This._ControlHwnd, SB_CTL, @m.lcScrollInfo, 1)
ENDPROC
PROCEDURE _setmaximum
*!* _SetMaximum()

If This._ControlHwnd = 0
	Return
Endif

Local ;
	loScrollInfo As ctlScrollInfo, ;
	lcScrollInfo As String

m.loScrollInfo = Createobject("ctlScrollInfo")

m.loScrollInfo.fMask     = Bitor(SIF_RANGE, 0)
m.loScrollInfo.nMin      = This.ctlMinimum
m.loScrollInfo.nMax      = This.ctlMaximum
m.loScrollInfo.nPage     = 0
m.loScrollInfo.nPos      = 0
m.loScrollInfo.nTrackPos = 0
m.lcScrollInfo = m.loScrollInfo.Value
m.loScrollInfo = .Null.

apiSetScrollInfo(This._ControlHwnd, SB_CTL, @m.lcScrollInfo, 1)


ENDPROC
PROCEDURE _setminimum
*!* _SetMinimum()

If This._ControlHwnd = 0
	Return
Endif

Local ;
	loScrollInfo As ctlScrollInfo, ;
	lcScrollInfo As String

m.loScrollInfo = Createobject("ctlScrollInfo")

m.loScrollInfo.fMask     = Bitor(SIF_RANGE, 0)
m.loScrollInfo.nMin      = This.ctlMinimum
m.loScrollInfo.nMax      = This.ctlMaximum
m.loScrollInfo.nPage     = 0
m.loScrollInfo.nPos      = 0
m.loScrollInfo.nTrackPos = 0
m.lcScrollInfo = m.loScrollInfo.Value
m.loScrollInfo = .Null.

apiSetScrollInfo(This._ControlHwnd, SB_CTL, @m.lcScrollInfo, 1)


ENDPROC
PROCEDURE _setorientation
*!* _SetOrientation()

Local ;
	lnAnchor As Integer, ;
	lnWidth As Integer, ;
	llVisible As Boolean

If This._ControlHwnd = 0 Then
	Return
Endif

m.lnAnchor = This.Anchor
m.lnWidth = This.Width
m.llVisible = This.ctlVisible

This.ctlVisible = FALSE
This.Anchor = 0

This.Width = This.Height
This.Height = m.lnWidth

*!* ctlVertical change needs to recreate Control
This._Create()

This.Anchor = m.lnAnchor
This.ctlVisible = m.llVisible

ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

DoDefault()

If This._ControlHwnd = 0
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

Local ;
	loScrollInfo As ctlScrollInfo, ;
	lcScrollInfo As String

m.loScrollInfo = Createobject("ctlScrollInfo")

m.loScrollInfo.fMask     = SIF_POS
m.loScrollInfo.nMin      = 0
m.loScrollInfo.nMax      = 0
m.loScrollInfo.nPage     = 0
m.loScrollInfo.nPos      = This.ctlValue
m.loScrollInfo.nTrackPos = 0

m.lcScrollInfo = m.loScrollInfo.Value

apiSetScrollInfo(This._ControlHwnd, SB_CTL, @m.lcScrollInfo, 1)

m.loScrollInfo = .Null.

ENDPROC
PROCEDURE ctldefaultheight_access
*!* ctlDefaultHeight_Access()

Local ;
	lnHeight As Integer

If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
	m.lnHeight = SYSMETRIC(8)
Else
	m.lnHeight = This.Height
Endif

Return m.lnHeight

ENDPROC
PROCEDURE ctldefaultwidth_access
*!* ctlDefaultWidth_Access()

Local ;
	lnWidth As Integer

If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
	m.lnWidth = This.Width
Else
	m.lnWidth = Sysmetric(5)
Endif

Return m.lnWidth

ENDPROC
PROCEDURE ctllargechange_assign
lparameters tuNewValue

If This.ctlLargeChange # m.tuNewValue Then
	This.ctlLargeChange = m.tuNewValue
	This._SetLargeChange()
Endif


ENDPROC
PROCEDURE ctlmaximum_assign
*!* ctlMaximum_Assign()

Lparameters m.tuNewValue

If This.ctlMaximum # m.tuNewValue Then
	This.ctlMaximum = m.tuNewValue
	This._SetMaximum()
Endif

ENDPROC
PROCEDURE ctlminimum_assign
*!* ctlMinimum_Assign()

Lparameters m.tuNewValue

If This.ctlMinimum # m.tuNewValue Then
	This.ctlMinimum = m.tuNewValue
	This._SetMinimum()
Endif

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_setlargechange 
*_setmaximum 
*_setminimum 
*ctllargechange_assign 
*ctlmaximum_assign 
*ctlminimum_assign 
ctllargechange Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
ctlmaximum Gets or sets the upper limit of values of the scrollable range.
ctlminimum Gets or sets the lower limit of values of the scrollable range.
ctlsmallchange Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
[END RESERVED3]
[START RESERVED4]
ctl32_scrollbar.bmp[END RESERVED4]
[START RESERVED5]
ctl32_scrollbar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_scrollbar
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CX17PCHY
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_sizebox
[START PROPERTIES]
Height = 24
Name = "ctl32_sizebox"
Width = 78
_visible = .F.
ctlTextBox.Name = "ctlTextBox"
ctlbackstyle = 0
lblname.Caption = "ctl32_sizebox"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE _bindevents
*!* _BindEvents()

DoDefault()

Bindevent(This.ctlHostFormhWnd, WM_CTLCOLORSTATIC, This, "_OnWindowMessage", 4)

ENDPROC
PROCEDURE _getdwstyle
Return Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, SBS_SIZEGRIP, SBS_SIZEBOXBOTTOMRIGHTALIGN)
ENDPROC
PROCEDURE _getlpclassname
Return WC_SCROLLBARA

ENDPROC
PROCEDURE _precreate
*!* _PreCreate()

This._SetAutoSize()


ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

This.Anchor = 0

This.Width = Sysmetric(5)
This.Height = Sysmetric(6)

This.Top = This.Parent.Height - This.Height
This.Left = This.Parent.Width - This.Width

This.Anchor = 12

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_sizebox
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1NS0MG7JU
[CLASS] container
[BASECLASS] container
[OBJNAME] ctl32_statusbar
[START PROPERTIES]

BackColor = 140,200,200
BorderWidth = 1
ForeColor = 0,0,0
Height = 24
Name = "ctl32_statusbar"
Width = 360
_height = 24
_memberdata =      145<VFPData><memberdata name="hwnd" type="property" display="HWnd"/><memberdata name="hwnd_access" type="method" display="HWnd_Access"/></VFPData>
_width = 0
builderx = (home() + "wizards\ctl32_statusbar_builder.app")
ctlabout = ctl32_statusbar - Carlos Alloatti.
ctlcaption = 
ctlhwnd = 0
ctlicon = 
ctllangid = 0
ctlmessage = 
ctlpanelcount = 5
ctlsizegrip = .T.
ctlthemes = .T.
ctlupdatestyle = 1
ctlversion = 20070711
hwnd = 
nbutton = 0
npanel = 0
nxcoord = 0
nycoord = 0
showprogressbarcaption = .F.
[END PROPERTIES]
[START PROTECTED]
_addpanels^
_addprogressbar^
_addproperties^
_adjustprogressbar^
_bindevents^
_create^
_declaredlls^
_destroy^
_eventhandlerformactivate^
_eventhandlerformdestroybefore^
_eventhandlerformresize^
_getborder^
_messagehandlerglobalproxy^
_messagehandlerproxywindowwm_notify^
_messagehandlerscreenwm_size^
_messagehandlervfpwm_enteridle^
_messagehandlervfpwm_themechanged^
_panelborders^
_panels^
_propertyhandlerformthemes^
_propertyhandlerformvisible^
_propertyhandlerprogressbarctlvisible^
_propertyhandlerprogressbarwidth^
_propertyhandlerscreenthemes^
_resize^
_resizepanels^
_setlocalestrings^
_settheme^
_width^
_width_access^
ctlhwnd_access^
ctlicon_assign^
ctllangid_assign^
ctlmessage_assign^
ctlthemes_assign^
ctlupdatestyle_assign^
showprogressbarcaption_assign^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
*!* 2006-06-27 Swaped order of this method calls
This._destroy()


ENDPROC
PROCEDURE Init
*!* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/status/status.asp

*!*	ctl32_StatusBar
*!*	Created by Carlos Alloatti - calloatti@gmail.com

Lparameters tnPanelCount

External Procedure ctl32.prg
Do (Addbs(Justpath(This.ClassLibrary)) + "ctl32.prg")

*!* Check if a numeric parameter was received, that should be PanelCount
If Pcount() > 0 And Vartype(m.tnPanelCount) = "N" Then
    This.ctlPanelCount = m.tnPanelCount
Endif

*!* 2006-06-27 Added Version(2) checking
If Type("ThisForm") <> T_OBJECT And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME Then
    Messagebox("Container has to be a Form Object", 16, This.Class)
    Return
Endif

If This.Parent.BaseClass <> "Form"  And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME Then
    Messagebox("Container has to be a Form Object", 16, This.Class)
    Return
Endif

This._AddObjects()
This._AddProperties()

*!*	Set up some properties
This.Visible = FALSE
*!* Comented on 2006-05-07 // Giancarlo Piccinato // *!* .Anchor = 0
This.Top = 0 &&-100
This.Left = 0

*!* 20070711 next two lines commented
*!* This.Width = Thisform.Width
*!* This.Height = This._Height

This._AddProgressBar()

*!* Add Panel objects:
This._AddPanels()

*!* To create the StatusBar in a TLF, we should wait until the Form is visible or make it visible,
*!* so we can add the bottom toolbar that will create a window placeholder for
*!* the StatusBar. To do that, the TLF Activate event is binded to _EventHandlerFormActivate
*!* In the first Form.Activate event, this delegate code will be called, it will call _Create
*!* and then Unbind itself.This way, we do not disturb the order of form events when form loads

If This._FormType  = CON_FORMTYPE_TOPLEVEL
    Bindevent(Thisform, "Activate", This, "_EventHandlerFormActivate", 1)
Else
    This._Create()
    This.ctlInit()
Endif



ENDPROC
PROCEDURE _addobjects
*!* _AddObjects()

*!* Define Rect Object to be used by various methods
This.AddProperty("oRect", Createobject("ctlRECT"))

This.addobject("tmrUpdater", "ctl32_statusbar_timer")


ENDPROC
PROCEDURE _addpanels
*!* _AddPanels()

*!*	StatusBar Panel  0 is the Message Panel
*!*	StatusBar Panel  1 is the ProgressBar Panel
*!*	StatusBar Panel  2 is Custom Panel 1
*!*	StatusBar Panel  3 is Custom Panel 2
*!* ...
*!*	StatusBar Panel  n is Custom Panel n -1
*!*	StatusBar Panel  .ctlPanelCount + 5 is PanelOvr
*!*	StatusBar Panel  6 is PanelNum
*!*	StatusBar Panel  7 is PanelCaps
*!*	StatusBar Panel  8 is PanelDate
*!*	StatusBar Panel  9 is Last Panel for sizing

*!* This.ctlPanels(1) = Panel1 -> StatusBar Panel 2 (index 0 based in windows statusbar control)
*!* This.ctlPanels(2) = Panel2 -> StatusBar Panel 3 (index 0 based)
*!* This.ctlPanels(3) = Panel3 -> StatusBar Panel 4 (index 0 based)

Local ;
	lnx As Number, ;
	lnTotPanelCount As Number

m.lnTotPanelCount = This.ctlPanelCount + This.nStdPanelCount

*!* Resize array properties to hold references to all Panel objects
Dimension This._Panels(m.lnTotPanelCount)
Dimension This.ctlPanels(This.ctlPanelCount)

*!* Store defined names of Panels in this array
Local Array laPanelNames(m.lnTotPanelCount)

m.laPanelNames(1)  = "PanelMessage"
m.laPanelNames(2)  = "PanelProgressBar"

*!* create custom panel names: "Panelx"
*!* 2006-06-27 Changed to ALLTRIM(STR //Doru Constantin//
For m.lnx = This.nStdPanelCountLeft + 1 To This.nStdPanelCountLeft + This.ctlPanelCount
	m.laPanelNames(m.lnx) = "Panel" + Alltrim(Str(m.lnx - This.nStdPanelCountLeft))
Endfor

m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 1) = "PanelOvr"
m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 2) = "PanelNum"
m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 3) = "PanelCaps"
m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 4) = "PanelDate"
m.laPanelNames(This.nStdPanelCountLeft + This.ctlPanelCount + 5) = "PanelLast"

*!* Create left Panels
For m.lnx = 1 To This.nStdPanelCountLeft
	This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
	This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
	This._Panels(m.lnx).ctlIndex = m.lnx - 1		&& Compensate for 0 based index
Endfor

*!* set this so alignment works in this Panel
This.PanelMessage.ctlAutosize = FALSE

*!* Create custom Panels
For m.lnx = This.nStdPanelCountLeft + 1 To This.nStdPanelCountLeft + This.ctlPanelCount
	This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
	This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
	This._Panels(m.lnx).ctlIndex = m.lnx - 1
	This.ctlPanels(m.lnx - 2) = This._Panels(m.lnx)
Endfor

*!* Create right Panels
For m.lnx =   This.nStdPanelCountLeft + This.ctlPanelCount + 1 To m.lnTotPanelCount
	This.Addobject(m.laPanelNames(m.lnx), "ctl32_StatusBar_Panel")
	This._Panels(m.lnx) = Evaluate("This." + m.laPanelNames(m.lnx))
	This._Panels(m.lnx).ctlIndex = m.lnx - 1
Endfor




ENDPROC
PROCEDURE _addprogressbar
*!* _AddProgressBar()

*!* Add progressbar object, pass -1 as parameter to prevent init code from progressbar to run
This.Newobject("ProgressBar","ctl32_progressbar", This.ClassLibrary, "", TRUE)

This.ProgressBar.Width = 93
This.ProgressBar.ctlMaximum = 100
This.ProgressBar.Height = 17
This.ProgressBar.ctlSizeAdjust = TRUE
This.ProgressBar.ctlStyle = 2
This.ProgressBar.ctlSmooth = TRUE
This.ProgressBar.ctlBarcolor = -1
*This.ProgressBar.ctlFormat = "<<ValueP>>"
This.ProgressBar.ctlVisible = FALSE
This.ProgressBar.ctlStep = 5
ENDPROC
PROCEDURE _addproperties
This.AddProperty("nStdPanelCountLeft", 2)
This.AddProperty("nStdPanelCountRight", 5)
This.AddProperty("nStdPanelCount", This.nStdPanelCountLeft + This.nStdPanelCountRight)

This.AddProperty("_OldWidth", 0)

*!* Stores the HWnd of the host window
This.AddProperty("_HostHWnd", 0)

*!* Stores the value of VFP window procedure
This.AddProperty("_WindowProcedure", ctlGetWindowProcedure(ThisForm.Hwnd))

*!* Stores HWnd of Windows common control created by the class
This.AddProperty("_ControlHwnd", 0)

*!* Stores old date value to update PanelDate
This.AddProperty("_OldDate", Dtos(Date(1900, 1, 1)))

*!* Stores HWnd of Windows common control created by the class
This.AddProperty("_ProxyHWnd", 0)

*!* Indicates if the control is in the creation stage
This.AddProperty("_Creating", FALSE)

*!* Stores form type: standard, top level form, _screen
This.AddProperty("_FormType", ctlGetFormType(This))

*!* Stores status of keys:
This.AddProperty("_OldCAPS", Not Capslock())
This.AddProperty("_OldNUM", Not Numlock())
This.AddProperty("_OldOVR", Not Insmode())
This.AddProperty("_oldMessage", "")

*!* Indicates if last mouse event was a double click:
This.AddProperty("_DoubleClick", 0)

*!* _Height property added to class
*!* Indicates Height of status bar
*!* This.AddProperty("_Height", 24)

*!* Stores HWnd of native VFP status bar
This.AddProperty("_VFPStatusBarHWnd", 0)

*!* Stores old Window state
This.AddProperty("_OldWindowState", -1)


ENDPROC
PROCEDURE _adjustprogressbar
*!* _AdjustProgressBar()

Local ;
	lcRect as String, ;
    lnTop As Number, ;
    lnBottom As Number, ;
    lnTopMargin As Number, ;
    lnBottomMargin As Number, ;
	lnColorBtnFace As Number

*!* Set ProgressBar Top and Height, get Height of StatusBar window
*!* 2006-06-27 Changed to use structs class
m.lcRect = This.oRect.Value
apiGetClientRect(This._ControlHwnd, @m.lcRect)
This.oRect.Value = m.lcRect

m.lnTop    = This.oRect.Top
m.lnBottom = This.oRect.Bottom

*!* Just in case we need to make adjustments to this values later
If ctlIsThemeActive(This) = TRUE Then
    m.lnTopMargin    = This._GetBorder(CON_SBBORDER_VERTICAL) + 3
    m.lnBottomMargin = This._GetBorder(CON_SBBORDER_VERTICAL) + 1
Else
    m.lnTopMargin    = This._GetBorder(CON_SBBORDER_VERTICAL) + 2
    m.lnBottomMargin = This._GetBorder(CON_SBBORDER_VERTICAL)
Endif

This.ProgressBar.Top = m.lnTop + m.lnTopMargin
This.ProgressBar.Height =  m.lnBottom - m.lnTop - m.lnTopMargin - m.lnBottomMargin

*!* Send color update message to correct bugs with theme changes
If This.ProgressBar.ctlHWnd > 0 Then
    apiSendMessage(This.ProgressBar.ctlHWnd, WM_SYSCOLORCHANGE , 0, 0)
    m.lnColorBtnFace = apiGetSysColor(COLOR_BTNFACE)
    apiSendMessage(This.ProgressBar.ctlHWnd, PBM_SETBKCOLOR, 0, m.lnColorBtnFace)
Endif


ENDPROC
PROCEDURE _bindevents
*!* _BindEvents()

*!* http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_foxhelp9/html/f988d7c6-f382-40dd-a51a-b5ab73eb08c7.asp

*!* Windows Theme change WM_THEMECHANGED
*!* statusbar in screen, no bottom toolbar docked: handled by Resize event in _Resize
*!* statusbar in screen, bottom toolbar docked: Bind WM_THEMECHANGED
*!* statusbar in form or tlf: Bind WM_THEMECHANGED, to fix colors

*!* _Screen.Themes Change
*!* statusbar in screen, no bottom toolbar docked: handled by Resize event in _Resize
*!* statusbar in screen, bottom toolbar docked: Bind _Screen.Themes to _SetTheme
*!* statusbar in form or tlf, Bind _Screen.Themes to _SetTheme

*!* Form.Themes Change
*!* statusbar in screen, nothing to do
*!* statusbar in form or tlf: Bind Form.Themes to _SetTheme


If ctlGetOsVersion() >= NTDDI_WINXP And Version(CON_VER_NUM) >= 900 Then
	Bindevent(_vfp.HWnd, WM_THEMECHANGED, This, "_MessageHandlerVfpWM_THEMECHANGED", 5)
Endif

Bindevent(_Screen, "Themes", This, "_PropertyHandlerScreenThemes", 1)

If This._FormType <> CON_FORMTYPE_SCREEN
	Bindevent(Thisform, "Themes", This, "_PropertyHandlerFormThemes", 1)
Endif

*!* Check for undocking of bottom toolbars, _Screen.Resize event does not fire
*!* when toolbar docked at bottom of screen is undocked.
If This._FormType  = CON_FORMTYPE_SCREEN Then
	Bindevent(This._HostHWnd, WM_SIZE, This, "_MessageHandlerScreenWM_SIZE", 5)
Endif

*!* Monitor _Screen or Form resizes
Bindevent(Thisform, "Resize", This, "_EventHandlerFormResize", 1)

Bindevent(This._ProxyHWnd, WM_NOTIFY, This, "_MessageHandlerProxyWindowWM_NOTIFY", 5)

*!* When ProgressBar Visible or Width changes, we should resize panels
Bindevent(This.ProgressBar, "ctlVisible", This, "_PropertyHandlerProgressBarctlVisible", 1)
Bindevent(This.ProgressBar, "Width",   This, "_PropertyHandlerProgressBarWidth", 1)

*!* If we are in a TLF, we are responsible for releasing the toolbar we added (are we?)
If This._FormType = CON_FORMTYPE_DEFAULT Then
	Bindevent(Thisform, "Destroy", This, "_EventHandlerFormDestroyBefore", 0)
Endif

*!* When host is a Standard Form and the form is resized in its Init event,
*!* the Resize event of the form does not fire, so we bind to Visible
*!* property of the form to cover all the bases like:
*!* Do Form xxx Noshow
*!* 2006-06-27 //Andrew Nickless//
*!* Also when resizing screen while it is not visible
*!* 2006-12-14 //danelliott//

Bindevent(Thisform, "Visible", This, "_PropertyHandlerFormVisible", 1)


ENDPROC
PROCEDURE _create
*!* Prevent recursive calling?
If This._Creating = TRUE Then
    Return
Endif

Local ;
	lnx As Number, ;
    lnSize As Number, ;
    lcClass As String

*!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
Local ;
    dwExStyle As Integer, ;
    lpClassName As String, ;
    lpWindowName As String, ;
    dwStyle As Integer, ;
    hMenu As Integer, ;
    hInstance As Integer, ;
    lpParam As Integer

*!* We enter Initialization Stage
This._Creating = TRUE

*m.llOldLockScreen = Thisform.LockScreen

*!*	Lock Form/Screen updates until we are done:
*!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
*apiSendMessage(_vfp.HWnd, WM_SETREDRAW, 0, 0)

*!*	If This._FormType  = CON_FORMTYPE_SCREEN Then
*!*	    LockWindowUpdate(_vfp.HWnd)
*!*	Else
*!*	    Thisform.LockScreen = TRUE
*!*	Endif

*!* We need the native Status Bar visible, otherwise _vfp.StatusBar gives us nothing!
If Set("Status Bar") = "OFF" Then
    Set Status Bar On
Endif

*!* When StatusBar is contained in a TLF or _Screen, we need a proxy window
If This._FormType  <> CON_FORMTYPE_DEFAULT && TLF or Screen

    *!* prepare to add aux toolbar, that creates the required bottom window to hold proxy window
    *!* in a TLF, and gives us a way to get the HWnd of the host window
    If Not Pemstatus(Thisform, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
        Thisform.AddProperty("StatusBar_ToolBar")
    Else
        Thisform.StatusBar_ToolBar = Null
    Endif

    *!*	add auxiliary toolbar, this toolbar docks itself to bottom of Form/Screen
    *!* If in _Screen we just use it to get HWnd of Host window
    Thisform.StatusBar_ToolBar = Createobject("ctl32_StatusBar_ToolBar")

    *!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
    *!*	Setup parameters for proxy window:
    m.dwExStyle = Bitor(WS_EX_NOPARENTNOTIFY, WS_EX_TOPMOST)
    m.lpWindowName = "StatusBar_proxy_window" + Sys(2015)
    m.dwStyle = Bitor(WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS, WS_CLIPCHILDREN)
    This._HostHWnd = apiGetParent(Thisform.StatusBar_ToolBar.HWnd)	&& Neat Trick!

    m.hMenu = 0
    m.hInstance = 0
    m.lpParam = 0

    *!* Find class name to use for proxy window from host VFP window (www.news2news.com)
    m.lcClass = Space(254)
    m.lnSize = apiRealGetWindowClass (This._HostHWnd, @m.lcClass , Len(m.lcClass))
    m.lcClass = Left(m.lcClass, m.lnSize)
    m.lpClassName = m.lcClass

    *!*	If statusbar is on screen, remove auxiliary ToolBar, VFP native StatusBar keeps host window alive
    *!* Also, if left, it makes the bottom window taller. We dont want that.
    *!* In a TLF, we need this ToolBar to keep host window alive. Added bonus: maximized child Forms
    *!* dont overlap StatusBar
    If This._FormType  = CON_FORMTYPE_SCREEN Then
        *!* 20080425 commented .http://www.foxite.com/archives/0000169202.htm
        *!* Thisform.StatusBar_ToolBar.Dock(TOOL_NOTDOCKED)
        Thisform.StatusBar_ToolBar = Null
    Endif

    *!* Now that aux toolbar is out of the way, get HWnd of native statusbar to hide it
    *!* if we are on _Screen

    *!* 20070711 Modified to prevent bug where native VFP status bar pops up when
    *!* clicking on ctl32_statusbar after poping up a context menu on a form
    *!* reported by Bentam

    If This._FormType  = CON_FORMTYPE_SCREEN
        This._VFPStatusBarHWnd = apiGetWindow(This._HostHWnd, GW_CHILD)
        *!* By using a timer, we give VFP some time to "stabilize" after a theme change
        *!* The timer procedure hides the native vfp status bar
        This.tmrHideVFPStatusBar.Reset()
        This.tmrHideVFPStatusBar.Enabled = TRUE

    Endif

    *!*	CREATE proxy window now:
    This._ProxyHWnd = apiCreateWindowEx( ;
        m.dwExStyle, ;
        m.lpClassName, ;
        m.lpWindowName, ;
        m.dwStyle, ;
        0, ;
        0, ;
        This._Width, ;
        This._Height,;
        This._HostHWnd,;
        m.hMenu, ;
        m.hInstance, ;
        m.lpParam)

    *!* Only for debugging purposes
    If This._ProxyHWnd = 0 And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME

        *!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
        *apiSendMessage(_vfp.HWnd, WM_SETREDRAW, 1, 0)
        *!* LockWindowUpdate(0)

        *Thisform.LockScreen = m.llOldLockScreen
        Messagebox("Error Creating window " + m.lpClassName, 0 + 16)
    Endif

    *!* When StatusBar is contained in a standard Form, there is no need for a proxy window
Else
    This._HostHWnd =  Thisform.HWnd
    This._ProxyHWnd = Thisform.HWnd
Endif

*!* setup parameters for StatusBar control window:
m.dwExStyle =  0
m.lpClassName = STATUSCLASSNAMEA
m.lpWindowName = m.lpClassName + Sys(2015)
m.dwStyle = Bitor(WS_CHILD, WS_VISIBLE, WS_CLIPSIBLINGS, SBARS_TOOLTIPS, CCS_BOTTOM)

*!* 20070711 changed code, always set sizegrip for screen, show or hide in resize

If This.ctlSizeGrip = TRUE  Then
    m.dwStyle = Bitor(m.dwStyle, SBARS_SIZEGRIP)
Endif

If This._FormType  = CON_FORMTYPE_SCREEN Then
    m.dwStyle = Bitor(m.dwStyle, SBARS_SIZEGRIP)
Endif

m.hMenu = 0
m.hInstance = 0
m.lpParam = 0

*!* 2006-06-27 Removed window creation parameters as class properties and set them as local vars
*!*	Create StatusBar control window:
This._ControlHwnd = apiCreateWindowEx( ;
    m.dwExStyle, ;
    m.lpClassName, ;
    m.lpWindowName, ;
    m.dwStyle, ;
    0, ;
    0, ;
    0, ;
    0, ;
    This._ProxyHWnd, ;
    m.hMenu, ;
    m.hInstance, ;
    m.lpParam)

*!* Only for debugging purposes
If This._ControlHwnd = 0 And Version(CON_VER_TYPE) <> CON_VER_TYPE_RUNTIME

    *!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
    *apiSendMessage(_vfp.HWnd, WM_SETREDRAW, 0, 0)
    *!* LockWindowUpdate(0)

    *Thisform.LockScreen = FALSE
    Messagebox("Error Creating window " + m.lpClassName, 0 + 16)
Endif

*!* Send various messages to StatusBar:

*!* Set simple to FALSE:
apiSendMessage(This._ControlHwnd, SB_SIMPLE , 0, 0)

*!* Set minimum Height:
apiSendMessage(This._ControlHwnd, SB_SETMINHEIGHT, 22, 0)

*!* Set locale strings for OVR, NUM, CAPS
This._SetLocaleStrings()

*!* Todo, refresh Panels captions and icons just in case we are recreating StatusBar
*!* after an OS Theme change
For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
    This._Panels(m.lnx)._UpdateAll()
Endfor

*!* We finish Initialization State
This._Creating = FALSE

This.ProgressBar.ctlHostHwnd = This._ControlHwnd
This.ProgressBar.ctlCreateControl()
*!* Set Height and Vertical position of ProgressBar
This._AdjustProgressBar()

*!* This has to be done here to update panels:
This._Resize()

*!* Set colors of statusbar, it fails to set right by itself,
*!* sometimes,  when XP theme changed to classic
If ctlGetOsVersion() >= NTDDI_WINXP && And isThemeActive() = 0 Then
    apiSendMessage(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)
Endif

*!* Send Theme message to control:
This._SetTheme()

*!* 2006-06-27 Moved this before ctl32_BindEvents

*!* Unlock Form/Screen updates:
*!* 2007-03-17: http://blogs.msdn.com/oldnewthing/archive/2007/02/22/1742084.aspx
*apiSendMessage(_vfp.HWnd, WM_SETREDRAW, 1, 0)
*!* LockWindowUpdate(0)

*Thisform.LockScreen = m.llOldLockScreen

*!* Now we bind to various events:
This._BindEvents()

*!* Enable updates of panels:
This.ctlUpdateStyle = This.ctlUpdateStyle




ENDPROC
PROCEDURE _declaredlls




ENDPROC
PROCEDURE _destroy

*!* Destroy StatusBar window
If This._ControlHwnd > 0 Then
    apiDestroyWindow(This._ControlHwnd)
Endif

*!* Destroy StatusBar proxy window
If This._ProxyHWnd > 0 Then
    apiDestroyWindow(This._ProxyHWnd)
Endif

This._ProxyHWnd = 0
This._ControlHwnd = 0

Local lnx As Integer

*!* Aux toolbar in _Screen, clear object reference, remove property
If Pemstatus(_Screen, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
    _Screen.StatusBar_ToolBar = Null
    Removeproperty(_Screen, "StatusBar_ToolBar")
Endif

*!* Clear objects references - see _AddPanels

For m.lnx = 1 To This.ctlPanelCount
    This.ctlPanels(m.lnx) = Null
Endfor

For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
    This._Panels(m.lnx) = Null
Endfor

*!* Display native vfp statusbar
If This._FormType  = CON_FORMTYPE_SCREEN
    apiShowWindow(This._VFPStatusBarHWnd, SW_SHOWNA)
Endif



ENDPROC
PROCEDURE _eventhandlerformactivate
*!* _EventHandlerFormActivate

*!* This only gets called via a BindeEvent to parent TLF activate event
*!* so the StatusBar is created after the form is visible

Local lnX

Unbindevent(Thisform, "Activate", This, "_EventHandlerFormActivate")
This._Create()
This.ctlInit()

*!* This added so icons and captions assigned in control init will show, if
*!* control is used in a top level form
For m.lnX = 1 To This.ctlPanelCount + This.nStdPanelCount
	This._Panels(m.lnX)._UpdateAll()
Endfor

ENDPROC
PROCEDURE _eventhandlerformdestroybefore
*!* _EventHandlerFormDestroyBefore

If Pemstatus(Thisform, "StatusBar_ToolBar", CON_PEMSTAT_DEFINED) Then
    Thisform.StatusBar_ToolBar = Null
    Removeproperty(Thisform, "StatusBar_ToolBar")
Endif

ENDPROC
PROCEDURE _eventhandlerformresize
*!* _EventHandlerFormResize

This._Resize()

ENDPROC
PROCEDURE _getborder
*!* Returns width in pixels of borders of a statusbar control

*!* 1 = Horizontal
*!* 2 = Vertical
*!* 3 = Separator

Lparameters tnWhichBorder

Local ;
	lcBorders as String, ;
    lnBorder As Number

m.lcBorders = Replicate(NULCHAR, 12)

apiSendMessage(This._ControlHwnd, SB_GETBORDERS, 0, @ m.lcBorders)

Do Case
    Case tnWhichBorder = 1
        m.lnBorder = CToBin(Substr(m.lcBorders, 1, 4), "4RS") && horizontal

    Case tnWhichBorder = 2
        m.lnBorder = CToBin(Substr(m.lcBorders, 5, 4), "4RS") && vertical

    Otherwise
        m.lnBorder = CToBin(Substr(m.lcBorders, 9, 4), "4RS") && separator
Endcase

Return m.lnBorder




ENDPROC
PROCEDURE _messagehandlerproxywindowwm_notify
*!* _MessageHandlerProxyWindowWM_NOTIFY

*!* 2006-06-27 Now it uses _nmmouse class to handle structure
*!* Bindevent(This._ProxyHWnd, WM_NOTIFY, This, "ctl32_WM_Notify", 1)
*!* Handles mouse clicks in statubar window

*!* msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/status/status.asp
*!* The WM_NOTIFY  lParam parameter is a pointer to a nmmouse Structure

Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer

Local ;
	lnResult As Number, ;
	lnCode As Number, ;
	lndwItemSpec As Number

If m.tnMsg = WM_NOTIFY And m.tnwParam = 0 Then

	*!* Read string of data

	Local loNmMouse As ctlNMMOUSE Of ctl32_structures.prg

	m.loNmMouse = Createobject("ctlNMMOUSE", m.tnLparam)

	*!* This determines button pressed and click/double click
	m.lnCode = m.loNmMouse.hdr.Code

	*!* This determines panel clicked
	m.lndwItemSpec = m.loNmMouse.dwItemSpec

	*!* This are mouse click coordinates
	This.nXCoord = m.loNmMouse.pt.x
	This.nYCoord = m.loNmMouse.pt.Y

	*!* Determine Panel clicked
	*!* PanelMessage will be -1, progressbar panel 0, first custom panel 1....
	*!* right panels will be 101, 102, 103, 104
	*!* no panel clicked is -2
	*!* m.lndwItemSpec = m.lndwItemSpec

	Do Case
		Case Between(m.lndwItemSpec, 0 , This.ctlPanelCount + 1)
			This.nPanel = m.lndwItemSpec - 1			&& Panel Clicked
		Case m.lndwItemSpec > This.ctlPanelCount
			This.nPanel = m.lndwItemSpec + 99 - This.ctlPanelCount
		Otherwise
			This.nPanel = m.lndwItemSpec
	Endcase

	*!* Determine mouse button pressed and check for double clicks
	*!* suppress second click event after double click
	Do Case
		Case m.lnCode = NM_CLICK	And This._DoubleClick = 1  && Left Click
			This._DoubleClick = 0

		Case m.lnCode = NM_RCLICK	And This._DoubleClick = 1  && Right Click
			This._DoubleClick = 0

		Case m.lnCode = NM_CLICK	And This._DoubleClick =  0  && Left Click
			This.nButton = 1
			Raiseevent(This, "ctlClick")

		Case m.lnCode = NM_RCLICK	And This._DoubleClick =  0 	&& Right Click
			This.nButton = 2
			Raiseevent(This, "ctlRightClick")

		Case m.lnCode = NM_DBLCLICK	&& Double Left Click
			This.nButton = 1
			This._DoubleClick = 1
			Raiseevent(This, "ctlDblClick")

		Case m.lnCode = NM_RDBLCLK	&& Double Right Click
			This.nButton = 2
			This._DoubleClick = 1
			Raiseevent(This, "ctlDblClick")
	Endcase
Endif

*!* 2006-06-27 Now the old window procedure is saved in the Init of the class
m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)

Return m.lnResult








ENDPROC
PROCEDURE _messagehandlerscreenwm_size
*!* _MessageHandlerScreenWM_SIZE

Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer

Local lnResult As Integer

If m.tnMsg = WM_SIZE Then
    If This._FormType  = CON_FORMTYPE_SCREEN Then
        This._Resize()
    Endif
Endif
*!* 2006-06-27 Now the old window procedure is saved in the Init of the class
*!* Just do what Calvin does, whatever it means
m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)

Return m.lnResult

ENDPROC
PROCEDURE _messagehandlervfpwm_enteridle
Lparameters m.tnHWnd As Integer, m.tnMsg As Integer, m.tnwParam As Integer, m.tnLparam As Integer

Local lnResult As Integer

m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)

If m.tnwParam = MSGF_MENU Then
    This.ctlUpdatePanels()
Endif

Return m.lnResult
ENDPROC
PROCEDURE _messagehandlervfpwm_themechanged
*!* _MessageHandlerVFPWM_THEMECHANGED

Lparameters tnHWnd As Integer, tnMsg As Integer, tnwParam As Integer, tnLparam As Integer

Local lnResult As Number

If m.tnMsg = WM_THEMECHANGED Then
    This._SetTheme()
Endif

*!* Just do what Calvin does, whatever it means
m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)

Return m.lnResult

ENDPROC
PROCEDURE _messagehandlervfpwm_uninitmenupopup
Lparameters m.tnHWnd As Integer, m.tnMsg As Integer, m.tnwParam As Integer, m.tnLparam As Integer

Local lnResult As Integer

m.lnResult  = apiCallWindowProc(This._WindowProcedure, m.tnHWnd, m.tnMsg, m.tnwParam, m.tnLparam)

_vfp.StatusBar = ""

This.ctlUpdatePanels()

Return m.lnResult

ENDPROC
PROCEDURE _propertyhandlerformthemes
*!* _PropertyHandlerFormThemes

This._SetTheme()

ENDPROC
PROCEDURE _propertyhandlerformvisible
*!* _PropertyHandlerFormVisible

This._Resize()


ENDPROC
PROCEDURE _propertyhandlerprogressbarctlvisible
*!* _PropertyHandlerProgressBarctlVisible

This.ctlResizePanels()
ENDPROC
PROCEDURE _propertyhandlerprogressbarwidth
*!* _PropertyHandlerProgressBarWidth

This.ctlResizePanels()
ENDPROC
PROCEDURE _propertyhandlerscreenthemes
*!* _PropertyHandlerScreenThemes

This._OldWindowState = -1
This._SetTheme()

ENDPROC
PROCEDURE _resize
*!*	If _FormType <> CON_FORMTYPE_DEFAULT, we have a proxy window that contains the statusbar window
*!*	This is done so the statusbar width equals the Host Width, and
*!* to show/hide the sizing grip of the statusbar, otherwise it does not display correctly
*!*	What we do is set this proxy Window to Maximized or Normal state so statusbar hides/shows sizing grip
*!*	by itself, depending on its parent proxy window WindowState

If This._ControlHwnd = 0 Or This._Creating = TRUE Then
    Return
Endif

*!* Check if a Theme change event destroyed our statusbar, if so, recreate
If apiIsWindow(This._ControlHwnd) = 0 And This._FormType = CON_FORMTYPE_SCREEN Then
    This._OldWindowState = -1
    This._Create()
    Return
Endif

*!* Check if window is still valid (it gets destroyed by OS Theme change, which triggers resize it seems)
If apiIsWindow(This._ControlHwnd) = 0
    Return
Endif

Local ;
    lcRect As String, ;
    lnyCoord As Number

*!*	If container form is _Screen or TLF, deal with proxy window
If This._FormType <> CON_FORMTYPE_DEFAULT
    *!*	IF WindowState has changed, set proxy window:
    If This._OldWindowState <> Thisform.WindowState

        apiShowWindow(This._ProxyHWnd, SW_HIDE)

        *!* 20070711 By setting the proxy window to maximized we hide size grip
        Do Case
            Case This.ctlSizeGrip = FALSE
                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)

            Case Thisform.BorderStyle <> CON_BS_SIZABLE
                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)

            Case Thisform.WindowState = WINDOWSTATE_MAXIMIZED
                apiShowWindow(This._ProxyHWnd, SW_MAXIMIZE)

            Otherwise
                apiShowWindow(This._ProxyHWnd, SW_RESTORE)
        Endcase

        This._OldWindowState = Thisform.WindowState
        apiShowWindow(This._ProxyHWnd, SW_SHOWNA)

    Endif

    *!*	Now we have to find Height of bottom window holding Statusbar proxy and maybe other
    *!*	toolbars, so we can position the proxy window at the bottom
    *!*	Also we resize proxy window to width of container form
    *!* Find Height of client rectangle of Host window:

    *!* 2006-06-27 Using oRect now
    m.lcRect = This.oRect.Value
    apiGetClientRect(This._HostHWnd, @m.lcRect)
    This.oRect.Value = m.lcRect

    m.lnyCoord = This.oRect.Height - This._Height

    *!* Resize/move statusbar proxy window
    apiSetWindowPos(This._ProxyHWnd, ;
        0, ;
        0, ;
        m.lnyCoord, ;
        This._Width, ;
        This._Height, ;
        0)
Endif

*!* Send resize message to ctl32_StatusBar
apiSendMessage(This._ControlHwnd, WM_SIZE, 0, 0)

*!* Now resize panels, only resize if width has changed:
If This._OldWidth <> This._Width Then
    This.ctlResizePanels()
    This._OldWidth = This._Width
Endif







ENDPROC
PROCEDURE _resizepanels
*!*	Panel  0 is the Message Panel
*!*	Panel  1 is the ProgressBar Panel
*!*	Panel  n to This.ctlPanelCount is Custom Panel n to This.ctlPanelCount
*!*	Panel  This.ctlPanelCount + 3 is PanelOvr
*!*	Panel  This.ctlPanelCount + 4 is PanelNum
*!*	Panel  This.ctlPanelCount + 5 is PanelCaps
*!*	Panel  This.ctlPanelCount + 6 is PanelDate
*!*	Panel  This.ctlPanelCount + 7 is Last Panel for sizing grip

*!* Panels array of StatusBar is 0 based
*!* we have 1 based arrays in VFP

If This._ControlHwnd = 0 Then
    Return
Endif

Local ;
    lnx As Number, ;
    lnMargin As Number, ;
    lnPBMargin As Number, ;
    lnLastMargin As Number, ;
    lcRights as String, ;
    lnTotalWidths As Number, ;
    lcRect as String, ;
    lnLeft As Number, ;
    oPanel


*!* Calculate margin for caption and icons in panels:
If ctlIsThemeActive(This) = TRUE Then
    m.lnMargin   = Int(This._GetBorder(CON_SBBORDER_SEPARATOR) * 3)
    m.lnPBMargin = Int(This._GetBorder(CON_SBBORDER_SEPARATOR) * 4)
Else
    m.lnMargin   = Int(This._GetBorder(CON_SBBORDER_SEPARATOR) * 2.2)
    m.lnPBMargin = Int(This._GetBorder(CON_SBBORDER_SEPARATOR) * 2) - 1
Endif

If This.PanelDate.ctlVisible = FALSE Or This.PanelDate.ctlFormat = 0
    m.lnLastMargin = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH) + This._GetBorder(CON_SBBORDER_SEPARATOR) * 2 + 1
Else
    m.lnLastMargin = Sysmetric(SYSMETRIC_VSCROLLBARWIDTH)
Endif

If Thisform.WindowState = WINDOWSTATE_MAXIMIZED Or Thisform.BorderStyle <> CON_BS_SIZABLE Then
    m.lnLastMargin = 0
Endif

*!* If no gripper at all:
If This.ctlSizeGrip = FALSE Then
   m.lnLastMargin = 0
Endif

*!* Calculate Widths of panels from right to left, first panel gets what's left of total width
*!* This.ctlPanelCount is the number of custom Panels, nStdPanelCount is the number of stock Panels (7)

This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Width = m.lnLastMargin

For m.lnx = This.ctlPanelCount + This.nStdPanelCount - 1 To 3 Step -1
    m.oPanel = This._Panels(m.lnx)
    If m.oPanel.ctlVisible Then
        If m.oPanel.ctlAutosize Then
            Do Case
                Case (Empty(m.oPanel.ctlIcon) And Empty(m.oPanel.ctlCaption))
                    m.oPanel._Width = 0

                Case Not Empty(m.oPanel.ctlIcon) And Empty(m.oPanel.ctlCaption)
                    m.oPanel._Width = 16 + Int(m.lnMargin * 1.5)

                Case Empty(m.oPanel.ctlIcon) And Not Empty(m.oPanel.ctlCaption)
                    m.oPanel._Width = ctlGetStringHeightFromHwnd(m.oPanel.ctlCaption, This._ControlHwnd) + Int(m.lnMargin * 1.5)

                Case Not Empty(m.oPanel.ctlIcon) And Not Empty(m.oPanel.ctlCaption)
                    m.oPanel._Width = 18 + m.lnMargin + ctlGetStringHeightFromHwnd(m.oPanel.ctlCaption, This._ControlHwnd) + m.lnMargin
            Endcase
        Else
            m.oPanel._Width = m.oPanel.ctlWidth
        Endif
    Else
        m.oPanel._Width = 0
    Endif
Endfor
m.oPanel = Null

*!* Calculate Width of ProgressBar Panel:
m.oPanel = This._Panels(2)
If m.oPanel.ctlAutosize = FALSE Or This.ProgressBar.ctlVisible = TRUE Then
    If ctlIsThemeActive(This) = TRUE Then
        m.oPanel._Width = This.ProgressBar.Width + m.lnPBMargin
    Else
        m.oPanel._Width = This.ProgressBar.Width + m.lnPBMargin + 1
    Endif
Else
    m.oPanel._Width = 0
Endif

*!* Now we are going to calculate the x axis value of the right border of each Panel:
*!* For now we assign StatusBar Width to Right property of last panel
This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Right = This._Width

For m.lnx = This.ctlPanelCount + This.nStdPanelCount - 1 To 1 Step -1
    This._Panels(m.lnx)._Right = Max(This._Panels(m.lnx + 1)._Right - This._Panels(m.lnx + 1)._Width, 0)
Endfor

*!* Now assign -1 to Right property of last panel so it stretches
*!* Send 0xFFFFFF instead of -1 or PanelDate is blank
This._Panels(This.ctlPanelCount + This.nStdPanelCount)._Right = 0xFFFFFF

*!* Do Same Thing to PanelDate so right border does not show
If This._Panels(This.ctlPanelCount + This.nStdPanelCount - 1).ctlVisible = TRUE Then
    This._Panels(This.ctlPanelCount + This.nStdPanelCount - 1)._Right = 0xFFFFFF
Endif

*!* Now we check if all Panels have a zero Width, then we hide all separators:
m.lnTotalWidths = 0
For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
    m.lnTotalWidths = m.lnTotalWidths + This._Panels(m.lnx)._Width
Endfor

If m.lnTotalWidths <= m.lnLastMargin Then
    This.SetAll("_Right", 0xFFFFFF, "ctl32_StatusBar_Panel")
Endif

*!* Now we build a string of the calculated x axis right borders:
m.lcRights = ""

For m.lnx = 1 To This.ctlPanelCount + This.nStdPanelCount
    m.lcRights = m.lcRights + BinToC(This._Panels(m.lnx)._Right, "4RS")
Endfor

*!* We finally send the info to the StatusBar:
apiSendMessage(This._ControlHwnd, SB_SETPARTS, This.ctlPanelCount + This.nStdPanelCount, @ m.lcRights)

If This.ProgressBar.ctlVisible Then
    *!* Set ProgressBar Left, retrieve rectangle of second panel (index 1) (0 based array in StatusBar)
    m.lcRect = This.oRect.Value
    apiSendMessage(This._ControlHwnd, SB_GETRECT, 1, @ m.lcRect)
    This.oRect.Value = m.lcRect
    This.ProgressBar.Left = This.oRect.Left + This._GetBorder(CON_SBBORDER_SEPARATOR) / 2
Endif

m.oPanel = Null

ENDPROC
PROCEDURE _setlocalestrings
Local  lnPrimaryLangID, lcIndicators

If This.ctlLangID = 0x0 Then
    m.lnPrimaryLangID = ctlGetPrimaryLangID()
    * m.lnSubLangID     = ctlGetSubLangID()
Else
    *!* If ctlLangID is <> 0 then it overrides the system locale language
    m.lnPrimaryLangID = ctlGetPrimaryLangID(This.ctlLangID)
    * m.lnSubLangID = 	ctlGetSubLangID(This.ctlLangID)
Endif

Do Case
    Case m.lnPrimaryLangID = LANG_CZECH 			&& // Vratislav Belsk //
        m.lcIndicators = "PRE|NUM|CAPS"

    Case m.lnPrimaryLangID = LANG_ENGLISH
        m.lcIndicators = "OVR|NUM|CAPS"

    Case m.lnPrimaryLangID = LANG_FRENCH
        m.lcIndicators = "OVR|NUM|CAPS"

    Case m.lnPrimaryLangID = LANG_GERMAN
        m.lcIndicators = "OVR|NUM|CAPS"

    Case m.lnPrimaryLangID = LANG_ITALIAN             && // Emanuele Cerlini //
        m.lcIndicators = "SSC|NUM|MAI"

    Case m.lnPrimaryLangID = LANG_SPANISH
        m.lcIndicators = "SOB|NUM|MAY"

    Case m.lnPrimaryLangID = LANG_RUSSIAN
        m.lcIndicators = "OVR|NUM|CAPS"

    Otherwise
        m.lcIndicators = "OVR|NUM|CAPS"	&& OTHER
Endcase

This.PanelOvr.ctlCaption  = Getwordnum(m.lcIndicators, 1, "|")
This.PanelNum.ctlCaption  = Getwordnum(m.lcIndicators, 2, "|")
This.PanelCaps.ctlCaption = Getwordnum(m.lcIndicators, 3, "|")



ENDPROC
PROCEDURE _settheme
*!* If statusbar was not preserved by a docked toolbar during a _Screen.Themes change, just return
If apiIsWindow(This._ControlHwnd) = 0 And This._FormType = CON_FORMTYPE_SCREEN Then
	Return
Endif

If ctlIsThemeActive(This) = TRUE Then
	apiSetWindowTheme(This._ControlHwnd, Null, Null)
Else
	apiSetWindowTheme(This._ControlHwnd, Null, "")
Endif

apiSendMessage(This._ControlHwnd, WM_SYSCOLORCHANGE , 0, 0)

This.ProgressBar.ctlThemes = This.ctlThemes

This._AdjustProgressBar()
This.ctlResizePanels()




ENDPROC
PROCEDURE _width_access
*!*	RETURN desired Width for StatusBar proxy Window
*!*	Width from _Screen is no good, space taken by toolbars on both
*!*	sides is subtracted from total Width, so we use _vfp HWnd

*!* Modified 20061010

Local ;
	lnHWnd As Integer, ;
	lcRect As String

If This._FormType  = CON_FORMTYPE_SCREEN
	m.lnHWnd = _vfp.HWnd
Else
	m.lnHWnd = Thisform.HWnd
Endif

m.lcRect = This.oRect.Value
apiGetClientRect(m.lnHWnd, @m.lcRect)
This.oRect.Value = m.lcRect

*!* Width is off by one pixel
Return This.oRect.Width + 1

ENDPROC
PROCEDURE ctlcaption_access
Return This.PanelMessage.ctlCaption

ENDPROC
PROCEDURE ctlcaption_assign
Lparameters vNewVal
If Type("This.PanelMessage") # T_UNDEFINED
	This.PanelMessage.ctlCaption = m.vNewVal
Endif


ENDPROC
PROCEDURE ctlgetstringsize
*!* ctlGetStringSize

*!* This method has been left here for backward compatiblity,
*!* use ctlGetStringSizeFromHwnd in ctl32.prg instead

*!* 2006-06-27 Now it uses StrToInt of _rect class
*!* ctlGetStringSize
*!* msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/fontext_8smq.asp
*!* www.news2news.com/vfp/?function=687
*!* vbnet.mvps.org/index.html?code/listapi/listrightalign.htm

*!*	typedef struct tagSIZE {
*!*	  LONG cx;
*!*	  LONG cy;
*!*	} SIZE, *PSIZE;

*!* Returns Width or Height of a string with font = font of the StatusBar
*!* tcReturnWidthOrHeight can be 'W' or 'H' or no parameter, defaults to 'W'
Lparameters tcString As String, tcReturnWidthOrHeight As String

If Pcount() = 1 Then
	m.tcReturnWidthOrHeight = "W"
Endif

Local ;
	lnSize As Number, ;
	lcSize As String, ;
	lnhFont As Number, ;
	lnhFontOld As Number, ;
	lnHdc

m.lcSize = Space(8)


m.lnHdc = apiGetDC(This.ctlHWnd)

m.lnhFont = apiSendMessage(This.ctlHWnd, WM_GETFONT, 0, 0)
m.lnhFontOld = apiSelectObject(m.lnHdc, m.lnhFont)

apiGetTextExtentPoint32(m.lnHdc, m.tcString, Len(m.tcString), @ m.lcSize)

If m.tcReturnWidthOrHeight <> "W" Then
	m.lnSize = CToBin(Substr(m.lcSize, 5, 4), "4RS")
Else
	m.lnSize = CToBin(Substr(m.lcSize, 1, 4), "4RS")
Endif

apiSelectObject(m.lnHdc, m.lnhFontOld)

apiReleaseDC(This.ctlHWnd, m.lnHdc)

Return m.lnSize



ENDPROC
PROCEDURE ctlhwnd_access
Return This._ControlHwnd

ENDPROC
PROCEDURE ctlicon_assign
*!* 2006-06-27 Added check for parameter type
Lparameters vNewVal

If Type("m.vNewVal") <> T_CHARACTER Then
    m.vNewVal = ""
Endif

This.ctlIcon = m.vNewVal
This.PanelMessage.ctlIcon = m.vNewVal


ENDPROC
PROCEDURE ctllangid_assign
Lparameters vNewVal
This.ctlLangid = m.vNewVal
This._SetLocaleStrings()

ENDPROC
PROCEDURE ctlmessage_access
Return This.PanelMessage.ctlCaption

ENDPROC
PROCEDURE ctlmessage_assign
Lparameters vNewVal
If Type("This.PanelMessage") # T_UNDEFINED
	This.PanelMessage.ctlCaption = m.vNewVal
Endif

ENDPROC
PROCEDURE ctlresizepanels
This._ResizePanels()
ENDPROC
PROCEDURE ctlthemes_assign
Lparameters vNewVal

If Type("m.vNewVal") = T_NUMERIC Then
	If m.vNewVal = 0 Then
		m.vNewVal = FALSE
	Else
		m.vNewVal = TRUE
	Endif
Endif

If Type("m.vNewVal") <> T_LOGICAL
	Return
Endif

This.ctlThemes = m.vNewVal

This._SetTheme()


ENDPROC
PROCEDURE ctlupdatepanels
Local lcMessage, lcPadLeft, lcPadRight

*!* If mouse button is down, just return. 
*!* This does not work, opening a menu returns .T. for Mdown
*!*	If Mdown() Then
*!*	    Return
*!*	Endif

Do Case
    Case This.PanelMessage.ctlAlignment = 1	&& Right
        m.lcPadLeft  = TABCHAR + TABCHAR + Space(1)
        m.lcPadRight = Space(1)

    Case This.PanelMessage.ctlAlignment = 2	&& Center
        m.lcPadLeft  = TABCHAR 
        m.lcPadRight = Space(0)

    Otherwise							&& Left
        m.lcPadLeft  = Space(1)
        m.lcPadRight = Space(0)
Endcase

If This.ShowProgressBarCaption = TRUE And This.ProgressBar.ctlVisible = TRUE Then
    m.lcMessage = m.lcPadLeft + This.ProgressBar.ctlCaption + m.lcPadRight
    apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelMessage.ctlIndex, m.lcMessage)
Else
    *!* 2006-06-27 //Anton
    If Not(This._oldMessage == _vfp.StatusBar) And Empty(This.PanelMessage.ctlCaption) Then

        This._oldMessage = _vfp.StatusBar
        m.lcMessage = m.lcPadLeft + _vfp.StatusBar + m.lcPadRight

        apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelMessage.ctlIndex, m.lcMessage)
    Endif
Endif

If  Insmode() <> This._OldOVR Then
    If Insmode() Then
        apiSendMessage(This.ctlHWnd, SB_SETTEXTA, This.PanelOvr.ctlIndex, Space(20))
    Else
        apiSendMessage(This.ctlHWnd, SB_SETTEXTA, This.PanelOvr.ctlIndex, This.PanelOvr.ctlCaption + Space(5))
    Endif
    This._OldOVR =  Insmode()
Endif

If Numlock() <> This._OldNUM Then
    If Numlock() Then
        apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelNum.ctlIndex, This.PanelNum.ctlCaption + Space(5))
    Else
        apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelNum.ctlIndex, Space(20))
    Endif
    This._OldNUM = Numlock()
Endif

If Capslock() <> This._OldCAPS Then
    If Capslock() Then
        apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelCaps.ctlIndex, This.PanelCaps.ctlCaption + Space(5))
        *apiSendMessage(This.ctlHWnd,SB_SETTEXTA, Bitor(This.PanelCaps.ctlIndex, SBT_OWNERDRAW), Space(4))
    Else
        apiSendMessage(This.ctlHWnd,SB_SETTEXTA, This.PanelCaps.ctlIndex, Space(20))
    Endif
    This._OldCAPS = Capslock()
Endif

If This._OldDate <> Dtos(Date()) And This.PanelDate.ctlFormat <> 0 Then
    This._OldDate = Dtos(Date())
    This.PanelDate.ctlCaption = ctlGetDateFormat(This.PanelDate.ctlFormat)
    This.PanelDate.ctlToolTipText = ctlGetDateFormat(2)
Endif


ENDPROC
PROCEDURE ctlupdatestyle_assign
*!* ctlUpdateStyle_Assign

*!* 20070902 added Bindevent to Thisform.hWnd WM_ENTERIDLE
*!* So it will work for menus in top level forms
*!* Added WM_UNINITMENUPOPUP Bindevent so message will clear
*!* after menu is closed

Lparameters m.lnNewUpdateStyle as Integer

Do Case
    Case m.lnNewUpdateStyle = 0			&& no updates
        Unbindevent(_vfp.HWnd, WM_ENTERIDLE)
        Unbindevent(Thisform.HWnd, WM_ENTERIDLE)
        Unbindevent(_vfp.HWnd, WM_UNINITMENUPOPUP)
        Unbindevent(Thisform.HWnd, WM_UNINITMENUPOPUP)
        This.tmrUpdater.Enabled = FALSE

    Case m.lnNewUpdateStyle = 1			&& use timer
        Unbindevent(_vfp.HWnd, WM_ENTERIDLE)
        Unbindevent(Thisform.HWnd, WM_ENTERIDLE)
        Unbindevent(_vfp.HWnd, WM_UNINITMENUPOPUP)
        Unbindevent(Thisform.HWnd, WM_UNINITMENUPOPUP)
        This.tmrUpdater.Enabled = TRUE

    Case m.lnNewUpdateStyle = 2			&& windows events
        This.tmrUpdater.Enabled = FALSE
        Bindevent(_vfp.HWnd, WM_ENTERIDLE, This, "_MessageHandlerVfpWM_ENTERIDLE", 5)
		Bindevent(Thisform.HWnd, WM_ENTERIDLE, This, "_MessageHandlerVfpWM_ENTERIDLE", 5)
        Bindevent(_vfp.HWnd, WM_UNINITMENUPOPUP, This, "_MessageHandlerVfpWM_UNINITMENUPOPUP", 5)
		Bindevent(Thisform.HWnd, WM_UNINITMENUPOPUP, This, "_MessageHandlerVfpWM_UNINITMENUPOPUP", 5)

Endcase

This.ctlUpdateStyle = m.lnNewUpdateStyle

ENDPROC
PROCEDURE hwnd_access
Return This._ControlHwnd

ENDPROC
PROCEDURE showprogressbarcaption_assign
Lparameters vNewVal

This.ShowProgressBarCaption = m.vNewVal

._oldMessage = Sys(2015)
This.ctlMessage = This.ctlMessage



ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
*_addobjects 
*_addpanels Adds Panels objects to StatusBar container
*_addprogressbar 
*_addproperties 
*_adjustprogressbar 
*_bindevents Binds events.
*_create 
*_declaredlls DLL declarations.
*_destroy 
*_eventhandlerformactivate Binded to Form.Activate, for top level forms, it creates statusbar after form is visible
*_eventhandlerformdestroybefore 
*_eventhandlerformresize 
*_getborder Returns the width of the especified border:  1 = Horizontal,  2 = Vertical, 3 = Separator
*_messagehandlerglobalproxy 
*_messagehandlerproxywindowwm_notify Handles mouse clicks in statusbar window
*_messagehandlerscreenwm_size 
*_messagehandlervfpwm_enteridle 
*_messagehandlervfpwm_themechanged 
*_messagehandlervfpwm_uninitmenupopup 
*_propertyhandlerformthemes 
*_propertyhandlerformvisible 
*_propertyhandlerprogressbarctlvisible 
*_propertyhandlerprogressbarwidth 
*_propertyhandlerscreenthemes 
*_resize Bound to Form.Resize
*_resizepanels Recalculates panel widths based on content
*_setlocalestrings Sets Locale strings for PanelCaps, PanelOvr, PanelNum
*_settheme 
*_width_access 
*ctlcaption_access 
*ctlcaption_assign 
*ctlclick 
*ctldblclick 
*ctlgetstringsize 
*ctlhwnd_access 
*ctlicon_assign 
*ctlinit 
*ctllangid_assign 
*ctlmessage_access 
*ctlmessage_assign 
*ctlresizepanels 
*ctlrightclick 
*ctlthemes_assign 
*ctlupdatepanels 
*ctlupdatestyle_assign 
*hwnd_access 
*showprogressbarcaption_assign 
^_panelborders[3,0] 
^_panels[1,0] 
^ctlpanels[1,0] 
_height
_memberdata XML Metadata for customizable properties
_width
builderx
ctlabout
ctlcaption
ctlhwnd Specifies the Window handle of the Control.
ctlicon Use PanelMessage.Icon instead
ctllangid
ctlmessage Use PanelMessage.Caption instead
ctlpanelcount Indicates how many custom panels are available.
ctlsizegrip
ctlthemes
ctlupdatestyle
ctlversion
hwnd Specifies the Window handle of the Window.
nbutton
npanel
nxcoord
nycoord
showprogressbarcaption
[END RESERVED3]
[START RESERVED4]
ctl32_statusbar.bmp[END RESERVED4]
[START RESERVED5]
ctl32_statusbar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1U50LVY1S
[CLASS] label
[BASECLASS] label
[OBJNAME] lblname
[PARENT] ctl32_statusbar
[START PROPERTIES]
AutoSize = .T.
BackStyle = 0
Caption = "ctl32_StatusBar"
FontName = "Tahoma"
FontSize = 8
ForeColor = 0,0,128
Left = 6
Name = "lblname"
Top = 4
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
Return FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _24P0VCQCO
[CLASS] timer
[BASECLASS] timer
[OBJNAME] tmrHideVFPStatusBar
[PARENT] ctl32_statusbar
[START PROPERTIES]
Enabled = .F.
Height = 23
Interval = 1000
Left = -30
Name = "tmrHideVFPStatusBar"
Top = 12
Width = 23
[END PROPERTIES]
[START METHODS]
PROCEDURE Timer
*!* By Using this timer, we give time to VFP to "stabilize" after a Theme change

apiShowWindow(This.Parent._VFPStatusBarHWnd, SW_HIDE)
This.Enabled = FALSE

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_statusbar

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2CE05TKG9
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_trackbar
[START PROPERTIES]
Height = 34
Name = "ctl32_trackbar"
Width = 240
_backgroundbrush = 0
_defaultheight = 0
_defaultthumbsize = 0
_defaultwidth = 0
_marginsize = 0
_thumbsize = 0
_tickssize = 0
ctlTextBox.Name = "ctlTextBox"
ctlautosize = .T.
ctlbottom = 0
ctlcanfocus = .T.
ctlfocused = .F.
ctllargechange = 5
ctlmaximum = 10
ctlminimum = 0
ctlorientation = 0
ctlshowticks = .T.
ctlshowtips = .F.
ctlsmallchange = 1
ctlthumbsize = 0
ctltickfrequency = 1
ctltickstyle = 2
ctltooltipposition = 0
lblname.Caption = "ctl32_trackbar"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE _bindevents
*!* _BindEvents()

DoDefault()

Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, This, "_OnWindowMessage", 4)
Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, This, "_OnWindowMessage", 4)




ENDPROC
PROCEDURE _getdefaultsize
*!* _GetDefaultSize()

*!* This gets the size (width for horizontal trackbars, height for vertical)
*!* of the tickmarks area, the margin between the border and the tickmarks or thumb,
*!* and the default thumb size. Also saves the initial width/height of the control.
*!* If ctlAutosize is set to FALSE, this initial widht/height is used to size the control
*!* properties used are:

*!* _MarginSize
*!* _DefaultThumbSize
*!* _TicksSize
*!* _DefaultSize

*!* See ctlDefaultHeight/Width_Access where this properties are used

*!* http://msdn2.microsoft.com/en-us/library/system.windows.forms.trackbar.defaultsize.aspx

Local ;
	loRect As ctlRect, ;
	lcRect As String, ;
	lnStyle As Integer, ;
	lnOldStyle As Integer

If This._ControlHwnd = 0
	Return
Endif

m.lnStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

*!* Save current value
m.lnOldStyle = m.lnStyle

m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_AUTOTICKS), TBS_AUTOTICKS)
m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_NOTICKS), TBS_NOTICKS)
m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_TOP), TBS_TOP)
m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_BOTTOM), TBS_BOTTOM)
m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_BOTH), TBS_BOTH)
m.lnStyle = Bitxor(Bitor(m.lnStyle, TBS_VERT), TBS_VERT)
m.lnStyle = Bitor(m.lnStyle, TBS_HORZ)

m.loRect = Createobject("ctlRect")
m.lcRect = m.loRect.Value

*!* Remove all ticks and get top margin and thumb height
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, Bitor(m.lnStyle, TBS_NOTICKS))
apiSendMessage(This._ControlHwnd, TBM_GETTHUMBRECT , 0, @m.lcRect)
m.loRect.Value = m.lcRect

This._MarginSize = m.loRect.Top

*!* Save the Windows default thumb size once:
This._DefaultThumbSize = m.loRect.Height

*!* Add ticks at the top, calculate ticks height
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, Bitor(m.lnStyle, TBS_TOP, TBS_AUTOTICKS))
apiSendMessage(This._ControlHwnd, TBM_GETTHUMBRECT , 0, @m.lcRect)
m.loRect.Value = m.lcRect

This._TicksSize = m.loRect.Top - This._MarginSize

This._DefaultHeight = This.Height
This._DefaultWidth = This.Width

*!* Set style to saved style
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.lnOldStyle)

ENDPROC
PROCEDURE _getdwexstyle
*!* _GetdwExStyle()

Return 0 &&BITOR(WS_EX_TOOLWINDOW, WS_EX_TOPMOST)

ENDPROC
PROCEDURE _getdwstyle
*!* _GetdwStyle()

Local ;
	dwStyle As Integer, ;
	lnTickStyle As Integer

m.dwStyle = Bitor(WS_CHILD, WS_CLIPCHILDREN, WS_CLIPSIBLINGS, WS_TABSTOP) &&, WS_POPUP)

m.dwStyle = Bitor(m.dwStyle, TBS_FIXEDLENGTH, TBS_DOWNISLEFT)

If This.ctlShowTips = TRUE Then
	m.dwStyle = Bitor(m.dwStyle, TBS_TOOLTIPS)
Endif

If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
	m.dwStyle = Bitor(m.dwStyle, TBS_VERT)
Else
	m.dwStyle = Bitor(m.dwStyle, TBS_HORZ)
Endif

m.lnTickStyle = Min(Max(This.ctlTickStyle, CTLTICKSTYLE_NONE), CTLTICKSTYLE_BOTH)

If This.ctlShowTicks = FALSE Or m.lnTickStyle = CTLTICKSTYLE_NONE Then
	m.dwStyle = Bitor(m.dwStyle, TBS_NOTICKS)
Else
	m.dwStyle = Bitor(m.dwStyle, TBS_AUTOTICKS)
Endif

Do Case

Case m.lnTickStyle = CTLTICKSTYLE_TOPLEFT
	m.dwStyle = Bitor(m.dwStyle, TBS_TOP)

Case m.lnTickStyle = CTLTICKSTYLE_BOTTOMRIGHT
	m.dwStyle = Bitor(m.dwStyle, TBS_BOTTOM)

Case m.lnTickStyle = CTLTICKSTYLE_BOTH
	m.dwStyle = Bitor(m.dwStyle, TBS_BOTH)

Endcase

Return m.dwStyle

ENDPROC
PROCEDURE _getlpclassname
Return TRACKBAR_CLASSA

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

DoDefault()

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_HSCROLL Or Thisform._2ce01ty4y_Msg = WM_VSCROLL

		If Thisform._2ce01ty4y_lParam = This._ControlHwnd Then

			*!* TBS_DOWNISLEFT style just plain does not work!, so reverse value for
			*!* vertical trackbars

			This._EnableUpdates = FALSE

			If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
				This.ctlValue = This.ctlMaximum - apiSendMessage(This._ControlHwnd, TBM_GETPOS, 0, 0) + This.ctlMinimum
			Else
				This.ctlValue = apiSendMessage(This._ControlHwnd, TBM_GETPOS, 0, 0)
			Endif

			This._EnableUpdates = TRUE

		Endif

		*!*		Case Thisform._2ce01ty4y_Msg = WM_NOTIFY

		*!*			If This.ctlBackStyle # 0 Then
		*!*				Return
		*!*			Endif

		*!*			*!* Get NMHDR structure from pointer
		*!*			Local m.loNMHdr As CTLNMHDR
		*!*			m.loNMHdr = Createobject("CTLNMHDR", Thisform._2ce01ty4y_lParam)

		*!*			*!* If the notification is not NM_CUSTOMDRAW, nothing to do
		*!*			If m.loNMHdr.Code # NM_CUSTOMDRAW Then
		*!*				Return
		*!*			Endif

		*!*			*!* If the message is not for this control, just return
		*!*			If m.loNMHdr.hwndFrom # This._ControlHwnd Then
		*!*				Return
		*!*			Endif

		*!*			*!* We have a NM_CUSTOMDRAW notification, get NMCUSTOMDRAW structure from pointer
		*!*			*!* The NMCUSTOMDRAW first member is the NMHDR we got before
		*!*			Local m.loNMCustomDraw As CTLNMCUSTOMDRAW
		*!*			m.loNMCustomDraw = Createobject("CTLNMCUSTOMDRAW", Thisform._2ce01ty4y_lParam)

		*!*			*!* If this is prepaint stage, ask to be notified of items prepaints and return.
		*!*			If m.loNMCustomDraw.dwDrawStage = CDDS_PREPAINT
		*!*				This._uItemState = m.loNMCustomDraw.uItemState
		*!*				Thisform._2ce01ty4y_ReturnValue = CDRF_NOTIFYITEMDRAW
		*!*				Return
		*!*			Endif

		*!*			*!* At this point, if we dont have a CDDS_ITEMPREPAINT, nothing to do then
		*!*			If m.loNMCustomDraw.dwDrawStage # CDDS_ITEMPREPAINT
		*!*				Return
		*!*			Endif

		*!*			Thisform._2ce01ty4y_ReturnValue = CDRF_DODEFAULT

		*!*			*!* Before control draws ticks, draw background:
		*!*			If m.loNMCustomDraw.dwItemSpec = TBCD_TICS
		*!*				Local m.lcRect As String

		*!*				*!* If control has focus, leave space for focus rectangle
		*!*				*!* Code is not clear, trying to speed things up
		*!*				If Bitand(This._uItemState, CDIS_FOCUS) = CDIS_FOCUS And This.ctlShowFocusCues Then
		*!*					m.lcRect = ;
		*!*						0h0100000001000000 + ;
		*!*						BINTOC(This.Width - 1, "4rs") + ;
		*!*						BINTOC(This.Height - 1, "4rs")
		*!*				Else
		*!*					m.lcRect = ;
		*!*						0h0000000000000000 + ;
		*!*						BINTOC(This.Width, "4rs") + ;
		*!*						BINTOC(This.Height, "4rs")
		*!*				Endif

		*!*				apiFillRect(m.loNMCustomDraw.hdc, m.lcRect, This._BackGroundBrush)

		*!*				Return
		*!*			Endif

		*!*			*!* Before control draws channel, draw channel background, with a width equal to the thumb
		*!*			If m.loNMCustomDraw.dwItemSpec = TBCD_CHANNEL
		*!*				Local m.loRect As CTLRECT, m.lcRect As String
		*!*				m.loRect = Createobject("CTLRECT")
		*!*				m.lcRect = m.loRect.Value
		*!*				apiSendMessage(This._ControlHwnd, TBM_GETTHUMBRECT , 0, @m.lcRect)
		*!*				m.loRect.Value = m.lcRect

		*!*				**!* If control has focus, leave space for focus rectangle
		*!*				If Bitand(This._uItemState, CDIS_FOCUS) = CDIS_FOCUS And This.ctlShowFocusCues Then
		*!*					If This.ctlOrientation = 0 Then
		*!*						m.loRect.Left = 1
		*!*						m.loRect.Right = This.Width - 1
		*!*					Else
		*!*						m.loRect.Top = 1
		*!*						m.loRect.Bottom = This.Height - 1
		*!*					Endif

		*!*				Else
		*!*					If This.ctlOrientation = 0 Then
		*!*						m.loRect.Left = 0
		*!*						m.loRect.Right = This.Width
		*!*					Else
		*!*						m.loRect.Top = 0
		*!*						m.loRect.Bottom = This.Height
		*!*					Endif
		*!*				Endif

		*!*				m.lcRect = m.loRect.Value

		*!*				*apiFillRect(m.loNMCustomDraw.hdc, m.lcRect, This._BackGroundBrush)

		*!*			Endif

Endcase

ENDPROC
PROCEDURE _postcreate
*!* _PostCreate()

This._SetMinimum()
This._SetMaximum()

This._SetLargeChange()
This._SetSmallChange()

This._SetTickFrequency()
This._SetToolTipPosition()

This._SetShowFocusCues()

This._SetThumbSize()

ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

Local lnAnchor As Integer

m.lnAnchor = This.Anchor

This.Anchor = 0

If This.ctlAutoSize = TRUE Then

	*!* Save previous dimensions
	This._DefaultHeight = This.Height
	This._DefaultWidth = This.Width

	If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		This.Width = This.ctlDefaultWidth
	Else
		This.Height = This.ctlDefaultHeight
	Endif

Else

	If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
		This.Width = This._DefaultWidth
	Else
		This.Height = This._DefaultHeight
	Endif

Endif

This.Anchor = m.lnAnchor

ENDPROC
PROCEDURE _setbackcolor
This._CreateBackGroundBrush()
This.ctlRefresh()

ENDPROC
PROCEDURE _setlargechange
*!* _SetLargeChange()

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, TBM_SETPAGESIZE, 0, THIS.ctlLargeChange)

ENDPROC
PROCEDURE _setmaximum
*!* _SetMaximum()

#Define FREDRAW 1

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, TBM_SETRANGEMAX, FREDRAW, This.ctlMaximum)

ENDPROC
PROCEDURE _setminimum
*!* _SetMinimum()

#Define FREDRAW 1

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, TBM_SETRANGEMIN, FREDRAW, This.ctlMinimum)

ENDPROC
PROCEDURE _setorientation
*!* _SetOrientation

Local ;
	dwStyle As Integer, ;
	lnOrientation as Integer, ;
	lnAnchor As Integer, ;
	lnWidth As Integer, ;
	llVisible As Boolean

If This._ControlHwnd = 0
	Return
Endif

m.dwStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

m.lnOrientation = Min(Max(This.ctlOrientation, CTLORIENTATION_HORIZONTAL), CTLORIENTATION_VERTICAL)

m.lnAnchor = This.Anchor
m.llVisible = This.ctlVisible

This.ctlVisible = FALSE
This.Anchor = 0

If m.lnOrientation = CTLORIENTATION_HORIZONTAL Then
	m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_VERT), TBS_VERT)
	m.dwStyle = Bitor(m.dwStyle, TBS_HORZ)
Else
	m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_HORZ), TBS_HORZ)
	m.dwStyle = Bitor(m.dwStyle, TBS_VERT)
Endif

m.lnWidth = This.Width

This.Width = This.Height
This.Height = m.lnWidth

This.Anchor = m.lnAnchor

*!* This will also restore the visible bit
apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.dwStyle)


ENDPROC
PROCEDURE _setshowtips
*!* _SetShowTips()

*!* Control must be recreated
This._Create()

ENDPROC
PROCEDURE _setsmallchange
*!* _SetSmallChange()

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, TBM_SETLINESIZE, 0, THIS.ctlSmallChange)

ENDPROC
PROCEDURE _setthumbsize
*!* _SetThumbSize()

Local lnThumbSize As Integer

If This._ControlHwnd = 0
	Return
Endif

If This.ctlThumbSize <= 0 Then
	m.lnThumbSize = This._DefaultThumbSize
Else
	m.lnThumbSize = This.ctlThumbSize
Endif

apiSendMessage(This._ControlHwnd, TBM_SETTHUMBLENGTH, m.lnThumbSize, 0)

This._SetAutoSize()

ENDPROC
PROCEDURE _settickfrequency
*!* _SetTickFrequency()

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, TBM_SETTICFREQ, This.ctlTickFrequency, 0)

*!* Force control redraw if tick frequency is 0, because control does not
*!* redraw itself in this case

If This.ctlTickFrequency = 0 Then
	apiSendMessage(This._ControlHwnd, WM_SETFOCUS, 0, 0)
Endif

ENDPROC
PROCEDURE _settickstyle
*!* _SetTickStyle()

Local ;
	dwStyle As Integer, ;
	lnTickStyle As Integer

If This._ControlHwnd = 0
	Return
Endif

m.dwStyle = apiGetWindowLong(This._ControlHwnd, GWL_STYLE)

m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_AUTOTICKS), TBS_AUTOTICKS)
m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_NOTICKS), TBS_NOTICKS)
m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_TOP), TBS_TOP)
m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_BOTTOM), TBS_BOTTOM)
m.dwStyle = Bitxor(Bitor(m.dwStyle, TBS_BOTH), TBS_BOTH)

m.lnTickStyle = Min(Max(This.ctlTickStyle, CTLTICKSTYLE_NONE), CTLTICKSTYLE_BOTH)

If This.ctlShowTicks = FALSE Or m.lnTickStyle = CTLTICKSTYLE_NONE Then
	m.dwStyle = Bitor(m.dwStyle, TBS_NOTICKS)
Else
	m.dwStyle = Bitor(m.dwStyle, TBS_AUTOTICKS)
Endif

Do Case

Case m.lnTickStyle = CTLTICKSTYLE_TOPLEFT
	m.dwStyle = Bitor(m.dwStyle, TBS_TOP)

Case m.lnTickStyle = CTLTICKSTYLE_BOTTOMRIGHT
	m.dwStyle = Bitor(m.dwStyle, TBS_BOTTOM)

Case m.lnTickStyle = CTLTICKSTYLE_BOTH
	m.dwStyle = Bitor(m.dwStyle, TBS_BOTH)

Endcase

apiSetWindowLong(This._ControlHwnd, GWL_STYLE, m.dwStyle)

If This.ctlAutoSize Then
	This._SetAutoSize()
Endif

ENDPROC
PROCEDURE _settooltipposition
*!* _SetToolTipPosition()

*!*	#Define TBTS_TOP                                                     0
*!*	#Define TBTS_LEFT                                                    1
*!*	#Define TBTS_BOTTOM                                                  2
*!*	#Define TBTS_RIGHT                                                   3

Local lnToolTipStyle as Integer

If This._ControlHwnd = 0
	Return
Endif

m.lnToolTipPosition = Min(Max(This.ctlToolTipPosition, TBTS_TOP), TBTS_RIGHT)

apiSendMessage(This._ControlHwnd, TBM_SETTIPSIDE, m.lnToolTipPosition, 0)




ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

DoDefault()

#Define FREDRAW 1

If This._ControlHwnd = 0
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

*!* TBS_DOWNISLEFT style just plain does not work!

If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then
	apiSendMessage(This._ControlHwnd, TBM_SETPOS, FREDRAW, This.ctlMaximum - This.ctlValue + This.ctlMinimum)
Else
	apiSendMessage(This._ControlHwnd, TBM_SETPOS, FREDRAW, This.ctlValue)
Endif

*!* Refresh control
If This.ctlFocused = FALSE Then
	apiSendMessage(This._ControlHwnd, WM_SETFOCUS, 0, 0)
Endif



ENDPROC
PROCEDURE ctldefaultheight_access
*!* ctlDefaultHeight_Access()

*!* ctlTickStyle = 0
*!* =========== Margin
*!*      #      Thumb
*!* =========== Margin

*!* ctlTickStyle = 1
*!* =========== Margin
*!*      #      Thumb
*!* | | | | | | Tickmarks
*!* =========== Margin

*!* ctlTickStyle = 2
*!* =========== Margin
*!* | | | | | | Tickmarks
*!*      #      Thumb
*!* =========== Margin

*!* ctlTickStyle = 3
*!* =========== Margin
*!* | | | | | | Tickmarks
*!*      #      Thumb
*!* | | | | | | Tickmarks
*!* =========== Margin

Local ;
	lnHeight As Integer, ;
	lnThumbSize As Integer

*!* "The default width is 104 pixels" says Microsoft
If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then

	m.lnThumbSize = apiSendMessage(This._ControlHwnd, TBM_GETTHUMBLENGTH, 0, 0)

	Do Case
		Case This.ctlShowTicks = FALSE
			m.lnHeight = This._MarginSize * 2 + m.lnThumbSize

		Case This.ctlTickStyle < 1
			m.lnHeight = This._MarginSize * 2 + m.lnThumbSize

		Case This.ctlTickStyle = 1
			m.lnHeight = This._MarginSize * 2 + This._TicksSize + m.lnThumbSize

		Case This.ctlTickStyle = 2
			m.lnHeight = This._MarginSize * 2 + m.lnThumbSize + This._TicksSize

		Case This.ctlTickStyle > 2
			m.lnHeight = This._MarginSize * 2 + This._TicksSize * 2 + m.lnThumbSize
	Endcase

Else

	*!* "The default height for a vertical trackbar is 104 pixels" says Microsoft
	m.lnHeight = 104

Endif

Return m.lnHeight

ENDPROC
PROCEDURE ctldefaultwidth_access
*!* ctlDefaultWidth_Access()

*!* ctlTickStyle = 0
*!* =========== Margin
*!*      #      Thumb
*!* =========== Margin

*!* ctlTickStyle = 1
*!* =========== Margin
*!*      #      Thumb
*!* | | | | | | Tickmarks
*!* =========== Margin

*!* ctlTickStyle = 2
*!* =========== Margin
*!* | | | | | | Tickmarks
*!*      #      Thumb
*!* =========== Margin

*!* ctlTickStyle = 3
*!* =========== Margin
*!* | | | | | | Tickmarks
*!*      #      Thumb
*!* | | | | | | Tickmarks
*!* =========== Margin

Local ;
	lnWidth As Integer, ;
	lnThumbSize As Integer

If This.ctlOrientation # CTLORIENTATION_HORIZONTAL Then

	m.lnThumbSize = apiSendMessage(This._ControlHwnd, TBM_GETTHUMBLENGTH, 0, 0)

	Do Case
		Case This.ctlShowTicks = FALSE
			m.lnWidth = This._MarginSize * 2 + m.lnThumbSize

		Case This.ctlTickStyle < 1
			m.lnWidth = This._MarginSize * 2 + m.lnThumbSize

		Case This.ctlTickStyle = 1
			m.lnWidth = This._MarginSize * 2 + This._TicksSize + m.lnThumbSize

		Case This.ctlTickStyle = 2
			m.lnWidth = This._MarginSize * 2 + m.lnThumbSize + This._TicksSize

		Case This.ctlTickStyle > 2
			m.lnWidth = This._MarginSize * 2 + This._TicksSize * 2 + m.lnThumbSize
	Endcase

Else

	*!* "The default width for an horizontal trackbar is 104 pixels" says Microsoft
	m.lnWidth = 104

Endif

Return m.lnWidth

ENDPROC
PROCEDURE ctllargechange_assign
*!* ctlLargeChange_Assign()

Lparameters m.tuNewValue

If This.ctlLargeChange # m.tuNewValue Then
	This.ctlLargeChange = m.tuNewValue
	This._SetLargeChange()
Endif


ENDPROC
PROCEDURE ctlmaximum_assign
*!* ctlMaximum_Assign()

Lparameters m.tuNewValue

If This.ctlMaximum # m.tuNewValue Then
	This.ctlMaximum = m.tuNewValue
	This._SetMaximum()
Endif

ENDPROC
PROCEDURE ctlminimum_assign
*!* ctlMinimum_Assign()

Lparameters m.tuNewValue

If This.ctlMinimum # m.tuNewValue Then
	This.ctlMinimum = m.tuNewValue
	This._SetMinimum()
Endif

ENDPROC
PROCEDURE ctlsetrange
*!* ctlSetRange(nMin, nMax)

Lparameters m.tnMinimum As Integer, m.tnMaximum As Integer

This.ctlMinimum = m.tnMinimum
This.ctlMaximum = m.tnMaximum
ENDPROC
PROCEDURE ctlshowticks_assign
*!* ctlShowTicks_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

If This.ctlShowTicks # m.tuNewValue Then
	This.ctlShowTicks = m.tuNewValue
	This._SetTickStyle()
Endif

ENDPROC
PROCEDURE ctlshowtips_assign
*!* ctlShowTips_Assign()

Lparameters m.tuNewValue

If Vartype(m.tuNewValue) = T_NUMERIC Then
	m.tuNewValue= m.tuNewValue # 0
Endif

If This.ctlShowTips # m.tuNewValue Then
	This.ctlShowTips = m.tuNewValue
	This._SetShowTips()
Endif

ENDPROC
PROCEDURE ctlsmallchange_assign
*!* ctlSmallChange_Assign()

Lparameters m.tuNewValue

If This.ctlSmallChange # m.tuNewValue Then
	This.ctlSmallChange = m.tuNewValue
	This._SetSmallChange()
Endif


ENDPROC
PROCEDURE ctlthumbsize_assign
*!* ctlThumbSize_Assign()

Lparameters m.tuNewValue

If m.tuNewValue <= 0 Then
	m.tuNewValue = This._DefaultThumbSize
Endif

This.ctlThumbSize = m.tuNewValue
This._SetThumbSize()

ENDPROC
PROCEDURE ctltickfrequency_assign
*!* ctlTickFrequency_Assign()

Lparameters m.tuNewValue

If This.ctlTickFrequency # m.tuNewValue Then
	This.ctlTickFrequency = m.tuNewValue
	This._SetTickFrequency()
Endif


ENDPROC
PROCEDURE ctltickstyle_assign
*!* ctlTickStyle_Assign()

Lparameters m.tuNewValue

If This.ctlTickStyle # m.tuNewValue Then
	This.ctlTickStyle = m.tuNewValue
	This._SetTickStyle()
Endif

ENDPROC
PROCEDURE ctltooltipposition_assign
*!* ctlToolTipPosition_Assign()

Lparameters m.tuNewValue

If This.ctlToolTipPosition # m.tuNewValue Then
	This.ctlToolTipPosition = m.tuNewValue
	This._SetToolTipPosition()
Endif

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_assign 
*_setlargechange 
*_setmaximum 
*_setminimum 
*_setshowtips 
*_setsmallchange 
*_setthumbsize 
*_settickfrequency 
*_settickstyle 
*_settooltipposition 
*ctllargechange_assign 
*ctlmaximum_assign 
*ctlminimum_assign 
*ctlscroll Occurs when either a mouse or keyboard action moves the scroll box.
*ctlsetrange Sets the minimum and maximum values for a TrackBar.
*ctlshowticks_assign 
*ctlshowtips_assign 
*ctlsmallchange_assign 
*ctlthumbsize_assign 
*ctltickfrequency_assign 
*ctltickstyle_assign 
*ctltooltipposition_assign 
_defaultthumbsize Saves the default thumbsize for trackbars.
_marginsize
_thumbsize Specifies the Windows DEFAULT ThumbSize
_tickssize
ctllargechange Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
ctlmaximum Gets or sets the upper limit of the range this TrackBar is working with.
ctlminimum Gets or sets the lower limit of the range this TrackBar is working with.
ctlshowticks Specifies if the tick marks should be visible.
ctlshowtips Determines whether ToolTips are shown for the control.
ctlsmallchange Gets or sets the value added to or subtracted from the Value property when the scroll box is moved a small distance.
ctlthumbsize Gets or sets the size of the slider in a trackbar.
ctltickfrequency Gets or sets a value that specifies the delta between ticks drawn on the control.
ctltickstyle Gets or sets a value indicating how to display the tick marks on the track bar. 0,1,2,3.
ctltooltipposition Specifies the position of the ToolTip control used by a trackbar control.
[END RESERVED3]
[START RESERVED4]
ctl32_trackbar.bmp[END RESERVED4]
[START RESERVED5]
ctl32_trackbar.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_trackbar
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2DD18X1VR
[CLASS] ctl32_controlbase
[CLASSLOC] ctl32.vcx
[BASECLASS] container
[OBJNAME] ctl32_updown
[START PROPERTIES]
Height = 18
Name = "ctl32_updown"
Width = 84
ctlTextBox.Name = "ctlTextBox"
ctllargechange = 10
ctlmaximum = 100
ctlminimum = 0
ctlsmallchange = 1
lblname.Caption = "ctl32_updown"
lblname.Name = "lblname"
[END PROPERTIES]
[START METHODS]
PROCEDURE _bindevents
*!* _BindEvents()

DoDefault()

Bindevent(This.ctlHostFormhWnd, WM_HSCROLL, This, "_OnWindowMessage", 4)
Bindevent(This.ctlHostFormhWnd, WM_VSCROLL, This, "_OnWindowMessage", 4)

ENDPROC
PROCEDURE _getdefaultsize
*!* _GetDefaultSize()

This._DefaultHeight = This.Height
This._DefaultWidth = This.Width

ENDPROC
PROCEDURE _getdwstyle
*!* _GetdwStyle()

Local dwStyle As Integer

m.dwStyle = Bitor(WS_CHILD, WS_CLIPSIBLINGS, UDS_HOTTRACK)

*!* Orientation
If This.ctlOrientation = 0  Then
	m.dwStyle = Bitor(m.dwStyle, UDS_HORZ)
Endif

Return m.dwStyle

ENDPROC
PROCEDURE _getlpclassname
*!* _GetlpClassName()

Return UPDOWN_CLASSA

ENDPROC
PROCEDURE _onformmessage
*!* _OnFormMessage()

DoDefault()

Local ;
	m.lnValue As Integer, ;
	m.lnRequest As Integer

Do Case

	Case Thisform._2ce01ty4y_Msg = WM_HSCROLL Or Thisform._2ce01ty4y_Msg = WM_VSCROLL

		If Thisform._2ce01ty4y_lParam = This._ControlHwnd Then

			This._EnableUpdates = FALSE
			This.ctlValue = apiSendMessage(This._ControlHwnd, UDM_GETPOS32, 0, 0)
			This._EnableUpdates = TRUE
		Endif

Endcase

ENDPROC
PROCEDURE _postcreate
This._SetMaximum()

This._SetAutoSize()
ENDPROC
PROCEDURE _setautosize
*!* _SetAutosize()

Local lnAnchor As Integer

m.lnAnchor = This.Anchor

This.Anchor = 0

If This.ctlAutoSize = TRUE Then

	*!* Save previous dimensions
	This._DefaultHeight = This.Height
	This._DefaultWidth = This.Width

	This.Width = This.ctlDefaultWidth
	This.Height = This.ctlDefaultHeight

Else

	This.Width = This._DefaultWidth
	This.Height = This._DefaultHeight

	*!* _http://support.microsoft.com/kb/180077/en-us/
	*!* PRB: Cannot Change Width of Vertical Up-Down Control
	If This._ControlHwnd # 0 And This.ctlOrientation = CTLORIENTATION_VERTICAL Then
		Local ;
			lhwnd As Integer, ;
			lhWndInsertAfter As Integer, ;
			lx As Integer, ;
			ly As Integer, ;
			lcx As Integer, ;
			lcy As Integer, ;
			lwFlags As Integer

		m.lhwnd 			= This._ControlHwnd
		m.lhWndInsertAfter 	= 0
		m.lx 				= This.ctlLocationLeft
		m.ly  				= This.ctlLocationTop
		m.lcx 				= This.Width
		m.lcy 				= This.Height
		m.lwFlags 			= SWP_NOZORDER

		apiSetWindowPos( ;
			m.lhwnd, ;
			m.lhWndInsertAfter,;
			m.lx, ;
			m.ly, ;
			m.lcx, ;
			m.lcy, ;
			m.lwFlags)

	Endif
Endif

This.Anchor = m.lnAnchor

ENDPROC
PROCEDURE _setbackcolor
*!* _SetBackColor()

This._CreateBackGroundBrush()
This.ctlRefresh()

ENDPROC
PROCEDURE _setmaximum
*!* _SetMaximum()

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, UDM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)


ENDPROC
PROCEDURE _setminimum
*!* _SetMinimum()

If This._ControlHwnd = 0
	Return
Endif

apiSendMessage(This._ControlHwnd, UDM_SETRANGE32, This.ctlMinimum, This.ctlMaximum)


ENDPROC
PROCEDURE _setvalue
*!* _SetValue()

DoDefault()

If This._ControlHwnd = 0
	Return
Endif

If This._EnableUpdates = FALSE
	Return
Endif

apiSendMessage(This._ControlHwnd, UDM_SETPOS32, 0, This.ctlValue)


ENDPROC
PROCEDURE ctldefaultheight_access
*!* ctlDefaultHeight_Access()

Local ;
	lnHeight As Integer

If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
	m.lnHeight = SYSMETRIC(8)
Else
	m.lnHeight = SYSMETRIC(8) * 2
Endif

Return m.lnHeight

ENDPROC
PROCEDURE ctldefaultwidth_access
*!* ctlDefaultWidth_Access()

Local ;
	lnWidth As Integer

If This.ctlOrientation = CTLORIENTATION_HORIZONTAL Then
	m.lnWidth = Sysmetric(5) * 2
Else
	m.lnWidth = Sysmetric(5)
Endif

Return m.lnWidth

ENDPROC
PROCEDURE ctlmaximum_assign
*!* ctlMaximum_Assign()

Lparameters m.tuNewValue

If This.ctlMaximum # m.tuNewValue Then
	This.ctlMaximum = m.tuNewValue
	This._SetMaximum()
Endif

ENDPROC
PROCEDURE ctlminimum_assign
*!* ctlMinimum_Assign()

Lparameters m.tuNewValue

If This.ctlMinimum # m.tuNewValue Then
	This.ctlMinimum = m.tuNewValue
	This._SetMinimum()
Endif

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
*_setmaximum 
*_setminimum 
*ctlmaximum_assign 
*ctlminimum_assign 
ctllargechange Gets or sets a value to be added to or subtracted from the Value property when the scroll box is moved a large distance.
ctlmaximum Gets or sets the upper limit of values of the scrollable range.
ctlminimum Gets or sets the lower limit of values of the scrollable range.
ctlsmallchange Gets or sets the value to be added to or subtracted from the Value property when the scroll box is moved a small distance.
[END RESERVED3]
[START RESERVED4]
ctl32_updown.bmp[END RESERVED4]
[START RESERVED5]
ctl32_updown.bmp[END RESERVED5]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
ctl32.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] ctl32_updown
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D4115V7U
[CLASS] container
[BASECLASS] container
[OBJNAME] etiqueta
[START PROPERTIES]
BackColor = 255,0,0
BorderWidth = 0
Height = 405
MouseIcon = ..\alal2008\
Name = "etiqueta"
Width = 645
_memberdata = 
barra = 
bruto = 0
clave = XX
codigo = XXXX
descripcion = 
fecha = (datetime())
guid_stock = 
idcaja = 
imprimir = .T.
lote = 0
neto = 0
nombre = 
operador = 0
padsize = 12
serial = 0
serial2 = 0
serialinc = 0
serialprn = 0
tara = 0
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
This.BackColor = Rgb(255,255,255)

ENDPROC
PROCEDURE barra_assign
Lparameters tuNewValue
This.barra = tuNewValue

Local m.lcBarra As String

m.lcBarra = ""

ENDPROC
PROCEDURE bruto_assign
Lparameters tuNewValue
This.Bruto = Max(0, Round(tuNewValue, 2))

This.Neto = Max(0, This.Bruto - This.Tara)

This.lblBruto.Caption = Transform(This.Bruto, "999" + Set("Point") + "99")
This.lblTara.Caption  = Transform(This.Tara, "999" + Set("Point") + "99")
This.lblNeto.Caption  = Transform(This.Neto, "999" + Set("Point") + "99")

This.Refresh()

ENDPROC
PROCEDURE clave_assign
Lparameters tuNewValue
This.clave = tuNewValue

This.lblClave.Caption = This.clave
This.lblCodigo.Caption = This.codigo + "/" + This.clave

ENDPROC
PROCEDURE codigo_assign
Lparameters tuNewValue
This.codigo = tuNewValue

This.lblCodigo.Caption = This.codigo + "/" + This.clave

ENDPROC
PROCEDURE descripcion_assign
Lparameters tuNewValue
This.descripcion = tuNewValue

This.lblDescripcion.Caption = Alltrim(This.descripcion)

ENDPROC
PROCEDURE getnewidcaja
Return "0" + Right(Sys(2015), 9)

ENDPROC
PROCEDURE idcaja_assign
lparameters tuNewValue
This.idcaja = tuNewValue

This.lblIdCaja.Caption = This.idcaja 

ENDPROC
PROCEDURE imprimiretiqueta
*!* ImprimirCopia()

Lparameters pnCopias As Integer

Local ;
	lcCaptionLote, ;
	lcCaptionClave, ;
	lcCaptionOperador, ;
	lcCaptionBruto, ;
	lcCaptionTara, ;
	lcCaptionNeto, ;
	lcCaptionCodigo, ;
	lnMarginTop, ;
	lnMarginLeft, ;
	lnCopias, ;
	lnFieldSize, ;
	lcSerial, ;
	lcLote, ;
	lcPesoBruto, ;
	lcPesoTara, ;
	lcPesoNeto, ;
	lcCodigo, ;
	lcBarra, ;
	lcIdCaja, ;
	lnPrintSerial, ;
	lnLineHeight, ;
	lnLeft, ;
	lnCurrentTop, ;
	lcDataLeft, ;
	lcLeft, ;
	lcTop, ;
	lcText, ;
	lcOperador

m.lcCaptionLote 		= "Lote/Batch"
m.lcCaptionClave 		= "Clave/Key"
m.lcCaptionOperador 	= "Operador/Operator"
m.lcCaptionBruto 		= "Peso Bruto/Gross Weight (Kg)"
m.lcCaptionTara 		= "Tara/Tare Weight (Kg)"
m.lcCaptionNeto 		= "Peso Neto/Net Weight (Kg)"
m.lcCaptionCodigo 		= "Codigo/Code"

m.lnMarginTop 	= Thisform.oRegistry.GetValue("Zebra\txtLabelHomeY", 0)
m.lnMarginLeft 	= Thisform.oRegistry.GetValue("Zebra\txtLabelHomeX", 0)
m.lnFieldSize 	= Thisform.oRegistry.GetValue("Etiqueta\LargoDeCampo", 12)
m.lnBarraLen	= Thisform.oRegistry.GetValue("Etiqueta\LargoDeCodigoDebarra", 21)

If Vartype(m.pnCopias) # "N" Then
	m.lnCopias = Thisform.oRegistry.GetValue("Etiqueta\Copias", 2)
Else
	m.lnCopias = m.pnCopias
Endif

*!*	Thisform.oRegistry.SetValue("Zebra\txtLabelHomeY", m.lnMarginTop)
*!*	Thisform.oRegistry.SetValue("Zebra\txtLabelHomeX", m.lnMarginLeft)
*!*	Thisform.oRegistry.SetValue("Etiqueta\Copias", m.lnCopias)
Thisform.oRegistry.SetValue("Etiqueta\LargoDeCampo", m.lnFieldSize)
Thisform.oRegistry.SetValue("Etiqueta\LargoDeCodigoDebarra", m.lnBarraLen)

m.lcSerial = ""

If Serial # 0 Then
	m.lcSerial 	= Padl(Alltrim(Str(Serial)), 8, "0")
Endif

If Serial2 # 0 Then
	m.lcSerial 	= Padl(Alltrim(Str(Serial2)), 8, "0")
Endif

m.lcLote 		= Padl(Transform(Lote, "999"), 3, "0")
m.lcPesoBruto 	= Padl(Transform(Bruto, "999.99"), m.lnFieldSize, " ")
m.lcPesoTara 	= Padl(Transform(Tara, "999.99"), m.lnFieldSize, " ")
m.lcPesoNeto 	= Padl(Transform(Neto, "999.99"), m.lnFieldSize, " ")
m.lcCodigo 		= Padl(Codigo + "/" + Clave, m.lnFieldSize, " ")
m.lcBarra 		= Left(Alltrim(Barra), m.lnBarraLen)
m.lcIdCaja		= IdCaja

m.lcOperador 	= Codigo1 + "/" ;
	+ Codigo2 + "/" ;
	+ Codigo3 + "/" ;
	+ Codigo4 + "/" ;
	+ Operador

Set Printer To lpt1

If This.Imprimir Then
	Set Printer On
	Set Console Off
Endif

?"^XA"
?"^PRA,A,A"
?"^LH0,0"

*!* This is the line height for font A0N,52,26 and AFN,52,27
m.lnLineHeight = 56
m.lnLeft = 25
m.lnCurrentTop = 15
m.lcDataLeft = "380"

m.lcLeft = Transform(m.lnMarginLeft + m.lnLeft)
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = Alltrim(Nombre)
?"^A0N,105,48^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + 105
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = Alltrim(Descripcion)
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionLote
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

If Empty(m.lcSerial) Then
	m.lcText = Padl(m.lcLote, m.lnFieldSize, " ")
Else
	m.lcText = Padl(m.lcSerial + "/" + m.lcLote, m.lnFieldSize, " ")
Endif

m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionClave
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = Padl(Clave, m.lnFieldSize, " ")
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionOperador
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = Padl(m.lcOperador, m.lnFieldSize, " ")
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionBruto
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = m.lcPesoBruto
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionTara
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = m.lcPesoTara
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionNeto
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = m.lcPesoNeto
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop  = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcText = m.lcCaptionCodigo
?"^ACN,54,10^FO" + m.lcLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

m.lcText = m.lcCodigo
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop - 2)
?"^AEN,56,20^FO"  + m.lcDataLeft + "," + m.lcTop + "^FD" + m.lcText + "^FS"

*!*	m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
*!*	m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop + 10)
*!*	m.lcText = IdCaja
*!*	?"^FO"  + m.lcLeft + "," + m.lcTop + "^ACN,36,10^FD" + m.lcText + "^FS"

m.lnCurrentTop = m.lnCurrentTop + m.lnLineHeight
m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop + 2)
m.lcText = IdCaja
?"^FO"  + m.lcLeft + "," + m.lcTop + "^ACN,54,20^FD" + m.lcText + "^FS"

m.lcTop = Transform(m.lnMarginTop + m.lnCurrentTop)
m.lcLeft = Transform(m.lnMarginLeft + 300)
?"^BY2,3,10"
?"^FO" + m.lcLeft + "," + m.lcTop + "^BCN,48,N,N,N,A^FD" + m.lcText + "^FS"

m.lcLeft = Transform(m.lnMarginLeft + 630)
m.lcTop  = Transform(m.lnMarginTop + 35)

?"^FO" + m.lcLeft + "," + m.lcTop + "^ACN,36,10^BY3^BCB,96,Y,N,N,A^FD" + m.lcBarra + "^FS"
?"^PON"
?"^PQ" + Transform(m.lnCopias)
?"^XZ"

Set Printer Off
Set Printer To


ENDPROC
PROCEDURE lote_assign
Lparameters tuNewValue
This.lote = tuNewValue

Local ;
	m.lcSerial As String, ;
	m.lcLote As String

m.lcSerial = Padl(Alltrim(Str(This.Serial)), 8, "0")
m.lcLote = Padl(Transform(This.lote), 3, "0")

If This.SerialPrn = 1 Then
	This.lblSerialyLote.Caption = m.lcSerial + "." + m.lcLote
Else
	This.lblSerialyLote.Caption = m.lcLote
Endif

ENDPROC
PROCEDURE neto_assign
lparameters tuNewValue
This.neto = m.tuNewValue

ENDPROC
PROCEDURE nombre_assign
Lparameters tuNewValue
This.nombre = tuNewValue

This.lblNombre.Caption = This.nombre

ENDPROC
PROCEDURE operador_assign
lparameters tuNewValue
This.operador = tuNewValue

This.lblOperador.Caption = This.operador


ENDPROC
PROCEDURE serial2_assign
lparameters tuNewValue
This.serial2 = tuNewValue

Local ;
	m.lcSerial As String, ;
	m.lcLote As String

m.lcSerial = ""

If This.SerialPrn = 1 Then
	m.lcSerial 	= Padl(Alltrim(Str(This.serial)), 8, "0")
Endif

If This.Serial2 > 0 Then
	m.lcSerial 	= Padl(Alltrim(Str(This.Serial2)), 8, "0")
Endif

m.lcLote = Padl(Transform(This.lote), 3, "0")

If Empty(m.lcSerial) Then
	This.lblSerialyLote.Caption = m.lcLote
Else
	This.lblSerialyLote.Caption = m.lcSerial + "." + m.lcLote
Endif


ENDPROC
PROCEDURE serial_assign
Lparameters tuNewValue
This.serial = tuNewValue

Local ;
	m.lcSerial As String, ;
	m.lcLote As String

m.lcSerial = ""

If This.SerialPrn = 1 Then
	m.lcSerial 	= Padl(Alltrim(Str(This.serial)), 8, "0")
Endif

If This.Serial2 > 0 Then
	m.lcSerial 	= Padl(Alltrim(Str(This.Serial2)), 8, "0")
Endif

m.lcLote = Padl(Transform(This.lote), 3, "0")

If Not Empty(m.lcSerial) Then
	This.lblSerialyLote.Caption = m.lcSerial + "." + m.lcLote
Else
	This.lblSerialyLote.Caption = m.lcLote
Endif


ENDPROC
PROCEDURE serialinc_assign
lparameters tuNewValue
This.serialinc = tuNewValue

ENDPROC
PROCEDURE serialprn_assign
lparameters tuNewValue
This.serialprn = tuNewValue

Local ;
	m.lcSerial As String, ;
	m.lcLote As String

m.lcSerial = Padl(Alltrim(Str(This.Serial)), 8, "0")
m.lcLote = Padl(Transform(This.lote), 3, "0")

If This.SerialPrn = 1 Then
	This.lblSerialyLote.Caption = m.lcSerial + "." + m.lcLote
Else
	This.lblSerialyLote.Caption = m.lcLote
Endif

ENDPROC
PROCEDURE sys2015
Lparameters tcParam

*The Sys2015 command returns a string of 10 characters.
*The first one is always an underscore '_'
*The following 9 characters are always from the range 0-9 or A-Z.
*The value per char they represent is 0=0, 1=1, ..., 9-9, A=10, B=11, ... , Z=35
*From the first 9 characters, the first 3 characters represent the days,
*the rest represent the (milli)seconds.
*
*The value of the days can be found this way:
*When you have the string of 3 characters, you must convert them from base36 to base10,
*where the MSB is in the first char.
*Unfortenately the century's are not in SYS(2015) so you can only extract the years 00-99.
*Now you have a number of the Days, where:
*Jan 1st '00 = 1
*Jan 2st '00 = 2
*Jan 1st '01 = 368
*etc
*
*You see the years have 367 days with no day 0.
*This way you can find the year and days since jan 1st.
*Because this routine returns a datetime, the century is filled with the century together with rollover.
*If the default VPF Century and Rollover settings are not correct for you, you can supply them to this routine
*by giving them as the 3rd and 4th parameter. (This is optional)
*
*Now the time:
*When you have the string of 6 characters, you must convert them from base36 to base10,
*where the MSB is in the first char.
*Now you have the time in millisecs since midnight.
*Because the datetime cannot return milliseconds, you can get the millisecs of the datetime by using the following syntax:
*nDateTime=CONVERT2015(cSys2015,@nMillisecs)
*nDateTime will have the Datetime, nMillisecs will have the milliSecs of this datetime

Local Array laDigit(9)

Local  lnx, lcDigits, lnDay, lnYear, lnSeconds, lnMilliSeconds

m.lcDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

*!* Convert each char from base36 to base10: '0-9,A-Z' to 0-35
*!* Skip first "_" char
For m.lnx = 1 To 9
	m.laDigit(m.lnx) = At(Substr(m.tcParam, m.lnx + 1, 1), m.lcDigits) - 1
Endfor

*!* Convert the day from BASE36 to BASE10
m.lnDay = m.laDigit(1) * 36^2 + m.laDigit(2) * 36 + m.laDigit(3) 

*!* In the SYS(2015) world, every year has 367 days
m.lnYear = Int(m.lnDay/367)

*!* Add the right century to this year, because SYS(2015) only has years 0-99
m.lnYear = m.lnYear + 2000

*!* Strip the year off, so you only have the days since Jan 1st
m.lnDay = Mod(m.lnDay,367)

*!* Convert the millisecs from BASE36 to BASE10
m.lnSeconds = (m.laDigit(4) * 36^5 + m.laDigit(5) * 36^4 + m.laDigit(6) * 36^3 + m.laDigit(7) * 36^2 + m.laDigit(8) * 36 + m.laDigit(9))

*!* Get the Millisecs from the seconds.
m.lnMilliSeconds = Mod(m.lnSeconds, 1000)

*!* Strip the millisecs from the seconds
m.lnSeconds = Int(m.lnSeconds / 1000)

*!* nDay must be substracted by 1 because nDay = 1 is Jan 1st, not day 0
Return Dtot(Date(m.lnYear, 1, 1) + m.lnDay -1) + m.lnSeconds


ENDPROC
PROCEDURE tara_assign
Lparameters tuNewValue
This.Tara = Round(tuNewValue, 2)

This.Neto = Max(0, This.Bruto - This.Tara)

This.lblBruto.Caption = Transform(This.Bruto, "999" + Set("Point") + "99")
This.lblTara.Caption  = Transform(This.Tara, "999" + Set("Point") + "99")
This.lblNeto.Caption  = Transform(This.Neto, "999" + Set("Point") + "99")

This.Refresh()

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
18[END RESERVED2]
[START RESERVED3]
*addlabel 
*barra_assign 
*bruto_assign 
*clave_assign 
*codigo_assign 
*descripcion_assign 
*getnewidcaja 
*idcaja_assign 
*imprimiretiqueta 
*lote_assign 
*neto_assign 
*newidcaja 
*nombre_assign 
*operador_assign 
*printlabel 
*serial2_assign 
*serial_assign 
*serialinc_assign 
*serialprn_assign 
*sys2015 
*tara_assign 
_memberdata XML Metadata for customizable properties
barra
bruto
clave
codigo
descripcion
fecha
guid_stock
idcaja
imprimir
lote
neto
nombre
operador
padsize
serial
serial2
serialinc
serialprn
tara
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM05
[CLASS] label
[BASECLASS] label
[OBJNAME] Label1
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Lote"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label1"
TabIndex = 7
Top = 93
Width = 53
ZOrderSet = 2
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM07
[CLASS] label
[BASECLASS] label
[OBJNAME] Label2
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Clave"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label2"
TabIndex = 8
Top = 133
Width = 65
ZOrderSet = 3
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM08
[CLASS] label
[BASECLASS] label
[OBJNAME] Label3
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Operador"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label3"
TabIndex = 9
Top = 173
Width = 114
ZOrderSet = 4
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM09
[CLASS] label
[BASECLASS] label
[OBJNAME] Label4
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Peso Bruto (Kg)"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label4"
TabIndex = 10
Top = 213
Width = 190
ZOrderSet = 5
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0A
[CLASS] label
[BASECLASS] label
[OBJNAME] Label5
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Tara (Kg)"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label5"
TabIndex = 11
Top = 253
Width = 115
ZOrderSet = 6
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0B
[CLASS] label
[BASECLASS] label
[OBJNAME] Label6
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Peso Neto (Kg)"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label6"
TabIndex = 12
Top = 293
Width = 181
ZOrderSet = 7
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0C
[CLASS] label
[BASECLASS] label
[OBJNAME] Label7
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "Codigo"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "Label7"
TabIndex = 13
Top = 333
Width = 84
ZOrderSet = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0J
[CLASS] label
[BASECLASS] label
[OBJNAME] lblBruto
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "000.00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 477
Name = "lblBruto"
TabIndex = 19
Top = 214
Width = 134
ZOrderSet = 14
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0H
[CLASS] label
[BASECLASS] label
[OBJNAME] lblClave
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 345
Name = "lblClave"
TabIndex = 17
Top = 134
Width = 266
ZOrderSet = 12
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0M
[CLASS] label
[BASECLASS] label
[OBJNAME] lblCodigo
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "0000/00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 455
Name = "lblCodigo"
TabIndex = 22
Top = 334
Width = 156
ZOrderSet = 17
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0E
[CLASS] label
[BASECLASS] label
[OBJNAME] lblDescripcion
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "-"
FontName = "Tahoma"
FontSize = 20
Height = 35
Left = 21
Name = "lblDescripcion"
TabIndex = 14
Top = 58
Width = 594
ZOrderSet = 9
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0D
[CLASS] label
[BASECLASS] label
[OBJNAME] lblIdCaja
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "0000000000"
FontName = "Consolas"
FontSize = 14
Height = 24
Left = 21
Name = "lblIdCaja"
TabIndex = 13
Top = 378
Width = 102
ZOrderSet = 8
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0L
[CLASS] label
[BASECLASS] label
[OBJNAME] lblNeto
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "000.00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 477
Name = "lblNeto"
TabIndex = 21
Top = 294
Width = 134
ZOrderSet = 16
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0F
[CLASS] label
[BASECLASS] label
[OBJNAME] lblNombre
[PARENT] etiqueta
[START PROPERTIES]
Anchor = 3
BackColor = 255,255,255
Caption = "-"
FontBold = .T.
FontName = "Tahoma"
FontSize = 32
Height = 54
Left = 21
Name = "lblNombre"
TabIndex = 15
Top = 8
Width = 594
ZOrderSet = 10
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0I
[CLASS] label
[BASECLASS] label
[OBJNAME] lblOperador
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "00/0/0/0/00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 345
Name = "lblOperador"
TabIndex = 18
Top = 174
Width = 266
ZOrderSet = 13
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0G
[CLASS] label
[BASECLASS] label
[OBJNAME] lblSerialyLote
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "00000000/000"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 105
Name = "lblSerialyLote"
TabIndex = 16
Top = 94
Width = 506
ZOrderSet = 11
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2D411MM0K
[CLASS] label
[BASECLASS] label
[OBJNAME] lblTara
[PARENT] etiqueta
[START PROPERTIES]
Alignment = 1
Anchor = 3
BackColor = 255,255,255
Caption = "000.00"
FontName = "Lucida console"
FontSize = 28
Height = 39
Left = 477
Name = "lblTara"
TabIndex = 20
Top = 254
Width = 134
ZOrderSet = 15
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] etiqueta
[EOF]
