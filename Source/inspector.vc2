*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="inspector.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cntbackreference AS cntgenericpage OF "inspector.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblBackLink" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: gotoreferencednode
	*</DefinedPropArrayMethod>

	Name = "cntbackreference"
	_memberdata = <VFPData>
		<memberdata name="gotoreferencednode" display="GoToReferencedNode"/>
		</VFPData>

	ADD OBJECT 'lblBackLink' AS label WITH ;
		AutoSize = .T., ;
		Caption = "This item is listed elsewhere in the hierarchy. Click here to jump to that node.", ;
		FontUnderline = .T., ;
		ForeColor = 0,0,255, ;
		Height = 17, ;
		Left = 14, ;
		Name = "lblBackLink", ;
		Top = 14, ;
		Width = 421
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE gotoreferencednode
		* Go to the node that this object refers to.
		
		LOCAL cParentKey
		
		cParentKey = ThisForm.GetKeyForCurrentNodeRefID()
		ThisForm.ExpandAllParents(m.cParentKey)
		ThisForm.oTreeViewContainer.SelectNode(m.cParentKey)
		
		RETURN
		
		
	ENDPROC

	PROCEDURE lblBackLink.Click
		This.Parent.GoToReferencedNode()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntcollectioninfo AS cntgenericpage OF "inspector.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdProperties" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox4" UniqueID="" Timestamp="" />

	Height = 305
	Name = "cntcollectioninfo"
	Width = 461

	ADD OBJECT 'grdProperties' AS grdproperties WITH ;
		Height = 248, ;
		Left = 6, ;
		Name = "grdProperties", ;
		Top = 34, ;
		Width = 449, ;
		grcProperty.hdrProperty.Name = "hdrProperty", ;
		grcProperty.Name = "grcProperty", ;
		grcProperty.txtProperty.Name = "txtProperty", ;
		grcType.hdrType.Name = "hdrType", ;
		grcType.Name = "grcType", ;
		grcType.txtType.Name = "txtType", ;
		grcValue.edtValue.Name = "edtValue", ;
		grcValue.hdrValue.Name = "hdrValue", ;
		grcValue.Name = "grcValue"
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="grid" />

	ADD OBJECT 'lblCount' AS sflabel WITH ;
		Caption = "Item Count", ;
		Left = 14, ;
		Name = "lblCount", ;
		Top = 8
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="label" />

	ADD OBJECT 'Objectfiltercheckbox1' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Native", ;
		ControlSource = "Thisform.lShowNative", ;
		Left = 22, ;
		Name = "Objectfiltercheckbox1", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox2' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited", ;
		ControlSource = "Thisform.lShowInherited", ;
		Left = 104, ;
		Name = "Objectfiltercheckbox2", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox3' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Custom", ;
		ControlSource = "Thisform.lShowCustom", ;
		Left = 202, ;
		Name = "Objectfiltercheckbox3", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox4' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Non-Default Only", ;
		ControlSource = "Thisform.lShowNonDefault", ;
		Left = 301, ;
		Name = "Objectfiltercheckbox4", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'txtCount' AS sftextbox WITH ;
		Left = 86, ;
		Name = "txtCount", ;
		ReadOnly = .T., ;
		Top = 4
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="textbox" />
	
	PROCEDURE Refresh
		DODEFAULT()
		
		IF NOT ISNULL(This.oCurrentObject)
			This.txtCount.Value = This.oCurrentObject.Count
		
			This.grdProperties.FillPropertyCursor(This.oCurrentObject)
		ENDIF
		
		RETURN
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntgenericpage AS sfcontainer OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: parseid		&& Parse the ID for the current item to build a reference to it
		*p: ocurrentobject		&& The object currently being displayed on this page
	*</DefinedPropArrayMethod>

	Height = 305
	Name = "cntgenericpage"
	ocurrentobject = .NULL.		&& The object currently being displayed on this page
	Width = 461
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="parseid" type="method" display="ParseID"/>
		<memberdata name="ocurrentobject" type="property" display="oCurrentObject"/>
		</VFPData>
	
	PROCEDURE parseid		&& Parse the ID for the current item to build a reference to it
		* Parse the ID for the current item, and return a
		* reference to the item.
		
		LOCAL aLevels[1], nLevels, nLevel, cHierarchy, oObject
		
		nLevels = ALINES(m.aLevels, ThisForm.cCurrentNodeID, "/")
		
		cHierarchy = "ThisForm.oRoot"
		
		FOR nLevel = 2 TO m.nLevels
			IF LEFT(aLevels[m.nLevel], 1) = "#"
				* It's an item in the current collection
				* Modified 7-June-2010 by TEG
				* Use the long form in case we have collections in collections
				cHierarchy = m.cHierarchy + ".Item[" + SUBSTR(aLevels[m.nLevel], 2) + "]"
			ELSE
				* It's a property of the current object
				cHierarchy = m.cHierarchy + "." + ALLTRIM(aLevels[m.nLevel])
			ENDIF
		ENDFOR
		
		TRY
			oObject = EVALUATE(m.cHierarchy)
		CATCH
			oObject = .null.
		ENDTRY
		
		RETURN m.oObject
		
	ENDPROC

	PROCEDURE Refresh
		This.oCurrentObject = This.ParseID()
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntobjectinfo AS cntgenericpage OF "inspector.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdProperties" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Objectfiltercheckbox4" UniqueID="" Timestamp="" />

	Name = "cntobjectinfo"
	_memberdata = <VFPData>

		</VFPData>

	ADD OBJECT 'grdProperties' AS grdproperties WITH ;
		Height = 276, ;
		Left = 6, ;
		Name = "grdProperties", ;
		Top = 6, ;
		Width = 449, ;
		grcProperty.hdrProperty.Name = "hdrProperty", ;
		grcProperty.Name = "grcProperty", ;
		grcProperty.txtProperty.Name = "txtProperty", ;
		grcType.hdrType.Name = "hdrType", ;
		grcType.Name = "grcType", ;
		grcType.txtType.Name = "txtType", ;
		grcValue.edtValue.Name = "edtValue", ;
		grcValue.hdrValue.Name = "hdrValue", ;
		grcValue.Name = "grcValue"
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="grid" />

	ADD OBJECT 'Objectfiltercheckbox1' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Native", ;
		ControlSource = "Thisform.lShowNative", ;
		Left = 22, ;
		Name = "Objectfiltercheckbox1", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox2' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Inherited", ;
		ControlSource = "Thisform.lShowInherited", ;
		Left = 104, ;
		Name = "Objectfiltercheckbox2", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox3' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Custom", ;
		ControlSource = "Thisform.lShowCustom", ;
		Left = 202, ;
		Name = "Objectfiltercheckbox3", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Objectfiltercheckbox4' AS objectfiltercheckbox WITH ;
		Alignment = 0, ;
		Caption = "Non-Default Only", ;
		ControlSource = "Thisform.lShowNonDefault", ;
		Left = 301, ;
		Name = "Objectfiltercheckbox4", ;
		Top = 286
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="checkbox" />
	
	PROCEDURE Refresh
		DODEFAULT()
		
		IF NOT ISNULL(This.oCurrentObject)
			This.grdProperties.FillPropertyCursor(This.oCurrentObject)
		ENDIF
		
		RETURN
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntscalar AS cntgenericpage OF "inspector.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtValue" UniqueID="" Timestamp="" />

	Name = "cntscalar"

	ADD OBJECT 'lblType' AS sflabel WITH ;
		Caption = "Type", ;
		Left = 14, ;
		Name = "lblType", ;
		Top = 16
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="label" />

	ADD OBJECT 'lblValue' AS sflabel WITH ;
		Caption = "Value", ;
		Left = 14, ;
		Name = "lblValue", ;
		Top = 48
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="label" />

	ADD OBJECT 'txtType' AS sftextbox WITH ;
		Height = 22, ;
		Left = 52, ;
		Name = "txtType", ;
		ReadOnly = .T., ;
		Top = 13, ;
		Width = 27
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtValue' AS sfeditbox WITH ;
		Height = 246, ;
		Left = 52, ;
		Name = "txtValue", ;
		ReadOnly = .T., ;
		Top = 45, ;
		Width = 394
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="editbox" />
	
	PROCEDURE Refresh
		* This.oCurrentObject here isn't really an object. It's 
		* just a value.
		
		DODEFAULT()
		
		IF NOT ISNULL(This.oCurrentObject)
			LOCAL cType, cValue
		
			cType = VARTYPE(This.oCurrentObject)
			IF m.cType = "C"
				cValue = This.oCurrentObject
			ELSE 
				cValue = TRANSFORM(This.oCurrentObject)
			ENDIF 
		
			This.txtType.Value = m.cType
			This.txtValue.Value = m.cValue
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS edtdynamictooltip AS sfeditbox OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: tooltiptext_access
	*</DefinedPropArrayMethod>

	BorderStyle = 0
	czoomformcaption = Zoom Property Value
	lcanzoom = .T.
	Name = "edtdynamictooltip"
	ToolTipText = ""
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="czoomclass" type="property" display="cZoomClass" favorites="True"/>
		<memberdata name="czoomformcaption" type="property" display="cZoomFormCaption" favorites="True"/>
		<memberdata name="czoomlibrary" type="property" display="cZoomLibrary" favorites="True"/>
		<memberdata name="lcanchangefont" type="property" display="lCanChangeFont" favorites="True"/>
		<memberdata name="lcanfind" type="property" display="lCanFind" favorites="True"/>
		<memberdata name="lcanzoom" type="property" display="lCanZoom" favorites="True"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="selectfont" type="method" display="SelectFont"/>
		<memberdata name="setzoomformproperties" type="method" display="SetZoomFormProperties" favorites="True"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="zoom" type="method" display="Zoom"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="tooltiptext" type="property" display="ToolTipText"/>
		<memberdata name="tooltiptext_access" type="method" display="ToolTipText_Access"/>
		</VFPData>
	
	PROCEDURE DblClick
		IF This.lCanZoom
			This.Zoom()
		ENDIF 
	ENDPROC

	PROCEDURE KeyPress
		lparameters nKeyCode,  nShiftAltCtrl
		
		* Modified 16-June-2010 by TEG
		* Navigate on arrow keys. Code courtesy of Martina Jindrova
		
		  IF nKeyCode=5 AND nShiftAltCtrl=0
		     KEYB "{BACKTAB}{UPARROW}{TAB}" PLAIN CLEAR
		     NODEFAULT
		     RETURN
		  ENDIF
		
		  IF nKeyCode=24 AND nShiftAltCtrl=0
		     KEYB "{BACKTAB}{DNARROW}{TAB}" PLAIN CLEAR
		     NODEFAULT
		     RETURN
		  ENDIF
		
		  IF nKeyCode=18 AND nShiftAltCtrl=0
		     KEYB "{BACKTAB}{PGUP}{TAB}" PLAIN CLEAR
		     NODEFAULT
		     RETURN
		  ENDIF
		
		  IF nKeyCode=3 AND nShiftAltCtrl=0
		     KEYB "{BACKTAB}{PGDN}{TAB}" PLAIN CLEAR
		     NODEFAULT
		     RETURN
		  ENDIF
		
		  IF nKeyCode=19 AND nShiftAltCtrl=0
		     IF This.SelStart=0
		        KEYB "{BACKTAB}" PLAIN CLEAR
		        NODEFAULT
		        RETURN
		     ENDIF
		  ENDIF
		
		  IF nKeyCode=4 AND nShiftAltCtrl=0
		     IF This.SelStart=LEN(LTRIM(This.Text))-1
		        KEYB "{TAB}" PLAIN CLEAR
		        NODEFAULT
		        RETURN
		     ENDIF
		  ENDIF
		
		DODEFAULT(nKeyCode,  nShiftAltCtrl)
	ENDPROC

	PROCEDURE setzoomformproperties
		lparameters toForm
		
		DODEFAULT(m.toForm)
		
		toForm.edtZoom.ReadOnly = .T.
	ENDPROC

	PROCEDURE tooltiptext_access
		LOCAL nRow, nCol
		LOCAL nGridComp, nRelRow, nRelCol
		LOCAL cTip
		
		nRow = MROW(_screen.ActiveForm.Name, 3)
		nCol = MCOL(_screen.ActiveForm.Name, 3)
		
		This.Parent.Parent.GridHitTest(m.nCol, m.nRow, @nGridComp, @nRelRow, @nRelCol)
		
		* Activate the relevant cell
		This.Parent.Parent.ActivateCell(m.nRelRow, m.nRelCol)
		cTip = This.Value
		
		return m.cTip
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmgrabfocus AS form 		&& Dummy form used to remove focus from main form.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata
	*</DefinedPropArrayMethod>

	Caption = "Dummy"
	DoCreate = .T.
	Height = 55
	Left = 0
	Name = "frmDummy"
	ShowWindow = 1
	Top = 0
	Width = 165
	_memberdata = <VFPData>

		</VFPData>

	ADD OBJECT 'Text1' AS textbox WITH ;
		Height = 23, ;
		Left = 12, ;
		Name = "Text1", ;
		Top = 12
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE

DEFINE CLASS grdproperties AS sfgrid OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grcProperty.hdrProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grcProperty.txtProperty" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grcType.hdrType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grcType.txtType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grcValue.hdrValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grcValue.edtValue" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: createpropertycursor		&& Create a cursor to hold the properties shown in this grid.
		*m: fillpropertycursor		&& Fill the property cursor with the property info for a specific object.
		*m: resizecolumnwidths
		*m: savecolumnwidths
		*m: tooltiptext_access
		*p: ccursoralias		&& Alias for the underlying cursor for this grid.
		*p: lresizingincode		&& Indicates whether a resizing operation was started by code or by the user.
		*p: ninitialwidth		&& Grid initial width
		*p: oobject		&& Reference to the object whose properties are currently displayed
		*a: ainitialcolumnwidths[3,0]
	*</DefinedPropArrayMethod>

	ccursoralias = 		&& Alias for the underlying cursor for this grid.
	ColumnCount = 3
	DeleteMark = .F.
	GridLineColor = 192,192,192
	Height = 300
	lresizingincode = .F.		&& Indicates whether a resizing operation was started by code or by the user.
	Name = "grdproperties"
	ninitialwidth = 0		&& Grid initial width
	oobject = .NULL.		&& Reference to the object whose properties are currently displayed
	Panel = 1
	ReadOnly = .T.
	RecordMark = .F.
	RowHeight = 25
	ToolTipText = ""
	Width = 440
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="getcaption" type="method" display="GetCaption"/>
		<memberdata name="lautofit" type="property" display="lAutoFit" favorites="True"/>
		<memberdata name="lautosetup" type="property" display="lAutoSetup" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu"/>
		<memberdata name="nbackcolor" type="property" display="nBackColor"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setupcolumns" type="method" display="SetupColumns"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="fillpropertycursor" type="method" display="FillPropertyCursor"/>
		<memberdata name="createpropertycursor" type="method" display="CreatePropertyCursor"/>
		<memberdata name="ccursoralias" type="property" display="cCursorAlias"/>
		<memberdata name="ainitialcolumnwidths" type="property" display="aInitialColumnWidths"/>
		<memberdata name="ninitialwidth" type="property" display="nInitialWidth"/>
		<memberdata name="lresizingincode" type="property" display="lResizingInCode"/>
		<memberdata name="savecolumnwidths" type="method" display="SaveColumnWidths"/>
		<memberdata name="oobject" type="property" display="oObject"/>
		<memberdata name="tooltiptext" type="property" display="ToolTipText"/>
		<memberdata name="tooltiptext_access" type="method" display="ToolTipText_Access"/>
		<memberdata name="resizecolumnwidths" display="ResizeColumnWidths"/>
		<memberdata name="gridlinecolor" display="GridLineColor"/>
		</VFPData>
	Column1.CurrentControl = "txtProperty"
	Column1.DynamicFontBold = "NonDefault"
	Column1.DynamicFontItalic = "ReadOnly"
	Column1.Name = "grcProperty"
	Column1.ReadOnly = .T.
	Column1.Width = 142
	Column2.Alignment = 2
	Column2.DynamicFontBold = "NonDefault"
	Column2.DynamicFontItalic = "ReadOnly"
	Column2.Name = "grcType"
	Column2.ReadOnly = .T.
	Column2.Width = 36
	Column3.CurrentControl = "edtValue"
	Column3.DynamicFontBold = "NonDefault"
	Column3.DynamicFontItalic = "ReadOnly"
	Column3.Name = "grcValue"
	Column3.ReadOnly = .T.
	Column3.Sparse = .F.
	Column3.Width = 231

	ADD OBJECT 'grcProperty.hdrProperty' AS header WITH ;
		Caption = "Property", ;
		Name = "hdrProperty"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grcProperty.txtProperty' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "txtProperty", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grcType.hdrType' AS header WITH ;
		Alignment = 2, ;
		Caption = "Type", ;
		Name = "hdrType"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grcType.txtType' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "txtType", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grcValue.edtValue' AS edtdynamictooltip WITH ;
		Name = "edtValue"
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="editbox" />

	ADD OBJECT 'grcValue.hdrValue' AS header WITH ;
		Caption = "Value", ;
		Name = "hdrValue"
		*< END OBJECT: BaseClass="header" />
	
	PROCEDURE createpropertycursor		&& Create a cursor to hold the properties shown in this grid.
		IF EMPTY(This.cCursorAlias)
			This.cCursorAlias = "csr" + SYS(2015)
			DO WHILE USED(This.cCursorAlias)
				This.cCursorAlias = "csr" + SYS(2015)
			ENDDO 
		ENDIF
		
		*!*	DEBUGOUT "Property cursor for page " + This.Parent.Name + " is " + This.cCursorAlias
		CREATE CURSOR (This.cCursorAlias) ;
			(cProperty C(200), cType C(1), mValue M, ReadOnly L, NonDefault L)
			
			
		* Set up grid to use it
		This.RecordSource = This.cCursorAlias
		
		* This.Columns[3].ControlSource = "mValue"
	ENDPROC

	PROCEDURE fillpropertycursor		&& Fill the property cursor with the property info for a specific object.
		Lparameters oObject
		
		* Fill the property cursor, emptying it first if necessary
		
		Local llNonDefault, llReadOnly, loException
		Local aProps[1], cPropName, cType, cValue, nProp, nPropCount
		If Reccount(This.cCursorAlias) > 0
			Zap In (This.cCursorAlias)
		Endif
		
		
		This.oObject = m.oObject
		
		If Not Isnull(m.oObject)
			nPropCount = Amembers(aProps, m.oObject, 0)
			For nProp = 1 To m.nPropCount
				cPropName = aProps[m.nProp]
		
				If Thisform.lShowNonDefault And Not Pemstatus(m.oObject, m.cPropName, 0)
					Loop
				Endif
		
				If Icase(Pemstatus(m.oObject, m.cPropName, 4) = .F., Thisform.lShowNative,		;
						  Pemstatus(m.oObject, m.cPropName, 6), Thisform.lShowInherited,		;
						  Thisform.lShowCustom)
		
					Try
						cType = Type('oObject.' + cPropName)
					Catch To loException
						cType = 'U'
					Endtry
		
					llNonDefault = Pemstatus(m.oObject, m.cPropName, 0)
					llReadOnly	 = Pemstatus(m.oObject, m.cPropName, 1)
					Do Case
						Case Evl(m.cType, 'U') = 'U'
							cValue	   = '<Property could not be evaluated>'
							Try
								If IsNull(Evaluate('oObject.' + cPropName)) 
									cValue = '.NULL.'
									cType  = 'X'
								EndIf 
							Catch
							EndTry
							llReadOnly = .T.
						Case Type('oObject.' + cPropName, 1) = 'A'
							cValue	   = '<Array>'
							llReadOnly = .T.
							If Evaluate('Alen(oObject.' + cPropName + ', 2)') = 0
								cPropName = m.cPropName + '[' + Transform(Evaluate('Alen(oObject.' + cPropName + ')')) + ']'
							Else
								cPropName = m.cPropName + '[' + Transform(Evaluate('Alen(oObject.' + cPropName + ',1)')) ;
									+ ', ' + Transform(Evaluate('Alen(oObject.' + cPropName + ',2)')) + ']'
							Endif
						Case Evl(m.cType, 'U') = 'O'
							If PemStatus(Evaluate('oObject.' + cPropName), 'BaseClass', 5)
								cValue = '<' + Evaluate('oObject.' + cPropName +  '.BaseClass') + ' object>'
							Else 
								cValue = '<Object>'
							EndIf 
								llReadOnly = .T.
						Otherwise
							cValue = Transform(Evaluate('oObject.' + cPropName))
					Endcase
		
					Insert Into (This.cCursorAlias)			;
						Values (Thisform.SpellKeyword(m.cPropName), m.cType, m.cValue, llReadOnly, llNonDefault)
				Endif
			Endfor
		Endif
		
		Go Top In (This.cCursorAlias)
		
		Return
		
		
	ENDPROC

	PROCEDURE Init
		Local lnRowHeight
		DoDefault()
		
		This.SaveColumnWidths()
		
		This.CreatePropertyCursor()
		Thisform.ShowTips = .T.
		
		Return
		
	ENDPROC

	PROCEDURE Refresh
		Local lnRowHeight
		lnRowHeight = Nvl(Thisform.nGridRowHeight, 0)
		If lnRowHeight = -1 Or lnRowHeight >= 12
			This.RowHeight = lnRowHeight
		Endif
		
	ENDPROC

	PROCEDURE Resize
		This.ResizeColumnWidths()
		This.SaveColumnWidths()
		
	ENDPROC

	PROCEDURE resizecolumnwidths
		* Adjust the column sizes
		LOCAL nRatio, nColumn
		
		This.lResizingInCode = .T.
		
		*!* * Removed 11/30/2011 -- only change the last column
		*!* nRatio = This.Width/This.nInitialWidth
		
		*!* FOR nColumn = 1 TO 3
		*!* 	This.Columns[m.nColumn].Width = INT(This.aInitialColumnWidths[m.nColumn] * m.nRatio)
		*!* ENDFOR 
		
		This.Columns[3].Width = This.Width - This.Columns[1].Width - This.Columns[2].Width - Sysmetric(5) - 8
		
		This.lResizingInCode = .F.
	ENDPROC

	PROCEDURE savecolumnwidths
		* Save the column widths
		LOCAL nColumn
		FOR nColumn = 1 TO 3
			This.aInitialColumnWidths[m.nColumn] = This.Columns[m.nColumn].Width
		ENDFOR 
		This.nInitialWidth = This.Width
		
	ENDPROC

	PROCEDURE tooltiptext_access
		* Look up the tooltip for the object currently under the mouse.
		LOCAL cToolTip, aMousePos[1], oColumn, oControl
		
		cToolTip = ""
		
		IF AMOUSEOBJ(aMousePos) > 0
			oColumn = aMousePos[1]
			IF NOT ISNULL(m.oColumn) AND UPPER(oColumn.BaseClass) = "COLUMN"
				* First, grab column-level tip in case we don't find something below
				cToolTip = oColumn.ToolTipText
				
				* Now, look for the right control. Given the way we construct
				* these grids, it should be the last control.
				IF oColumn.Objects.Count > 0
					oControl = oColumn.Objects[oColumn.Objects.Count]
					IF NOT EMPTY(oControl.ToolTipText) OR PEMSTATUS(m.oControl, "ToolTipText_Access", 5)
						cToolTip = oControl.ToolTipText
					ENDIF
				ENDIF 
			ENDIF 
		ENDIF 
		
		return m.cToolTip
		
	ENDPROC

	PROCEDURE grcProperty.Resize
		IF NOT This.Parent.lResizingInCode
			* The test above may not be needed, but JIC
			This.Parent.ResizeColumnWidths()
			This.Parent.SaveColumnWidths()
		ENDIF 
	ENDPROC

	PROCEDURE grcProperty.txtProperty.DblClick
		ThisForm.JumpToItem(ALLTRIM(This.Value))
		
		
	ENDPROC

	PROCEDURE grcProperty.txtProperty.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		IF m.nKeyCode = 13
			ThisForm.JumpToItem(ALLTRIM(This.Value))
			NODEFAULT 
		ENDIF 
	ENDPROC

	PROCEDURE grcType.Resize
		IF NOT This.Parent.lResizingInCode
			* The test above may not be needed, but JIC
			This.Parent.ResizeColumnWidths()
			This.Parent.SaveColumnWidths()
		ENDIF 
	ENDPROC

	PROCEDURE grcValue.edtValue.DblClick
		Local lcAlias, lcProperty, lcType, lcValue, llReadOnly, loCurrentObject, loException, lxValue
		
		lcAlias			= This.Parent.Parent.RecordSource
		lcProperty		= Alltrim(Evaluate(lcAlias + '.cProperty'))
		
		If Evaluate(lcAlias + '.cType') = 'O'
			Thisform.JumpToItem(lcProperty)
			Return
		EndIf
		
		loCurrentObject	= This.Parent.Parent.Parent.oCurrentObject
		lcType			= Vartype(Getpem(loCurrentObject, lcProperty))
		llReadOnly		= Evaluate(lcAlias + '.ReadOnly') Or Not lcType $ 'CNL'
		
		This.Zoom(llReadOnly)
		
		If llReadOnly
			Return
		Endif
		
		lcValue = This.Value
		Do Case
			Case Left(lcValue, 1) = '='
				Try
					lxValue	= Eval(Substr(lcValue, 2))
					lcValue	= Transform(lxValue)
					lcType	= Vartype(lxValue)
				Catch To loException
		
				Endtry
			Case lcType = 'N'
				lxValue = Val(lcValue)
			Case lcType = 'L'
				lxValue = '.T.' $ Upper(lcValue)
			Otherwise
				lxValue = lcValue
		Endcase
		
		Try
			loCurrentObject.&lcProperty = lxValue
			Replace								;
					mValue	With  lcValue		;
					cType	With  lcType		;
				In (lcAlias)
		Catch To loException
			Messagebox('Unable to change ' + lcProperty + Chr[13] + Chr[13] + loException.Message, 16)
		Endtry
		
		
	ENDPROC

	PROCEDURE grcValue.edtValue.setzoomformproperties
		lparameters toForm
		
		LOCAL cPropName
		
		STORE EVALUATE(This.Parent.Parent.cCursorAlias + ".cProperty") to m.cPropName
		
		toForm.Caption = "Zoom " + m.cPropName
		
		RETURN
		
	ENDPROC

	PROCEDURE grcValue.Resize
		IF NOT This.Parent.lResizingInCode
			* The test above may not be needed, but JIC
			This.Parent.SaveColumnWidths()
		ENDIF 
	ENDPROC

ENDDEFINE

DEFINE CLASS inspector AS sfexplorerformtreeview OF "sfexplorer.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties.sfpage1.cntCollectionInfo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties.Sfpage2.cntObjectInfo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties.Sfpage3.cntScalar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfProperties.Sfpage4.cntBackFeference" UniqueID="" Timestamp="" />

	#INCLUDE "inspectorversion.h"
	*<DefinedPropArrayMethod>
		*m: addcollectionmemberstotreeviewcursor
		*m: addcollectionpropertytotreeviewcursor		&& Add a property that contains a collection to the treeview cursor, and then add its members.
		*m: addobjectpropertytotreeviewcursor		&& Add an object property to the treeview cursor, so it can be used for drilldown
		*m: addtoitemsvisited		&& Add an item to the collection of items visited
		*m: expandallparents		&& Expand all parents of the node with the specified key.
		*m: findobjectpropertiesfortreeviewcursor		&& Look through an object to find any properties that are objects or collections, so they can be added to the treeview cursor.
		*m: getkeyforcurrentnoderefid		&& Return the key for the node referenced by the current node's RefID field.
		*m: goback		&& Go back to the previously chosen item in the tree
		*m: jumptoitem		&& Jump to the child of the current item with the specified name.
		*m: laddkeys_assign
		*m: logit		&& Write the string passed in to a log file
		*m: read_vfp_keywords
		*m: refreshtree		&& Refresh the data in the treeview
		*m: spellkeyword
		*m: stackisempty		&& Returns a value to indicate whether the stack of past actions is empty
		*p: clogfile		&& Filename for log file
		*p: crootname		&& Variable name for collection
		*p: laddkeys		&& Indicates whether the ItemsVisited collection should add keys to the objects it sees, in order to speed up collection of data.
		*p: lshowcustom
		*p: lshowinherited
		*p: lshownative
		*p: lshownondefault
		*p: ngridrowheight
		*p: nsavedheight
		*p: oitemsvisited		&& Collection of items already visited in walking the object hierarchy
		*p: oroot		&& Object to display
		*p: osettings
	*</DefinedPropArrayMethod>

	Caption = "Object and Collection Inspector"
	clogfile = (forcepath("Inspector.Log", sys(2023)))		&& Filename for log file
	crootname = 		&& Variable name for collection
	ctoolbarclass = tbrInspector
	ctoolbarlibrary = Inspector.VCX
	DoCreate = .T.
	Height = 330
	Icon = graphics\binoculr.ico
	laddkeys = .T.		&& Indicates whether the ItemsVisited collection should add keys to the objects it sees, in order to speed up collection of data.
	lshowcustom = .T.
	lshowinherited = .T.
	lshownative = .T.
	lshownondefault = .F.
	Name = "inspector"
	ngridrowheight = 25
	ninitialwidth = 750
	nsavedheight = 0
	oitemsvisited = .NULL.		&& Collection of items already visited in walking the object hierarchy
	oroot = 		&& Object to display
	osettings = .NULL.
	ShowWindow = 2
	Width = 750
	_memberdata = <VFPData>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="ctoolbarclass" type="property" display="cToolbarClass"/>
		<memberdata name="ctoolbarlibrary" type="property" display="cToolbarLibrary"/>
		<memberdata name="nsplitterleft" type="property" display="nSplitterLeft"/>
		<memberdata name="otoolbar" type="property" display="oToolbar"/>
		<memberdata name="updatestatepanel" type="method" display="UpdateStatePanel"/>
		<memberdata name="updateprogressbar" type="method" display="UpdateProgressBar"/>
		<memberdata name="nstatepanelwidth" type="property" display="nStatePanelWidth"/>
		<memberdata name="lstatepanelautosize" type="property" display="lStatePanelAutoSize"/>
		<memberdata name="cstatepanelname" type="property" display="cStatePanelName"/>
		<memberdata name="hideprogressbar" type="method" display="HideProgressBar"/>
		<memberdata name="setupstatusbar" type="method" display="SetupStatusBar"/>
		<memberdata name="restoreformsize" type="method" display="RestoreFormSize"/>
		<memberdata name="updatemessagepanel" type="method" display="UpdateMessagePanel"/>
		<memberdata name="saveformsize" type="method" display="SaveFormSize"/>
		<memberdata name="cdefaultstatemessage" type="property" display="cDefaultStateMessage"/>
		<memberdata name="displayproperties" type="method" display="DisplayProperties"/>
		<memberdata name="ccurrentnodeid" type="property" display="cCurrentNodeID"/>
		<memberdata name="ccurrentnodekey" type="property" display="cCurrentNodeKey"/>
		<memberdata name="ccurrentnodetype" type="property" display="cCurrentNodeType"/>
		<memberdata name="cstateiconready" type="property" display="cStateIconReady"/>
		<memberdata name="cstateiconbusy" type="property" display="cStateIconBusy"/>
		<memberdata name="statusbarclick" type="method" display="StatusBarClick"/>
		<memberdata name="cgobackicon" type="property" display="cGoBackIcon"/>
		<memberdata name="luseformfont" type="property" display="lUseFormFont"/>
		<memberdata name="addcollectionmemberstotreeviewcursor" type="method" display="AddCollectionMembersToTreeViewCursor"/>
		<memberdata name="addcollectionpropertytotreeviewcursor" type="method" display="AddCollectionPropertyToTreeViewCursor"/>
		<memberdata name="oroot" type="property" display="oRoot"/>
		<memberdata name="crootname" type="property" display="cRootName"/>
		<memberdata name="findobjectpropertiesfortreeviewcursor" type="method" display="FindObjectPropertiesForTreeViewCursor"/>
		<memberdata name="addobjectpropertytotreeviewcursor" type="method" display="AddObjectPropertyToTreeViewCursor"/>
		<memberdata name="oitemsvisited" type="property" display="oItemsVisited"/>
		<memberdata name="addtoitemsvisited" type="method" display="AddToItemsVisited"/>
		<memberdata name="logit" type="method" display="LogIt"/>
		<memberdata name="clogfile" type="property" display="cLogFile"/>
		<memberdata name="getkeyforcurrentnoderefid" type="method" display="GetKeyForCurrentNodeRefID"/>
		<memberdata name="expandallparents" type="method" display="ExpandAllParents"/>
		<memberdata name="jumptoitem" type="method" display="JumpToItem"/>
		<memberdata name="refreshtree" type="method" display="RefreshTree"/>
		<memberdata name="goback" type="method" display="GoBack"/>
		<memberdata name="stackisempty" type="method" display="StackIsEmpty"/>
		<memberdata name="laddkeys" type="property" display="lAddKeys"/>
		<memberdata name="laddkeys_assign" type="method" display="lAddKeys_Assign"/>
		<memberdata name="nsavedheight" display="nSavedHeight"/>
		<memberdata name="osettings" display="oSettings"/>
		<memberdata name="lshownative" display="lShowNative"/>
		<memberdata name="lshowinherited" display="lShowInherited"/>
		<memberdata name="lshowcustom" display="lShowCustom"/>
		<memberdata name="lshownondefault" display="lShowNonDefault"/>
		<memberdata name="read_vfp_keywords" display="Read_VFP_Keywords"/>
		<memberdata name="spellkeyword" display="SpellKeyword"/>
		<memberdata name="ngridrowheight" display="nGridRowHeight"/>
		</VFPData>
	oSplitter.Anchor = 7
	oSplitter.Height = 331
	oSplitter.Left = 277
	oSplitter.Name = "oSplitter"
	oSplitter.Top = 0
	opersist.Left = 0
	opersist.Name = "opersist"
	oTreeViewContainer.Anchor = 7
	oTreeViewContainer.ccursorstructure = ID C(240), TYPE C(60), PARENTID C(240), PARENTTYPE C(60), TEXT C(60), IMAGE C(20), SELIMAGE C(20), EXPIMAGE C(20), SORTED L, NODEKEY C(240), PAGE N(1), RefID C(240)
	oTreeViewContainer.Height = 311
	oTreeViewContainer.Left = -2
	oTreeViewContainer.Name = "oTreeViewContainer"
	oTreeViewContainer.nautoexpand = 1
	oTreeViewContainer.oImageList.Left = 160
	oTreeViewContainer.oImageList.Name = "oImageList"
	oTreeViewContainer.oImageList.Top = 0
	oTreeViewContainer.oStack.Name = "oStack"
	oTreeViewContainer.oTree.Height = 275
	oTreeViewContainer.oTree.Name = "oTree"
	oTreeViewContainer.oTree.Width = 210
	oTreeViewContainer.tmrReload.Name = "tmrReload"
	oTreeViewContainer.tmrSync.Name = "tmrSync"
	oTreeViewContainer.Top = -2
	oTreeViewContainer.Width = 277
	pgfProperties.Anchor = 15
	pgfProperties.ErasePage = .T.
	pgfProperties.Height = 331
	pgfProperties.Left = 287
	pgfProperties.Name = "pgfProperties"
	pgfProperties.PageCount = 4
	pgfProperties.sfpage1.Name = "sfpage1"
	pgfProperties.Sfpage2.Caption = "Sfpage2"
	pgfProperties.Sfpage2.Name = "Sfpage2"
	pgfProperties.Sfpage3.Caption = "Sfpage3"
	pgfProperties.Sfpage3.Name = "Sfpage3"
	pgfProperties.Sfpage4.Caption = "Sfpage4"
	pgfProperties.Sfpage4.Name = "Sfpage4"
	pgfProperties.Top = -1

	ADD OBJECT 'lblCount' AS sflabel WITH ;
		Anchor = 4, ;
		Caption = "Count", ;
		FontSize = 8, ;
		Left = 15, ;
		Name = "lblCount", ;
		Top = 313
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="label" />

	ADD OBJECT 'pgfProperties.sfpage1.cntCollectionInfo' AS cntcollectioninfo WITH ;
		Height = 325, ;
		Left = 0, ;
		Name = "cntCollectionInfo", ;
		Top = 1, ;
		Width = 461, ;
		grdProperties.grcProperty.hdrProperty.Name = "hdrProperty", ;
		grdProperties.grcProperty.Name = "grcProperty", ;
		grdProperties.grcProperty.txtProperty.Name = "txtProperty", ;
		grdProperties.grcProperty.Width = 142, ;
		grdProperties.grcType.hdrType.Name = "hdrType", ;
		grdProperties.grcType.Name = "grcType", ;
		grdProperties.grcType.txtType.Name = "txtType", ;
		grdProperties.grcValue.edtValue.Name = "edtValue", ;
		grdProperties.grcValue.hdrValue.Name = "hdrValue", ;
		grdProperties.grcValue.Name = "grcValue", ;
		grdProperties.Height = 268, ;
		grdProperties.Left = 10, ;
		grdProperties.Name = "grdProperties", ;
		grdProperties.Top = 34, ;
		grdProperties.Width = 440, ;
		lblCount.Name = "lblCount", ;
		txtCount.Name = "txtCount", ;
		Objectfiltercheckbox1.Alignment = 0, ;
		Objectfiltercheckbox1.Left = 22, ;
		Objectfiltercheckbox1.Name = "Objectfiltercheckbox1", ;
		Objectfiltercheckbox1.Top = 306, ;
		Objectfiltercheckbox2.Alignment = 0, ;
		Objectfiltercheckbox2.Left = 104, ;
		Objectfiltercheckbox2.Name = "Objectfiltercheckbox2", ;
		Objectfiltercheckbox2.Top = 306, ;
		Objectfiltercheckbox3.Alignment = 0, ;
		Objectfiltercheckbox3.Left = 202, ;
		Objectfiltercheckbox3.Name = "Objectfiltercheckbox3", ;
		Objectfiltercheckbox3.Top = 306, ;
		Objectfiltercheckbox4.Alignment = 0, ;
		Objectfiltercheckbox4.Left = 301, ;
		Objectfiltercheckbox4.Name = "Objectfiltercheckbox4", ;
		Objectfiltercheckbox4.Top = 306
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProperties.Sfpage2.cntObjectInfo' AS cntobjectinfo WITH ;
		Height = 325, ;
		Left = -1, ;
		Name = "cntObjectInfo", ;
		Top = 0, ;
		Width = 461, ;
		grdproperties.grcProperty.hdrProperty.Name = "hdrProperty", ;
		grdproperties.grcProperty.Name = "grcProperty", ;
		grdproperties.grcProperty.txtProperty.Name = "txtProperty", ;
		grdproperties.grcProperty.Width = 142, ;
		grdproperties.grcType.hdrType.Name = "hdrType", ;
		grdproperties.grcType.Name = "grcType", ;
		grdproperties.grcType.txtType.Name = "txtType", ;
		grdproperties.grcType.Width = 36, ;
		grdproperties.grcValue.edtValue.Name = "edtValue", ;
		grdproperties.grcValue.hdrValue.Name = "hdrValue", ;
		grdproperties.grcValue.Name = "grcValue", ;
		grdproperties.Height = 296, ;
		grdproperties.Name = "grdproperties", ;
		Objectfiltercheckbox1.Alignment = 0, ;
		Objectfiltercheckbox1.Left = 22, ;
		Objectfiltercheckbox1.Name = "Objectfiltercheckbox1", ;
		Objectfiltercheckbox1.Top = 306, ;
		Objectfiltercheckbox2.Alignment = 0, ;
		Objectfiltercheckbox2.Left = 104, ;
		Objectfiltercheckbox2.Name = "Objectfiltercheckbox2", ;
		Objectfiltercheckbox2.Top = 306, ;
		Objectfiltercheckbox3.Alignment = 0, ;
		Objectfiltercheckbox3.Left = 202, ;
		Objectfiltercheckbox3.Name = "Objectfiltercheckbox3", ;
		Objectfiltercheckbox3.Top = 306, ;
		Objectfiltercheckbox4.Alignment = 0, ;
		Objectfiltercheckbox4.Left = 301, ;
		Objectfiltercheckbox4.Name = "Objectfiltercheckbox4", ;
		Objectfiltercheckbox4.Top = 306
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProperties.Sfpage3.cntScalar' AS cntscalar WITH ;
		Height = 305, ;
		Left = 0, ;
		Name = "cntScalar", ;
		Top = 0, ;
		lblType.Name = "lblType", ;
		txtType.Name = "txtType", ;
		lblValue.Name = "lblValue", ;
		txtValue.Height = 246, ;
		txtValue.Name = "txtValue"
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="container" />

	ADD OBJECT 'pgfProperties.Sfpage4.cntBackFeference' AS cntbackreference WITH ;
		Height = 305, ;
		Left = 0, ;
		Name = "cntBackFeference", ;
		Top = 0, ;
		lblBackLink.Name = "lblBackLink"
		*< END OBJECT: ClassLib="inspector.vcx" BaseClass="container" />
	
	PROCEDURE addcollectionmemberstotreeviewcursor
		* Add the members of a collection to the tree view cursor.
		* This method can be called recursively.
		LPARAMETERS oCollection, cParentKey, cParentType, cAlias, nLevel
		
		IF PCOUNT() < 5
			nLevel = 1
		ENDIF
		
		* Make the compiler happy
		EXTERNAL ARRAY oCollection
		
		* Now, the members
		LOCAL nItem, oObject, cKey, cLabel, lIsClass, cID, cItemType, nPage, cRefID, lIsCollection, laObjectInfo(1), nToDrillDown
		
		This.LogIt("Adding members of collection " + oCollection.Name)
		
		*!*	Dimension laObjectInfo[Max(oCollection.Count, 1), 3]
		
		nToDrillDown = 0
		
		FOR nItem = 1 TO oCollection.Count
			cLabel = "Item[" + TRANSFORM(m.nItem) + "]"
			cKey = oCollection.GetKey(m.nItem)
			IF NOT EMPTY(m.cKey)
				cLabel = m.cLabel +  "/" + m.cKey
			ENDIF
			cID = m.cParentKey + "/#" + TRANSFORM(m.nItem)
			
			lIsClass = (VARTYPE(oCollection[m.nItem]) = "O")
			
			* Modified 7-June-2010 by TEG
			* If it's a class, check whether it's a collection
			IF m.lIsClass
				lIsCollection = (PEMSTATUS(oCollection[m.nItem], "BaseClass", 5) AND UPPER(oCollection[m.nItem].BaseClass) = "COLLECTION")
			ENDIF 
			
			* If this is an object, check whether it's already in the 
			* items we've visited. If so, categorize it differently 
			* and don't drill down.
			cRefID = ""
			IF m.lIsClass
				cRefID = This.oItemsVisited.GetItemKey(oCollection[m.nItem])
				IF NOT EMPTY(m.cRefID)
		*!*				This.LogIt(  "Item " + TRANSFORM(m.nItem) + " was previously added.")
					cItemType = "Previous"
					nPage = 4
				ELSE
		*!*				This.LogIt(  "Item " + TRANSFORM(m.nItem) + " is an object.")
					* Modified 7-June-2010 by TEG
					* Handle collections correctly
		
					IF m.lIsCollection
						cItemType = "Collection"
						nPage = 1
					ELSE
						cItemType = "Class"
						nPage = 2
					ENDIF 
				ENDIF
			ELSE
				This.LogIt(  "Item " + TRANSFORM(m.nItem) + " is scalar.")
				cItemType = "Nothing"
				nPage = 3
			ENDIF 
			
			INSERT INTO (m.cAlias) ;	
				(ID, PARENTID, PARENTTYPE, ;
				 TYPE, TEXT, IMAGE, ;
				 SORTED, PAGE, REFID, ;
				 NODEKEY) ;
				VALUES ;
				(m.cID, m.cParentKey, m.cParentType, ;
				 "ITEM", m.cLabel, m.cItemType, ;
				 .F., m.nPage, m.cRefID, ;
				 This.oTreeViewContainer.GetNodeKey("ITEM", m.cID))
		
			* Modified 7-June-2010 by TEG
			* There are now two values of cItemType we want to pursue
			IF m.lIsClass AND m.cItemType <> "Previous"
				This.oItemsVisited.AddItemVisited(oCollection[m.nItem], m.cParentKey, m.cID, "ITEM")
			ENDIF 
			
			* Modified 17-July-2012 by TEG
			* Try breadth-first search
			nToDrillDown = m.nToDrillDown + 1 
			DIMENSION laObjectInfo[m.nToDrillDown, 4]
			laObjectInfo[m.nToDrillDown, 1] = m.lIsClass
			laObjectInfo[m.nToDrillDown, 2] = m.cItemType 
			laObjectInfo[m.nToDrillDown, 3] = m.cID
			laObjectInfo[m.nToDrillDown, 4] = m.nItem
		EndFor
		
		LOCAL nDrillDownItem
		
		FOR nDrillDownItem = 1 TO m.nToDrillDown && oCollection.Count
		
			m.lIsClass   = laObjectInfo[m.nDrillDownItem, 1] 
			m.cItemType  = laObjectInfo[m.nDrillDownItem, 2] 
			m.cID        = laObjectInfo[m.nDrillDownItem, 3] 
			nItem = laObjectInfo[m.nDrillDownItem, 4] 
			
			* Is this member a collection? Need to check whether there is a 
			* BaseClass property, since the item might have been created from Empty class.
			IF m.cItemType = "Collection" && PEMSTATUS(oCollection[m.nItem], "BaseClass", 5) AND UPPER(oCollection[m.nItem].BaseClass) = "COLLECTION"
				This.AddCollectionMembersToTreeViewCursor(oCollection[m.nItem], m.cID, "ITEM", m.cAlias, m.nLevel + 1)
			ENDIF
			
			* More likely is that one or more properties are collections or objects.
			IF m.cItemType = "Class"
				This.FindObjectPropertiesForTreeViewCursor(oCollection[m.nItem], m.cID, "ITEM", m.cAlias, m.nLevel + 1)
			ENDIF 
			
		ENDFOR 
		
	ENDPROC

	PROCEDURE addcollectionpropertytotreeviewcursor		&& Add a property that contains a collection to the treeview cursor, and then add its members.
		* Add a collection that's a property of an item to the tree view cursor.
		* Then add its members
		LPARAMETERS oCollection, cPropName, cParentKey, cParentType, cAlias, nLevel
		
		LOCAL cLabel, cID, cItemType, nPage, cRefID
		
		This.LogIt("Adding collection " + oCollection.Name + " referenced by property " + m.cPropName)
		cLabel = m.cPropName
		cID = m.cParentKey + "/" + m.cPropName
		
		* Figure out whether we're seen this collection before
		* and if so, handle it differently
		cRefID = This.oItemsVisited.GetItemKey(m.oCollection)
		IF NOT EMPTY(m.cRefID)
		*!*		This.LogIt(  "The object referenced by this property was previously added.")
			cItemType = "Previous"
			nPage = 4
		ELSE
		*!*		This.LogIt(  "Collection is new.")
			cItemType = "Collection"
			nPage = 1
		ENDIF
		
		INSERT INTO (m.cAlias) ;
			(ID, PARENTID, PARENTTYPE, ;
			 TYPE, TEXT, IMAGE, ;
			 SORTED, PAGE, REFID, ;
			 NODEKEY) ;
			VALUES ;
			(m.cID, m.cParentKey, m.cParentType, ;
			 "PROPERTY", m.cLabel, m.cItemType, ;
			 .F., m.nPage, m.cRefID, ;
			 This.oTreeViewContainer.GetNodeKey("PROPERTY", m.cID))
			 
		IF m.cItemType = "Collection"	 
			This.oItemsVisited.AddItemVisited(m.oCollection, m.cParentKey, m.cID, "PROPERTY")
		
			* Modified 17-July-2012 by TEG
			* Defer this for breadth-first search
			* Now add its members
			* This.AddCollectionMembersToTreeViewCursor(m.oCollection, m.cID, "PROPERTY", m.cAlias, m.nLevel + 1)
		ENDIF
		
		RETURN IIF(m.cItemType = "Collection", m.cID, "")
		
	ENDPROC

	PROCEDURE addobjectpropertytotreeviewcursor		&& Add an object property to the treeview cursor, so it can be used for drilldown
		* Add an object that's a property of an item to the tree view cursor.
		* Then add its properties
		LPARAMETERS oObject, cPropName, cParentKey, cParentType, cAlias, nLevel
		
		LOCAL cLabel, cID, cItemType, nPage, cName, cRefID
		
		IF PEMSTATUS(oObject, "Name", 5)
			cName = oObject.Name
		ELSE
			cName = "UNNAMED"
		ENDIF 
		
		This.LogIt("Adding object " + m.cName + " referenced by property " + m.cPropName)
		
		cLabel = m.cPropName
		cID = m.cParentKey + "/" + m.cPropName
		
		* Check whether we've seen it before, and if so,
		* categorize appropriately and avoid drilldown
		
		cRefID = This.oItemsVisited.GetItemKey(m.oObject)
		IF NOT EMPTY(m.cRefID)
		*!*		This.LogIt("  This object was previously added.")
			cItemType = "Previous"
			nPage = 4
			If m.cPropName == 'PARENT'
				Return ''
			EndIf 
		ELSE
		*!*		This.LogIt("  This object is new.")
			cItemType = "Class"
			nPage = 2
		ENDIF 
		
		* correct case of name, if possible / JRN / 2013-11-30
		IF PEMSTATUS(oObject, "Name", 5) and not PEMSTATUS(oObject, "Name", 4)
			Do Case
				Case Upper(m.cLabel) == Upper(m.cName)
					cLabel = m.cName
				Case m.cLabel == 'PARENT'
				    cLabel = 'Parent (' + m.cName + ')'
			Endcase
		EndIf 
		
		INSERT INTO (m.cAlias) ;
			(ID, PARENTID, PARENTTYPE, ;
			 TYPE, TEXT, IMAGE, ;
			 SORTED, PAGE, REFID, ;
			 NODEKEY) ;
			VALUES ;
			(m.cID, m.cParentKey, m.cParentType, ;
			 "PROPERTY", m.cLabel, m.cItemType, ;
			 .F., m.nPage, m.cRefID, ;
			 This.oTreeViewContainer.GetNodeKey("PROPERTY", m.cID))
		
		IF m.cItemType = "Class"
			This.oItemsVisited.AddItemVisited(m.oObject, m.cParentKey, m.cID, "PROPERTY")
			 
			* Modified 17-July-2012 by TEG
			* Defer this for breadth-first search
		
			* Now add its members
		*!*		This.FindObjectPropertiesForTreeViewCursor(m.oObject, m.cID, "PROPERTY", m.cAlias, m.nLevel + 1)
		ENDIF 
		
		RETURN IIF(m.cItemType="Class", m.cID, "")
		
	ENDPROC

	PROCEDURE addtoitemsvisited		&& Add an item to the collection of items visited
	ENDPROC

	PROCEDURE Destroy
		If 'O' = Type('Thisform.oSettings')
		
			*!* ******************** Removed 12/1/2013 ********************
			*!* This.nSavedHeight  = This.Height + This.oToolbar.Height + This.oStatus.Height
			This.nSavedHeight  = This.Height + This.oToolbar.Height
			*!* ******************** End of duplicated text ********************
			This.nSplitterLeft = This.oSplitter.Left
		
			This.oSettings.Save(Thisform)
			This.oSettings = .Null.
		Endif
		
		DoDefault()
		
	ENDPROC

	PROCEDURE displayproperties
		lparameters tnPage
		
		DODEFAULT(m.tnPage)
		
		* Modified 7-December-2010 by TEG
		* In some cases, the grid shows as empty after the above.
		* But taking focus off the form and putting it back cures it.
		* So this code forces focus off the inspector form and then
		* restores it.
		LOCAL oTempForm as Form
		
		oTempForm = NEWOBJECT("frmGrabFocus", "Inspector")
		oTempForm.Left = -1000
		oTempForm.Width = 5
		oTempForm.Show()
		oTempForm.Release()
		
		RETURN
		
	ENDPROC

	PROCEDURE expandallparents		&& Expand all parents of the node with the specified key.
		* Expand all parents of the item with the specified key.
		LPARAMETERS cKey
		
		LOCAL lExpanded, aKeys[1], nToBeExpanded, cAlias
		* Work upwards from the key, until we find a node that was previously expanded.
		
		lExpanded = .F.
		cAlias = This.oTreeViewContainer.cCursorAlias
		
		* Put the first item into the array
		aKeys[1] = m.cKey
		nToBeExpanded = 1
		
		* Go to record for the specified key
		SEEK m.cKey ORDER NODEKEY IN (m.cAlias)
		
		DO WHILE NOT m.lExpanded
		
			TRY
				oItem = This.oTreeViewContainer.oTree.Nodes[m.cKey]
				* If we're still here, the item exists and thus must have been expanded.
				lExpanded = .T.
		
			CATCH 
				* Find the parent of this item.
				cParentID = ALLTRIM(EVALUATE(m.cAlias + ".ParentID"))
				IF SEEK(m.cParentID, m.cAlias, "ID")
					cKey = ALLTRIM(EVALUATE(m.cAlias + ".NodeKey"))
		
					* Add this item to the list to expand
					nToBeExpanded = m.nToBeExpanded + 1 
					DIMENSION aKeys[m.nToBeExpanded]
					aKeys[m.nToBeExpanded] = m.cKey	
		
				ELSE
					* Get out of here. There's nothing more we can do.
					lExpanded = .T.
				ENDIF
		
			ENDTRY 
		ENDDO 
		
		* Now go backwards through the array and expand
		FOR nItem = m.nToBeExpanded TO 1 STEP -1
			This.oTreeViewContainer.TreeExpand(aKeys[m.nItem], .T.)
		ENDFOR 
		
		RETURN
		
	ENDPROC

	PROCEDURE findobjectpropertiesfortreeviewcursor		&& Look through an object to find any properties that are objects or collections, so they can be added to the treeview cursor.
		LPARAMETERS oObject, cParentKey, cParentType, cAlias, nLevel
		
		LOCAL aProps[1], nPropCount, nProp, oChildObject, cName, cType
		
		
		IF PEMSTATUS(oObject, "Name", 5)
			cName = oObject.Name
		ELSE
			cName = "UNNAMED"
		ENDIF 
		*!*	This.LogIt("Checking properties of object " + m.cName + " for objects and collections")
		
		* Modified 17-July-2012 by TEG
		* Try breadth-first search
		LOCAL aObjectInfo[1], nToDrillDown, nDrillDownItem, cID
		nToDrillDown = 0
		
		* Modified 17-July-2012 by TEG
		* Pick up controls, too.
		
		nPropCount = AMEMBERS(aProps, m.oObject, 1)
		FOR nProp = 1 TO m.nPropCount
			Try 
				cType = Type("oObject." + aProps[m.nProp, 1])
			Catch to loException
				cType = 'U'
			EndTry
			If Evl(m.cType, 'U') = 'U'
				Loop
			EndIf
			
			IF (aProps[m.nProp, 2] = "Property" AND TYPE("oObject." + aProps[m.nProp, 1]) = "O") OR ;
			   (aProps[m.nProp, 2] = "Object")
				oChildObject = EVALUATE("oObject." + aProps[m.nProp, 1])
				* Want to omit COM and null objects
				IF NOT ISNULL(m.oChildObject)
					DO CASE 
					CASE PEMSTATUS(m.oChildObject, "BaseClass", 5) AND UPPER(oChildObject.BaseClass) = "COLLECTION"
						cID = This.AddCollectionPropertyToTreeViewCursor(m.oChildObject, aProps[m.nProp,1], m.cParentKey, m.cParentType, m.cAlias, m.nLevel + 1)
		
						* Modified 17-July-2012 by TEG
						* Put this item in the list for follow-up
						IF NOT EMPTY(m.cID)
							nToDrillDown = m.nToDrillDown + 1 
							DIMENSION aObjectInfo[m.nToDrillDown, 3]
		
							aObjectInfo[m.nToDrillDown, 1] = "AddCollectionMembersToTreeViewCursor"
							aObjectInfo[m.nToDrillDown, 2] = m.oChildObject
							aObjectInfo[m.nToDrillDown, 3] = m.cID
						ENDIF 
		
					CASE ALLTRIM(COMCLASSINFO(m.oChildObject, 5)) = "1" 
						IF NOT PEMSTATUS(m.oChildObject, "Name", 5) OR NOT UPPER(m.oChildObject.Name) = "XFCSYSTEM"
							* Omit GDIPlusX stuff to avoid trouble
							cID = This.AddObjectPropertyToTreeViewCursor(m.oChildObject, aProps[m.nProp,1], m.cParentKey, m.cParentType, m.cAlias, m.nLevel + 1)
							
							* Modified 17-July-2012 by TEG
							* Put this item in the list for follow-up
							IF NOT EMPTY(m.cID)
								nToDrillDown = m.nToDrillDown + 1 
								DIMENSION aObjectInfo[m.nToDrillDown, 3]
		
								aObjectInfo[m.nToDrillDown, 1] = "FindObjectPropertiesForTreeViewCursor"
								aObjectInfo[m.nToDrillDown, 2] = m.oChildObject
								aObjectInfo[m.nToDrillDown, 3] = m.cID
							ENDIF 
						ENDIF 
					OTHERWISE
						* COM object. Don't add it.
					ENDCASE 
				ENDIF 
			ENDIF
		ENDFOR
		
		* Modified 17-July-2012 by TEG
		* Now drill down
		LOCAL cMethod, cCommand
		FOR nDrillDownItem = 1 TO m.nToDrillDown
			cMethod = aObjectInfo[m.nDrillDownItem, 1]
			oChildObject = aObjectInfo[m.nDrillDownItem, 2]
			cID = aObjectInfo[m.nDrillDownItem, 3]
			
			TEXT TO m.cCommand NOSHOW TEXTMERGE 
			This.<<m.cMethod>>( m.oChildObject, m.cID, "PROPERTY", m.cAlias, m.nLevel + 1)
			ENDTEXT 
			
			&cCommand
		ENDFOR 
		
		RETURN 
	ENDPROC

	PROCEDURE getkeyforcurrentnoderefid		&& Return the key for the node referenced by the current node's RefID field.
		LOCAL cParentKey, cAlias
		
		* Find the row for the current node
		cAlias = This.oTrEEVIEWCONTAINER.cCursorAlias
		IF SEEK(This.cCurrentNodeID, m.cAlias, "ID")
			cParentKey = TRIM(EVALUATE(m.cAlias + ".RefID"))
		ENDIF 
		
		RETURN m.cParentKey
	ENDPROC

	PROCEDURE goback		&& Go back to the previously chosen item in the tree
		* Delegate to the tree view
		This.oTreeViewContainer.GoBack()
	ENDPROC

	PROCEDURE Init
		Lparameters oRoot, cRootName, lDontAddKeys
		Local loSettings As Object
		Local lnAnchor
		
		This.oRoot	   = m.oRoot
		This.cRootName = Evl(m.cRootName, This.cRootName)
		This.lAddKeys  = Not m.lDontAddKeys
		
		This.Read_VFP_Keywords()
		*** JRN 11/22/2011 : Code to restore size / position of form
		* ThorFormSettings home page = http://vfpx.codeplex.com/wikipage?title=Thor%20Framework%20FormSettings
		
		If 'C' = Type('_Screen.cThorDispatcher')
			loSettings    = Execscript(_Screen.cThorDispatcher, 'Class= ThorFormSettings', 'ObjectInspector')
			Thisform.oSettings = loSettings
		
			loSettings.Restore(Thisform)
			loSettings.Restore(Thisform, 'nSavedHeight, nSplitterLeft, lShowNative, lShowInherited, lShowCustom, lShowNonDefault')
			This.nGridRowHeight = ExecScript(_Screen.cThorDispatcher, "Get Option=", 'Grid Row Height', 'Object and Collection Inspector')
		Endif
		
		If Not Empty(Thisform.nSavedHeight)
			Thisform.Height = Thisform.nSavedHeight
		Endif
		If Not Empty(Thisform.nSplitterLeft)
			With Thisform.oSplitter
				lnAnchor = .Anchor
				.Anchor	 = 0
				.Left	 = Thisform.nSplitterLeft
				.Anchor	 = lnAnchor
			Endwith
		Endif
		*** JRN 11/22/2011
		
		DoDefault()
		
		Return
		
	ENDPROC

	PROCEDURE jumptoitem		&& Jump to the child of the current item with the specified name.
		* Jump in the treeview to the child of the
		* current item whose name is passed as parameter.
		
		LPARAMETERS cName
		
		LOCAL oCurrentNode, oChildren, oChild, lFound
		
		* Get info about current node
		oCurrentNode = This.otreeViewContainer.GetTypeAndIDFromNode(This.otreeViewContainer.oSelectedNode)
		
		* Get children of current node
		oChildren = CREATEOBJECT("Collection")
		This.oTreeViewContainer.GetChildNodes(oCurrentNode.Type, oCurrentNode.ID, oChildren)
		
		* Find the child we're interested in
		lFound = .F.
		FOR EACH oChild IN m.oChildren FOXOBJECT 
			IF UPPER(oChild.Text) = UPPER(m.cName)
				lFound = .T.
				EXIT
			ENDIF 
		ENDFOR 
		
		IF m.lFound
			* Make sure current node is expanded
			This.oTreeViewContainer.TreeExpand(This.otreeViewContainer.oSelectedNode, .T.)
			
			This.oTreeViewContainer.SelectNode(m.oChild)
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode,  tnShiftAltCtrl
		
		DODEFAULT(m.tnKeyCode, m.tnShiftAltCtrl)
		
		DO CASE 
		CASE  m.tnKeyCode = 127
			This.GoBack()
			NODEFAULT 
		CASE m.tnKeyCode = -4 && F5
			This.RefreshTree()
		ENDCASE 
		
		RETURN
		
	ENDPROC

	PROCEDURE laddkeys_assign
		lparameters tuNewValue
		This.lAddKeys = tuNewValue
		
		* Propagate to ItemsVisited collection
		IF NOT ISNULL(This.oItemsVisited) AND PEMSTATUS(This.oItemsVisited, "lAddToObject", 5)
			This.oItemsVisited.lAddToObject = This.lAddKeys
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE Load
		DODEFAULT()
		
		This.LogIt("Opening inspector form", .T.)
	ENDPROC

	PROCEDURE logit		&& Write the string passed in to a log file
		LPARAMETERS cLogString, lStartNewLogFile
		
		IF EMPTY(This.cLogFile)
			This.cLogFile = FORCEPATH("Inspector.Log", SYS(2023))
		ENDIF
		
		STRTOFILE(TTOC(DATETIME()) + ":" + m.cLogString + CHR(13) + CHR(10), This.cLogFile, not m.lStartNewLogFile)
		
		RETURN
		
	ENDPROC

	PROCEDURE read_vfp_keywords
		If Not Used('crsr_VFP_Keywords')
			Try
				Use Home() + 'WIZARDS\FDKEYWRD' Order TOKEN Again Shared In 0 Alias Keywords
				Select TOKEN From Keywords Into Cursor crsr_VFP_Keywords Readwrite
				Index On Upper(TOKEN) Tag TOKEN
				Use In Keywords
			Catch
			Endtry
		Endif
		
	ENDPROC

	PROCEDURE Refresh
		DODEFAULT()
		
		IF NOT ISNULL(This.oToolbar)
			This.oToolbar.Refresh()
		ENDIF 
	ENDPROC

	PROCEDURE refreshtree		&& Refresh the data in the treeview
		This.oTreeViewContainer.LoadTree()
		This.Refresh()
	ENDPROC

	PROCEDURE spellkeyword
		Lparameters lcKeyWord
		
		If Used('crsr_VFP_Keywords') And Seek(Upper(lcKeyWord), 'crsr_VFP_Keywords') 
			Return Alltrim(crsr_VFP_Keywords.Token)
		Else
			Return lcKeyWord
		Endif
		
	ENDPROC

	PROCEDURE stackisempty		&& Returns a value to indicate whether the stack of past actions is empty
		LOCAL lReturn
		
		lReturn = (This.oTreeViewContainer.oStack.Count = 0)
		
		RETURN m.lReturn
		
	ENDPROC

	PROCEDURE lblCount.Init
		This.Caption = [cnVersion] + ' - ' + [cdVersionDate]
	ENDPROC

	PROCEDURE oTreeViewContainer.filltreeviewcursor
		* Fill the cursor with info about the collection
		
		ThisForm.LogIt("In " + PROGRAM() + "; starting to traverse hierarchy")
		
		* Set up the collection to track items we've seen,
		* to avoid infinite recursion
		ThisForm.oItemsVisited = NEWOBJECT("colItemsVisited", "ItemsVisited.PRG", "", ThisForm)
		ThisForm.oItemsVisited.lAddToObject = ThisForm.lAddKeys
		
		* First, the root item
		
		IF PEMSTATUS(ThisForm.oRoot, "BaseClass", 5) AND UPPER(ThisForm.oRoot.BaseClass) = "COLLECTION"
			INSERT INTO (This.cCursorAlias) ;
				(ID, TYPE, TEXT, IMAGE, SORTED, PAGE, NODEKEY, REFID) ;
				VALUES ;
				( "ROOT" , "TOP", ThisForm.cRootName, "Collection", .F., 1, This.GetNodeKey("TOP", "ROOT"), "")
			ThisForm.oItemsVisited.AddItemVisited(ThisForm.oRoot, "", "ROOT", "TOP")
				
			ThisForm.AddCollectionMembersToTreeViewCursor(ThisForm.oRoot, "ROOT", "TOP", This.cCursorAlias)
		ELSE
			INSERT INTO (This.cCursorAlias) ;
				(ID, TYPE, TEXT, IMAGE, SORTED, PAGE, NODEKEY, REFID) ;
				VALUES ;
				( "ROOT" , "TOP", ThisForm.cRootName, "Class", .F., 2, This.GetNodeKey("TOP", "ROOT"), "")
			ThisForm.oItemsVisited.AddItemVisited(ThisForm.oRoot, "", "ROOT", "TOP")
				
			ThisForm.FindObjectPropertiesForTreeViewCursor(ThisForm.oRoot, "ROOT", "TOP", This.cCursorAlias, 1)
		ENDIF 
		
		ThisForm.LogIt("Finished traversal of objects.")
		ThisForm.LogIt("  Number of items identified for treeview = " + TRANSFORM(RECCOUNT(This.cCursorAlias)))
		ThisForm.LogIt("  Number of objects/collections visited = " + TRANSFORM(ThisForm.oItemsVisited.Count))
		
		RETURN
		
	ENDPROC

	PROCEDURE oTreeViewContainer.loadimages
		This.oImageList.ListImages.Add(1, "Collection", LOADPICTURE("Graphics\Collection.bmp"))
		This.oImageList.ListImages.Add(2, "Class", LOADPICTURE("Graphics\Class.bmp"))
		This.oImageList.ListImages.Add(3, "Nothing", LOADPICTURE("Graphics\Nothing.gif"))
		This.oImageList.ListImages.Add(4, "Previous", LOADPICTURE("Graphics\Arw02Lt.ico"))
	ENDPROC

ENDDEFINE

DEFINE CLASS objectfiltercheckbox AS sfcheckbox OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Alignment = 0
	Anchor = 4
	Name = "objectfiltercheckbox"
	
	PROCEDURE Valid
		This.Parent.Parent.Refresh()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tbrinspector AS sftoolbar OF "sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdRefresh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="sfseparator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGoBack" UniqueID="" Timestamp="" />

	Height = 38
	Left = -1
	Name = "tbrinspector"
	ShowWindow = 1
	Top = -2
	Width = 81

	ADD OBJECT 'cmdGoBack' AS sfcommandbutton WITH ;
		Caption = "", ;
		Height = 32, ;
		Left = 44, ;
		Name = "cmdGoBack", ;
		Picture = graphics\arw05lt.ico, ;
		ToolTipText = "Go back", ;
		Top = 3, ;
		Width = 32, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRefresh' AS sfcommandbutton WITH ;
		Caption = "", ;
		Height = 32, ;
		Left = 5, ;
		Name = "cmdRefresh", ;
		Picture = graphics\refresh.ico, ;
		ToolTipText = "Refresh", ;
		Top = 3, ;
		Width = 32, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'sfseparator1' AS sfseparator WITH ;
		Height = 0, ;
		Left = 44, ;
		Name = "sfseparator1", ;
		Top = 3, ;
		Width = 0
		*< END OBJECT: ClassLib="sfctrls.vcx" BaseClass="separator" />
	
	PROCEDURE cmdGoBack.Click
		_screen.ActiveForm.GoBack()
	ENDPROC

	PROCEDURE cmdGoBack.Refresh
		IF _screen.ActiveForm.StackIsEmpty()
			This.Enabled = .F.
		ELSE
			This.Enabled = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE cmdRefresh.Click
		_screen.ActiveForm.RefreshTree()
	ENDPROC

ENDDEFINE
